
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 b9 e3 00 00       	call   80e3ea <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 b7 a4 00 00       	call   80a4ff <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 00 a5 00 00       	call   80a56d <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	79 1b                	jns    80008f <start_timer+0x42>
		panic("cannot create timer thread: %s", e2s(r));
  800074:	83 ec 0c             	sub    $0xc,%esp
  800077:	50                   	push   %eax
  800078:	e8 2c a8 00 00       	call   80a8a9 <e2s>
  80007d:	50                   	push   %eax
  80007e:	68 80 0c 81 00       	push   $0x810c80
  800083:	6a 7a                	push   $0x7a
  800085:	68 b5 0d 81 00       	push   $0x810db5
  80008a:	e8 bb e3 00 00       	call   80e44a <_panic>
}
  80008f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800092:	c9                   	leave  
  800093:	c3                   	ret    

00800094 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi

	for (;;) {
		uint32_t cur = sys_time_msec();
  80009c:	e8 fb ef 00 00       	call   80f09c <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx

		lwip_core_lock();
  8000a3:	e8 1e a4 00 00       	call   80a4c6 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 1b a4 00 00       	call   80a4cb <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 57 a6 00 00       	call   80a716 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 0b 01 00 00    	ja     8001e7 <serve_thread+0x123>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 60 0e 81 00 	jmp    *0x810e60(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 ea 0d 00 00       	call   800ee7 <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 2c eb 00 00       	call   80ec3a <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
  800111:	e9 ec 00 00 00       	jmp    800202 <serve_thread+0x13e>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800116:	83 ec 04             	sub    $0x4,%esp
  800119:	ff 76 14             	pushl  0x14(%esi)
  80011c:	8d 46 04             	lea    0x4(%esi),%eax
  80011f:	50                   	push   %eax
  800120:	ff 36                	pushl  (%esi)
  800122:	e8 6f 0f 00 00       	call   801096 <lwip_bind>
  800127:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  800129:	83 c4 10             	add    $0x10,%esp
  80012c:	e9 d1 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800131:	83 ec 08             	sub    $0x8,%esp
  800134:	ff 76 04             	pushl  0x4(%esi)
  800137:	ff 36                	pushl  (%esi)
  800139:	e8 5b 1a 00 00       	call   801b99 <lwip_shutdown>
  80013e:	89 c7                	mov    %eax,%edi
		break;
  800140:	83 c4 10             	add    $0x10,%esp
  800143:	e9 ba 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800148:	83 ec 0c             	sub    $0xc,%esp
  80014b:	ff 36                	pushl  (%esi)
  80014d:	e8 fa 0f 00 00       	call   80114c <lwip_close>
  800152:	89 c7                	mov    %eax,%edi
		break;
  800154:	83 c4 10             	add    $0x10,%esp
  800157:	e9 a6 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80015c:	83 ec 04             	sub    $0x4,%esp
  80015f:	ff 76 14             	pushl  0x14(%esi)
  800162:	8d 46 04             	lea    0x4(%esi),%eax
  800165:	50                   	push   %eax
  800166:	ff 36                	pushl  (%esi)
  800168:	e8 68 10 00 00       	call   8011d5 <lwip_connect>
  80016d:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80016f:	83 c4 10             	add    $0x10,%esp
  800172:	e9 8b 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800177:	83 ec 08             	sub    $0x8,%esp
  80017a:	ff 76 04             	pushl  0x4(%esi)
  80017d:	ff 36                	pushl  (%esi)
  80017f:	e8 07 11 00 00       	call   80128b <lwip_listen>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	83 c4 10             	add    $0x10,%esp
  800189:	eb 77                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80018b:	ff 76 08             	pushl  0x8(%esi)
  80018e:	ff 76 04             	pushl  0x4(%esi)
  800191:	56                   	push   %esi
  800192:	ff 36                	pushl  (%esi)
  800194:	e8 c8 13 00 00       	call   801561 <lwip_recv>
  800199:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  80019b:	83 c4 10             	add    $0x10,%esp
  80019e:	eb 62                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001a0:	ff 76 08             	pushl  0x8(%esi)
  8001a3:	ff 76 04             	pushl  0x4(%esi)
  8001a6:	8d 46 0c             	lea    0xc(%esi),%eax
  8001a9:	50                   	push   %eax
  8001aa:	ff 36                	pushl  (%esi)
  8001ac:	e8 1a 15 00 00       	call   8016cb <lwip_send>
  8001b1:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  8001b3:	83 c4 10             	add    $0x10,%esp
  8001b6:	eb 4a                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001b8:	83 ec 04             	sub    $0x4,%esp
  8001bb:	ff 76 08             	pushl  0x8(%esi)
  8001be:	ff 76 04             	pushl  0x4(%esi)
  8001c1:	ff 36                	pushl  (%esi)
  8001c3:	e8 96 15 00 00       	call   80175e <lwip_socket>
  8001c8:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  8001ca:	83 c4 10             	add    $0x10,%esp
  8001cd:	eb 33                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  8001cf:	83 ec 08             	sub    $0x8,%esp
  8001d2:	56                   	push   %esi
  8001d3:	68 00 b2 b3 00       	push   $0xb3b200
  8001d8:	e8 bb a7 00 00       	call   80a998 <jif_input>
		r = 0;
		break;
  8001dd:	83 c4 10             	add    $0x10,%esp
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
		break;
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
  8001e0:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  8001e5:	eb 3d                	jmp    800224 <serve_thread+0x160>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8001e7:	83 ec 04             	sub    $0x4,%esp
  8001ea:	56                   	push   %esi
  8001eb:	ff 73 04             	pushl  0x4(%ebx)
  8001ee:	68 a0 0c 81 00       	push   $0x810ca0
  8001f3:	e8 2b e3 00 00       	call   80e523 <cprintf>
		r = -E_INVAL;
		break;
  8001f8:	83 c4 10             	add    $0x10,%esp
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
		break;
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
  8001fb:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800200:	eb 22                	jmp    800224 <serve_thread+0x160>
	}

	if (r == -1) {
  800202:	83 ff ff             	cmp    $0xffffffff,%edi
  800205:	75 1d                	jne    800224 <serve_thread+0x160>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800207:	ff 33                	pushl  (%ebx)
  800209:	68 c0 0d 81 00       	push   $0x810dc0
  80020e:	6a 64                	push   $0x64
  800210:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800213:	56                   	push   %esi
  800214:	e8 3c e8 00 00       	call   80ea55 <snprintf>
		perror(buf);
  800219:	89 34 24             	mov    %esi,(%esp)
  80021c:	e8 64 a6 00 00       	call   80a885 <perror>
  800221:	83 c4 10             	add    $0x10,%esp
	}

	if (args->reqno != NSREQ_INPUT)
  800224:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800227:	74 10                	je     800239 <serve_thread+0x175>
		ipc_send(args->whom, r, 0, 0);
  800229:	6a 00                	push   $0x0
  80022b:	6a 00                	push   $0x0
  80022d:	57                   	push   %edi
  80022e:	ff 73 04             	pushl  0x4(%ebx)
  800231:	e8 68 f2 00 00       	call   80f49e <ipc_send>
  800236:	83 c4 10             	add    $0x10,%esp

	put_buffer(args->req);
  800239:	8b 53 08             	mov    0x8(%ebx),%edx
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  80023c:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800242:	c1 e8 0c             	shr    $0xc,%eax
  800245:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  80024c:	83 ec 08             	sub    $0x8,%esp
  80024f:	52                   	push   %edx
  800250:	6a 00                	push   $0x0
  800252:	e8 d9 ec 00 00       	call   80ef30 <sys_page_unmap>
	free(args);
  800257:	89 1c 24             	mov    %ebx,(%esp)
  80025a:	e8 67 ff 00 00       	call   8101c6 <free>
}
  80025f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800262:	5b                   	pop    %ebx
  800263:	5e                   	pop    %esi
  800264:	5f                   	pop    %edi
  800265:	5d                   	pop    %ebp
  800266:	c3                   	ret    

00800267 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800267:	55                   	push   %ebp
  800268:	89 e5                	mov    %esp,%ebp
  80026a:	56                   	push   %esi
  80026b:	53                   	push   %ebx
  80026c:	83 ec 10             	sub    $0x10,%esp
  80026f:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800272:	e8 4f a2 00 00       	call   80a4c6 <lwip_core_lock>

	uint32_t done = 0;
  800277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80027e:	83 ec 08             	sub    $0x8,%esp
  800281:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800284:	53                   	push   %ebx
  800285:	68 33 00 80 00       	push   $0x800033
  80028a:	e8 c8 21 00 00       	call   802457 <tcpip_init>
	lwip_core_unlock();
  80028f:	e8 37 a2 00 00       	call   80a4cb <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  800294:	83 c4 0c             	add    $0xc,%esp
  800297:	6a ff                	push   $0xffffffff
  800299:	6a 00                	push   $0x0
  80029b:	53                   	push   %ebx
  80029c:	e8 75 a4 00 00       	call   80a716 <thread_wait>
	lwip_core_lock();
  8002a1:	e8 20 a2 00 00       	call   80a4c6 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8002a6:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002af:	8b 45 10             	mov    0x10(%ebp),%eax
  8002b2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002b5:	83 c4 0c             	add    $0xc,%esp
  8002b8:	68 7d 65 80 00       	push   $0x80657d
  8002bd:	68 8c aa 80 00       	push   $0x80aa8c
  8002c2:	68 14 50 81 00       	push   $0x815014
  8002c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002ca:	50                   	push   %eax
  8002cb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002ce:	50                   	push   %eax
  8002cf:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002d2:	50                   	push   %eax
  8002d3:	68 00 b2 b3 00       	push   $0xb3b200
  8002d8:	e8 62 43 00 00       	call   80463f <netif_add>
  8002dd:	83 c4 20             	add    $0x20,%esp
  8002e0:	85 c0                	test   %eax,%eax
  8002e2:	75 14                	jne    8002f8 <serve_init+0x91>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  8002e4:	83 ec 04             	sub    $0x4,%esp
  8002e7:	68 c4 0c 81 00       	push   $0x810cc4
  8002ec:	6a 5c                	push   $0x5c
  8002ee:	68 b5 0d 81 00       	push   $0x810db5
  8002f3:	e8 52 e1 00 00       	call   80e44a <_panic>

	netif_set_default(nif);
  8002f8:	83 ec 0c             	sub    $0xc,%esp
  8002fb:	68 00 b2 b3 00       	push   $0xb3b200
  800300:	e8 f0 43 00 00       	call   8046f5 <netif_set_default>
	netif_set_up(nif);
  800305:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80030c:	e8 f1 43 00 00       	call   804702 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800311:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800318:	b9 cf 0d 81 00       	mov    $0x810dcf,%ecx
  80031d:	ba 4a 94 80 00       	mov    $0x80944a,%edx
  800322:	b8 34 50 81 00       	mov    $0x815034,%eax
  800327:	e8 21 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80032c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800333:	b9 d9 0d 81 00       	mov    $0x810dd9,%ecx
  800338:	ba fb 56 80 00       	mov    $0x8056fb,%edx
  80033d:	b8 28 50 81 00       	mov    $0x815028,%eax
  800342:	e8 06 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800347:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80034e:	b9 e5 0d 81 00       	mov    $0x810de5,%ecx
  800353:	ba f5 5c 80 00       	mov    $0x805cf5,%edx
  800358:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  80035d:	e8 eb fc ff ff       	call   80004d <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800362:	89 34 24             	mov    %esi,(%esp)
  800365:	e8 d8 72 00 00       	call   807642 <inet_ntoa>
  80036a:	50                   	push   %eax
  80036b:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  800372:	50                   	push   %eax
  800373:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  80037a:	50                   	push   %eax
  80037b:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  800382:	50                   	push   %eax
  800383:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  80038a:	50                   	push   %eax
  80038b:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  800392:	50                   	push   %eax
  800393:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  80039a:	50                   	push   %eax
  80039b:	68 e4 0c 81 00       	push   $0x810ce4
  8003a0:	e8 7e e1 00 00       	call   80e523 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8003a5:	83 c4 30             	add    $0x30,%esp
  8003a8:	e8 1e a1 00 00       	call   80a4cb <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8003ad:	83 ec 0c             	sub    $0xc,%esp
  8003b0:	68 f1 0d 81 00       	push   $0x810df1
  8003b5:	e8 69 e1 00 00       	call   80e523 <cprintf>
}
  8003ba:	83 c4 10             	add    $0x10,%esp
  8003bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c0:	5b                   	pop    %ebx
  8003c1:	5e                   	pop    %esi
  8003c2:	5d                   	pop    %ebp
  8003c3:	c3                   	ret    

008003c4 <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  8003c4:	55                   	push   %ebp
  8003c5:	89 e5                	mov    %esp,%ebp
  8003c7:	57                   	push   %edi
  8003c8:	56                   	push   %esi
  8003c9:	53                   	push   %ebx
  8003ca:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003cd:	8d 7d e0             	lea    -0x20(%ebp),%edi

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003d0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8003d5:	eb 08                	jmp    8003df <serve+0x1b>
			thread_yield();
  8003d7:	e8 b7 a2 00 00       	call   80a693 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003dc:	83 c3 01             	add    $0x1,%ebx
  8003df:	e8 3a a1 00 00       	call   80a51e <thread_wakeups_pending>
  8003e4:	85 c0                	test   %eax,%eax
  8003e6:	74 05                	je     8003ed <serve+0x29>
  8003e8:	83 fb 1f             	cmp    $0x1f,%ebx
  8003eb:	7e ea                	jle    8003d7 <serve+0x13>
			thread_yield();

		perm = 0;
  8003ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f4:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003f9:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800400:	74 0a                	je     80040c <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800402:	83 c0 01             	add    $0x1,%eax
  800405:	83 f8 14             	cmp    $0x14,%eax
  800408:	75 ef                	jne    8003f9 <serve+0x35>
  80040a:	eb 05                	jmp    800411 <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  80040c:	83 f8 14             	cmp    $0x14,%eax
  80040f:	75 14                	jne    800425 <serve+0x61>
		panic("NS: buffer overflow");
  800411:	83 ec 04             	sub    $0x4,%esp
  800414:	68 0a 0e 81 00       	push   $0x810e0a
  800419:	6a 3f                	push   $0x3f
  80041b:	68 b5 0d 81 00       	push   $0x810db5
  800420:	e8 25 e0 00 00       	call   80e44a <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  800425:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80042b:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042e:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800435:	83 ec 04             	sub    $0x4,%esp
  800438:	57                   	push   %edi
  800439:	53                   	push   %ebx
  80043a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043d:	50                   	push   %eax
  80043e:	e8 f2 ef 00 00       	call   80f435 <ipc_recv>
  800443:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800445:	83 c4 10             	add    $0x10,%esp
  800448:	83 f8 0c             	cmp    $0xc,%eax
  80044b:	75 5e                	jne    8004ab <serve+0xe7>
			process_timer(whom);
  80044d:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800450:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  800456:	74 13                	je     80046b <serve+0xa7>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800458:	83 ec 08             	sub    $0x8,%esp
  80045b:	56                   	push   %esi
  80045c:	68 20 0d 81 00       	push   $0x810d20
  800461:	e8 bd e0 00 00       	call   80e523 <cprintf>
  800466:	83 c4 10             	add    $0x10,%esp
  800469:	eb 2b                	jmp    800496 <serve+0xd2>
		return;
	}

	start = sys_time_msec();
  80046b:	e8 2c ec 00 00       	call   80f09c <sys_time_msec>
  800470:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800473:	e8 1b a2 00 00       	call   80a693 <thread_yield>
	now = sys_time_msec();
  800478:	e8 1f ec 00 00       	call   80f09c <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80047d:	6a 00                	push   $0x0
  80047f:	6a 00                	push   $0x0
  800481:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800484:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80048a:	29 c2                	sub    %eax,%edx
  80048c:	52                   	push   %edx
  80048d:	56                   	push   %esi
  80048e:	e8 0b f0 00 00       	call   80f49e <ipc_send>
  800493:	83 c4 10             	add    $0x10,%esp
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800496:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80049c:	c1 eb 0c             	shr    $0xc,%ebx
  80049f:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  8004a6:	e9 25 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  8004ab:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  8004af:	75 18                	jne    8004c9 <serve+0x105>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  8004b1:	83 ec 08             	sub    $0x8,%esp
  8004b4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8004b7:	68 5c 0d 81 00       	push   $0x810d5c
  8004bc:	e8 62 e0 00 00       	call   80e523 <cprintf>
			continue; // just leave it hanging...
  8004c1:	83 c4 10             	add    $0x10,%esp
  8004c4:	e9 07 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8004c9:	83 ec 0c             	sub    $0xc,%esp
  8004cc:	6a 0c                	push   $0xc
  8004ce:	e8 a1 fd 00 00       	call   810274 <malloc>
		if (!args)
  8004d3:	83 c4 10             	add    $0x10,%esp
  8004d6:	85 c0                	test   %eax,%eax
  8004d8:	75 17                	jne    8004f1 <serve+0x12d>
			panic("could not allocate thread args structure");
  8004da:	83 ec 04             	sub    $0x4,%esp
  8004dd:	68 8c 0d 81 00       	push   $0x810d8c
  8004e2:	68 27 01 00 00       	push   $0x127
  8004e7:	68 b5 0d 81 00       	push   $0x810db5
  8004ec:	e8 59 df 00 00       	call   80e44a <_panic>

		args->reqno = reqno;
  8004f1:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8004f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8004f6:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8004f9:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8004fc:	50                   	push   %eax
  8004fd:	68 c4 00 80 00       	push   $0x8000c4
  800502:	68 1e 0e 81 00       	push   $0x810e1e
  800507:	6a 00                	push   $0x0
  800509:	e8 5f a0 00 00       	call   80a56d <thread_create>
		thread_yield(); // let the thread created run
  80050e:	e8 80 a1 00 00       	call   80a693 <thread_yield>
  800513:	83 c4 10             	add    $0x10,%esp
  800516:	e9 b5 fe ff ff       	jmp    8003d0 <serve+0xc>

0080051b <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80051b:	55                   	push   %ebp
  80051c:	89 e5                	mov    %esp,%ebp
  80051e:	56                   	push   %esi
  80051f:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800520:	83 ec 0c             	sub    $0xc,%esp
  800523:	68 2b 0e 81 00       	push   $0x810e2b
  800528:	e8 c7 73 00 00       	call   8078f4 <inet_addr>
  80052d:	89 c6                	mov    %eax,%esi
  80052f:	c7 04 24 34 0e 81 00 	movl   $0x810e34,(%esp)
  800536:	e8 b9 73 00 00       	call   8078f4 <inet_addr>
  80053b:	89 c3                	mov    %eax,%ebx
  80053d:	c7 04 24 42 0e 81 00 	movl   $0x810e42,(%esp)
  800544:	e8 ab 73 00 00       	call   8078f4 <inet_addr>
  800549:	83 c4 0c             	add    $0xc,%esp
  80054c:	56                   	push   %esi
  80054d:	53                   	push   %ebx
  80054e:	50                   	push   %eax
  80054f:	e8 13 fd ff ff       	call   800267 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800554:	e8 6b fe ff ff       	call   8003c4 <serve>

00800559 <umain>:
}

void
umain(int argc, char **argv)
{
  800559:	55                   	push   %ebp
  80055a:	89 e5                	mov    %esp,%ebp
  80055c:	53                   	push   %ebx
  80055d:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800560:	e8 08 e9 00 00       	call   80ee6d <sys_getenvid>
  800565:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800567:	c7 05 e8 42 81 00 25 	movl   $0x813825,0x8142e8
  80056e:	38 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800571:	e8 e0 ec 00 00       	call   80f256 <fork>
  800576:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  80057b:	85 c0                	test   %eax,%eax
  80057d:	79 17                	jns    800596 <umain+0x3d>
		panic("error forking");
  80057f:	83 ec 04             	sub    $0x4,%esp
  800582:	68 4c 0e 81 00       	push   $0x810e4c
  800587:	68 44 01 00 00       	push   $0x144
  80058c:	68 b5 0d 81 00       	push   $0x810db5
  800591:	e8 b4 de 00 00       	call   80e44a <_panic>
	else if (timer_envid == 0) {
  800596:	85 c0                	test   %eax,%eax
  800598:	75 16                	jne    8005b0 <umain+0x57>
		timer(ns_envid, TIMER_INTERVAL);
  80059a:	83 ec 08             	sub    $0x8,%esp
  80059d:	68 fa 00 00 00       	push   $0xfa
  8005a2:	53                   	push   %ebx
  8005a3:	e8 96 00 00 00       	call   80063e <timer>
		return;
  8005a8:	83 c4 10             	add    $0x10,%esp
  8005ab:	e9 89 00 00 00       	jmp    800639 <umain+0xe0>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005b0:	e8 a1 ec 00 00       	call   80f256 <fork>
	if (input_envid < 0)
  8005b5:	85 c0                	test   %eax,%eax
  8005b7:	79 17                	jns    8005d0 <umain+0x77>
		panic("error forking");
  8005b9:	83 ec 04             	sub    $0x4,%esp
  8005bc:	68 4c 0e 81 00       	push   $0x810e4c
  8005c1:	68 4e 01 00 00       	push   $0x14e
  8005c6:	68 b5 0d 81 00       	push   $0x810db5
  8005cb:	e8 7a de 00 00       	call   80e44a <_panic>
	else if (input_envid == 0) {
  8005d0:	85 c0                	test   %eax,%eax
  8005d2:	75 0e                	jne    8005e2 <umain+0x89>
		input(ns_envid);
  8005d4:	83 ec 0c             	sub    $0xc,%esp
  8005d7:	53                   	push   %ebx
  8005d8:	e8 f4 00 00 00       	call   8006d1 <input>
		return;
  8005dd:	83 c4 10             	add    $0x10,%esp
  8005e0:	eb 57                	jmp    800639 <umain+0xe0>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005e2:	e8 6f ec 00 00       	call   80f256 <fork>
  8005e7:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005ec:	85 c0                	test   %eax,%eax
  8005ee:	79 17                	jns    800607 <umain+0xae>
		panic("error forking");
  8005f0:	83 ec 04             	sub    $0x4,%esp
  8005f3:	68 4c 0e 81 00       	push   $0x810e4c
  8005f8:	68 58 01 00 00       	push   $0x158
  8005fd:	68 b5 0d 81 00       	push   $0x810db5
  800602:	e8 43 de 00 00       	call   80e44a <_panic>
	else if (output_envid == 0) {
  800607:	85 c0                	test   %eax,%eax
  800609:	75 0e                	jne    800619 <umain+0xc0>
		output(ns_envid);
  80060b:	83 ec 0c             	sub    $0xc,%esp
  80060e:	53                   	push   %ebx
  80060f:	e8 65 01 00 00       	call   800779 <output>
		return;
  800614:	83 c4 10             	add    $0x10,%esp
  800617:	eb 20                	jmp    800639 <umain+0xe0>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800619:	e8 b2 9e 00 00       	call   80a4d0 <thread_init>
	thread_create(0, "main", tmain, 0);
  80061e:	6a 00                	push   $0x0
  800620:	68 1b 05 80 00       	push   $0x80051b
  800625:	68 5a 0e 81 00       	push   $0x810e5a
  80062a:	6a 00                	push   $0x0
  80062c:	e8 3c 9f 00 00       	call   80a56d <thread_create>
	thread_yield();
  800631:	e8 5d a0 00 00       	call   80a693 <thread_yield>
  800636:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800639:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80063c:	c9                   	leave  
  80063d:	c3                   	ret    

0080063e <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80063e:	55                   	push   %ebp
  80063f:	89 e5                	mov    %esp,%ebp
  800641:	57                   	push   %edi
  800642:	56                   	push   %esi
  800643:	53                   	push   %ebx
  800644:	83 ec 1c             	sub    $0x1c,%esp
  800647:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80064a:	e8 4d ea 00 00       	call   80f09c <sys_time_msec>
  80064f:	03 45 0c             	add    0xc(%ebp),%eax
  800652:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800654:	c7 05 e8 42 81 00 8c 	movl   $0x810e8c,0x8142e8
  80065b:	0e 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80065e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800661:	eb 05                	jmp    800668 <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800663:	e8 24 e8 00 00       	call   80ee8c <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800668:	e8 2f ea 00 00       	call   80f09c <sys_time_msec>
  80066d:	89 c2                	mov    %eax,%edx
  80066f:	85 c0                	test   %eax,%eax
  800671:	78 04                	js     800677 <timer+0x39>
  800673:	39 c3                	cmp    %eax,%ebx
  800675:	77 ec                	ja     800663 <timer+0x25>
			sys_yield();
		}
		if (r < 0)
  800677:	85 c0                	test   %eax,%eax
  800679:	79 12                	jns    80068d <timer+0x4f>
			panic("sys_time_msec: %e", r);
  80067b:	52                   	push   %edx
  80067c:	68 95 0e 81 00       	push   $0x810e95
  800681:	6a 0f                	push   $0xf
  800683:	68 a7 0e 81 00       	push   $0x810ea7
  800688:	e8 bd dd 00 00       	call   80e44a <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  80068d:	6a 00                	push   $0x0
  80068f:	6a 00                	push   $0x0
  800691:	6a 0c                	push   $0xc
  800693:	56                   	push   %esi
  800694:	e8 05 ee 00 00       	call   80f49e <ipc_send>
  800699:	83 c4 10             	add    $0x10,%esp

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069c:	83 ec 04             	sub    $0x4,%esp
  80069f:	6a 00                	push   $0x0
  8006a1:	6a 00                	push   $0x0
  8006a3:	57                   	push   %edi
  8006a4:	e8 8c ed 00 00       	call   80f435 <ipc_recv>
  8006a9:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006ae:	83 c4 10             	add    $0x10,%esp
  8006b1:	39 f0                	cmp    %esi,%eax
  8006b3:	74 13                	je     8006c8 <timer+0x8a>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006b5:	83 ec 08             	sub    $0x8,%esp
  8006b8:	50                   	push   %eax
  8006b9:	68 b4 0e 81 00       	push   $0x810eb4
  8006be:	e8 60 de 00 00       	call   80e523 <cprintf>
				continue;
  8006c3:	83 c4 10             	add    $0x10,%esp
  8006c6:	eb d4                	jmp    80069c <timer+0x5e>
			}

			stop = sys_time_msec() + to;
  8006c8:	e8 cf e9 00 00       	call   80f09c <sys_time_msec>
  8006cd:	01 c3                	add    %eax,%ebx
  8006cf:	eb 97                	jmp    800668 <timer+0x2a>

008006d1 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  8006d1:	55                   	push   %ebp
  8006d2:	89 e5                	mov    %esp,%ebp
  8006d4:	57                   	push   %edi
  8006d5:	56                   	push   %esi
  8006d6:	53                   	push   %ebx
  8006d7:	83 ec 48             	sub    $0x48,%esp
	binaryname = "ns_input";
  8006da:	c7 05 e8 42 81 00 ef 	movl   $0x810eef,0x8142e8
  8006e1:	0e 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
	cprintf("NS INPUT ENV is on!\n");
  8006e4:	68 f8 0e 81 00       	push   $0x810ef8
  8006e9:	e8 35 de 00 00       	call   80e523 <cprintf>
  8006ee:	83 c4 10             	add    $0x10,%esp

	// Allocate some pages to receive page
	char *bufs[10];
	char *va = (char *) 0x0ffff000;
	int i;
	for (i = 0; i < 10; i++) {
  8006f1:	bb 00 00 00 00       	mov    $0x0,%ebx
  8006f6:	8d b3 ff ff 00 00    	lea    0xffff(%ebx),%esi
  8006fc:	c1 e6 0c             	shl    $0xc,%esi
		sys_page_alloc(0, va, PTE_P | PTE_U | PTE_W);
  8006ff:	83 ec 04             	sub    $0x4,%esp
  800702:	6a 07                	push   $0x7
  800704:	56                   	push   %esi
  800705:	6a 00                	push   $0x0
  800707:	e8 9f e7 00 00       	call   80eeab <sys_page_alloc>
		bufs[i] = va;
  80070c:	89 74 9d c0          	mov    %esi,-0x40(%ebp,%ebx,4)

	// Allocate some pages to receive page
	char *bufs[10];
	char *va = (char *) 0x0ffff000;
	int i;
	for (i = 0; i < 10; i++) {
  800710:	83 c3 01             	add    $0x1,%ebx
  800713:	83 c4 10             	add    $0x10,%esp
  800716:	83 fb 0a             	cmp    $0xa,%ebx
  800719:	75 db                	jne    8006f6 <input+0x25>
  80071b:	bb 00 00 00 00       	mov    $0x0,%ebx
	while(1) {
		// Build request
		union Nsipc *nsipc = (union Nsipc *) bufs[current_buffer];
		char *packet_buf = (nsipc->pkt).jp_data;
		size_t size = -1; // Could pass the jp_len instead
		sys_receive_packet(packet_buf, &size);
  800720:	8d 7d bc             	lea    -0x44(%ebp),%edi
	// Infinity loop trying to receive packets and, if received, send it
	// to the network server
	int current_buffer = 0;
	while(1) {
		// Build request
		union Nsipc *nsipc = (union Nsipc *) bufs[current_buffer];
  800723:	8b 74 9d c0          	mov    -0x40(%ebp,%ebx,4),%esi
		char *packet_buf = (nsipc->pkt).jp_data;
		size_t size = -1; // Could pass the jp_len instead
  800727:	c7 45 bc ff ff ff ff 	movl   $0xffffffff,-0x44(%ebp)
		sys_receive_packet(packet_buf, &size);
  80072e:	83 ec 08             	sub    $0x8,%esp
  800731:	57                   	push   %edi
	// to the network server
	int current_buffer = 0;
	while(1) {
		// Build request
		union Nsipc *nsipc = (union Nsipc *) bufs[current_buffer];
		char *packet_buf = (nsipc->pkt).jp_data;
  800732:	8d 46 04             	lea    0x4(%esi),%eax
		size_t size = -1; // Could pass the jp_len instead
		sys_receive_packet(packet_buf, &size);
  800735:	50                   	push   %eax
  800736:	e8 c2 e9 00 00       	call   80f0fd <sys_receive_packet>

		// If it receives a packet, the size won't be -1 anymore
		if (size != -1) {
  80073b:	8b 45 bc             	mov    -0x44(%ebp),%eax
  80073e:	83 c4 10             	add    $0x10,%esp
  800741:	83 f8 ff             	cmp    $0xffffffff,%eax
  800744:	74 dd                	je     800723 <input+0x52>
			

			// Store the correct size
			(nsipc->pkt).jp_len = size;
  800746:	89 06                	mov    %eax,(%esi)

			// Request is built, now send it
			ipc_send(nsenv, NSREQ_INPUT, nsipc, PTE_P|PTE_W|PTE_U);
  800748:	6a 07                	push   $0x7
  80074a:	56                   	push   %esi
  80074b:	6a 0a                	push   $0xa
  80074d:	68 01 10 00 00       	push   $0x1001
  800752:	e8 47 ed 00 00       	call   80f49e <ipc_send>

			// Let the current buffer rest for a while. Go to next.
			current_buffer = (current_buffer + 1)%10;
  800757:	8d 4b 01             	lea    0x1(%ebx),%ecx
  80075a:	b8 67 66 66 66       	mov    $0x66666667,%eax
  80075f:	f7 e9                	imul   %ecx
  800761:	c1 fa 02             	sar    $0x2,%edx
  800764:	89 c8                	mov    %ecx,%eax
  800766:	c1 f8 1f             	sar    $0x1f,%eax
  800769:	29 c2                	sub    %eax,%edx
  80076b:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80076e:	01 c0                	add    %eax,%eax
  800770:	29 c1                	sub    %eax,%ecx
  800772:	89 cb                	mov    %ecx,%ebx
  800774:	83 c4 10             	add    $0x10,%esp
		}
	}
  800777:	eb aa                	jmp    800723 <input+0x52>

00800779 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800779:	55                   	push   %ebp
  80077a:	89 e5                	mov    %esp,%ebp
  80077c:	56                   	push   %esi
  80077d:	53                   	push   %ebx
  80077e:	83 ec 1c             	sub    $0x1c,%esp
	binaryname = "ns_output";
  800781:	c7 05 e8 42 81 00 0d 	movl   $0x810f0d,0x8142e8
  800788:	0f 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
	cprintf("NS OUTPUT ENV is on!\n");
  80078b:	68 17 0f 81 00       	push   $0x810f17
  800790:	e8 8e dd 00 00       	call   80e523 <cprintf>
  800795:	83 c4 10             	add    $0x10,%esp
	
	union Nsipc *nsipc = (union Nsipc *)0x0ffff000;
	envid_t whom; 	int perm;     
	// Endless loop s
	while (1) {
		uint32_t req = ipc_recv(&whom, nsipc, &perm);
  800798:	8d 75 f0             	lea    -0x10(%ebp),%esi
  80079b:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80079e:	83 ec 04             	sub    $0x4,%esp
  8007a1:	56                   	push   %esi
  8007a2:	68 00 f0 ff 0f       	push   $0xffff000
  8007a7:	53                   	push   %ebx
  8007a8:	e8 88 ec 00 00       	call   80f435 <ipc_recv>

		// Check if the request is of the expected type
		if (req == NSREQ_OUTPUT) {
  8007ad:	83 c4 10             	add    $0x10,%esp
  8007b0:	83 f8 0b             	cmp    $0xb,%eax
  8007b3:	75 2c                	jne    8007e1 <output+0x68>
			char *buf = (nsipc->pkt).jp_data;

			
			// Transmit the packet
			int r;
			if ((r = sys_transmit_packet(buf, size)) < 0)
  8007b5:	83 ec 08             	sub    $0x8,%esp
  8007b8:	ff 35 00 f0 ff 0f    	pushl  0xffff000
  8007be:	68 04 f0 ff 0f       	push   $0xffff004
  8007c3:	e8 f3 e8 00 00       	call   80f0bb <sys_transmit_packet>
  8007c8:	83 c4 10             	add    $0x10,%esp
  8007cb:	85 c0                	test   %eax,%eax
  8007cd:	79 cf                	jns    80079e <output+0x25>
				panic("sys_transmit_packet: %e", r);
  8007cf:	50                   	push   %eax
  8007d0:	68 2d 0f 81 00       	push   $0x810f2d
  8007d5:	6a 21                	push   $0x21
  8007d7:	68 45 0f 81 00       	push   $0x810f45
  8007dc:	e8 69 dc 00 00       	call   80e44a <_panic>
		} else {
			panic("NS OUTPUT ENV: Invalid request received!");
  8007e1:	83 ec 04             	sub    $0x4,%esp
  8007e4:	68 54 0f 81 00       	push   $0x810f54
  8007e9:	6a 23                	push   $0x23
  8007eb:	68 45 0f 81 00       	push   $0x810f45
  8007f0:	e8 55 dc 00 00       	call   80e44a <_panic>

008007f5 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8007f5:	55                   	push   %ebp
  8007f6:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8007f8:	83 f8 1f             	cmp    $0x1f,%eax
  8007fb:	76 11                	jbe    80080e <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  8007fd:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800804:	00 00 00 
    return NULL;
  800807:	b8 00 00 00 00       	mov    $0x0,%eax
  80080c:	eb 30                	jmp    80083e <get_socket+0x49>
  }

  sock = &sockets[s];
  80080e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  800815:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  800818:	8d 0c 8d 60 50 81 00 	lea    0x815060(,%ecx,4),%ecx

  if (!sock->conn) {
  80081f:	01 c2                	add    %eax,%edx
  800821:	83 3c 95 60 50 81 00 	cmpl   $0x0,0x815060(,%edx,4)
  800828:	00 
  800829:	75 11                	jne    80083c <get_socket+0x47>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80082b:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800832:	00 00 00 
    return NULL;
  800835:	b8 00 00 00 00       	mov    $0x0,%eax
  80083a:	eb 02                	jmp    80083e <get_socket+0x49>
  }

  return sock;
  80083c:	89 c8                	mov    %ecx,%eax
}
  80083e:	5d                   	pop    %ebp
  80083f:	c3                   	ret    

00800840 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800840:	55                   	push   %ebp
  800841:	89 e5                	mov    %esp,%ebp
  800843:	57                   	push   %edi
  800844:	56                   	push   %esi
  800845:	53                   	push   %ebx
  800846:	83 ec 40             	sub    $0x40,%esp
  800849:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80084c:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80084f:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800852:	6a 04                	push   $0x4
  800854:	6a 00                	push   $0x0
  800856:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800859:	50                   	push   %eax
  80085a:	e8 8e e3 00 00       	call   80ebed <memset>
  FD_ZERO(&lwriteset);
  80085f:	83 c4 0c             	add    $0xc,%esp
  800862:	6a 04                	push   $0x4
  800864:	6a 00                	push   $0x0
  800866:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800869:	50                   	push   %eax
  80086a:	e8 7e e3 00 00       	call   80ebed <memset>
  FD_ZERO(&lexceptset);
  80086f:	83 c4 0c             	add    $0xc,%esp
  800872:	6a 04                	push   $0x4
  800874:	6a 00                	push   $0x0
  800876:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800879:	50                   	push   %eax
  80087a:	e8 6e e3 00 00       	call   80ebed <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80087f:	83 c4 10             	add    $0x10,%esp
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  800882:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800889:	bf 00 00 00 00       	mov    $0x0,%edi
  80088e:	e9 80 00 00 00       	jmp    800913 <lwip_selscan+0xd3>
    if (FD_ISSET(i, readset)) {
  800893:	8d 5f 07             	lea    0x7(%edi),%ebx
  800896:	85 ff                	test   %edi,%edi
  800898:	0f 49 df             	cmovns %edi,%ebx
  80089b:	c1 fb 03             	sar    $0x3,%ebx
  80089e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8008a1:	89 fe                	mov    %edi,%esi
  8008a3:	83 e6 07             	and    $0x7,%esi
  8008a6:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8008a9:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8008ad:	0f a3 f0             	bt     %esi,%eax
  8008b0:	73 2c                	jae    8008de <lwip_selscan+0x9e>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8008b2:	89 f8                	mov    %edi,%eax
  8008b4:	e8 3c ff ff ff       	call   8007f5 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008b9:	85 c0                	test   %eax,%eax
  8008bb:	74 21                	je     8008de <lwip_selscan+0x9e>
  8008bd:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8008c1:	75 07                	jne    8008ca <lwip_selscan+0x8a>
  8008c3:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8008c8:	74 14                	je     8008de <lwip_selscan+0x9e>
        FD_SET(i, &lreadset);
  8008ca:	b8 01 00 00 00       	mov    $0x1,%eax
  8008cf:	89 f1                	mov    %esi,%ecx
  8008d1:	d3 e0                	shl    %cl,%eax
  8008d3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008d6:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8008da:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  8008de:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8008e1:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8008e5:	0f a3 f0             	bt     %esi,%eax
  8008e8:	73 26                	jae    800910 <lwip_selscan+0xd0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8008ea:	89 f8                	mov    %edi,%eax
  8008ec:	e8 04 ff ff ff       	call   8007f5 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8008f1:	85 c0                	test   %eax,%eax
  8008f3:	74 1b                	je     800910 <lwip_selscan+0xd0>
  8008f5:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8008fa:	74 14                	je     800910 <lwip_selscan+0xd0>
        FD_SET(i, &lwriteset);
  8008fc:	b8 01 00 00 00       	mov    $0x1,%eax
  800901:	89 f1                	mov    %esi,%ecx
  800903:	d3 e0                	shl    %cl,%eax
  800905:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800908:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  80090c:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800910:	83 c7 01             	add    $0x1,%edi
  800913:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800916:	0f 8c 77 ff ff ff    	jl     800893 <lwip_selscan+0x53>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  80091c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80091f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800922:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800924:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800927:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80092a:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  80092c:	83 ec 04             	sub    $0x4,%esp
  80092f:	6a 04                	push   $0x4
  800931:	6a 00                	push   $0x0
  800933:	ff 75 08             	pushl  0x8(%ebp)
  800936:	e8 b2 e2 00 00       	call   80ebed <memset>
  
  return nready;
}
  80093b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80093e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800941:	5b                   	pop    %ebx
  800942:	5e                   	pop    %esi
  800943:	5f                   	pop    %edi
  800944:	5d                   	pop    %ebp
  800945:	c3                   	ret    

00800946 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800946:	55                   	push   %ebp
  800947:	89 e5                	mov    %esp,%ebp
  800949:	57                   	push   %edi
  80094a:	56                   	push   %esi
  80094b:	53                   	push   %ebx
  80094c:	83 ec 3c             	sub    $0x3c,%esp
  80094f:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800952:	89 cf                	mov    %ecx,%edi
  800954:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800957:	e8 99 fe ff ff       	call   8007f5 <get_socket>
  if (!sock)
  80095c:	85 c0                	test   %eax,%eax
  80095e:	0f 84 80 00 00 00    	je     8009e4 <lwip_getaddrname+0x9e>
  800964:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800966:	83 ec 04             	sub    $0x4,%esp
  800969:	6a 10                	push   $0x10
  80096b:	6a 00                	push   $0x0
  80096d:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800970:	50                   	push   %eax
  800971:	e8 77 e2 00 00       	call   80ebed <memset>
  sin.sin_len = sizeof(sin);
  800976:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  80097a:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80097e:	89 f0                	mov    %esi,%eax
  800980:	0f b6 f0             	movzbl %al,%esi
  800983:	56                   	push   %esi
  800984:	8d 45 da             	lea    -0x26(%ebp),%eax
  800987:	50                   	push   %eax
  800988:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80098b:	50                   	push   %eax
  80098c:	ff 33                	pushl  (%ebx)
  80098e:	e8 e7 a2 00 00       	call   80ac7a <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800993:	83 c4 14             	add    $0x14,%esp
  800996:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80099a:	50                   	push   %eax
  80099b:	e8 3b 6d 00 00       	call   8076db <htons>
  8009a0:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8009a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8009a7:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8009aa:	83 c4 10             	add    $0x10,%esp
  8009ad:	83 3f 10             	cmpl   $0x10,(%edi)
  8009b0:	76 06                	jbe    8009b8 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8009b2:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8009b8:	83 ec 04             	sub    $0x4,%esp
  8009bb:	ff 37                	pushl  (%edi)
  8009bd:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8009c0:	50                   	push   %eax
  8009c1:	ff 75 c4             	pushl  -0x3c(%ebp)
  8009c4:	e8 d9 e2 00 00       	call   80eca2 <memcpy>
  sock_set_errno(sock, 0);
  8009c9:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8009d0:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8009d7:	00 00 00 
  return 0;
  8009da:	83 c4 10             	add    $0x10,%esp
  8009dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8009e2:	eb 05                	jmp    8009e9 <lwip_getaddrname+0xa3>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8009e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  8009e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8009ec:	5b                   	pop    %ebx
  8009ed:	5e                   	pop    %esi
  8009ee:	5f                   	pop    %edi
  8009ef:	5d                   	pop    %ebp
  8009f0:	c3                   	ret    

008009f1 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8009f1:	55                   	push   %ebp
  8009f2:	89 e5                	mov    %esp,%ebp
  8009f4:	57                   	push   %edi
  8009f5:	56                   	push   %esi
  8009f6:	53                   	push   %ebx
  8009f7:	83 ec 1c             	sub    $0x1c,%esp
  8009fa:	8b 7d 08             	mov    0x8(%ebp),%edi
  8009fd:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  800a00:	85 ff                	test   %edi,%edi
  800a02:	0f 84 81 01 00 00    	je     800b89 <event_callback+0x198>
    s = conn->socket;
  800a08:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800a0b:	85 db                	test   %ebx,%ebx
  800a0d:	79 49                	jns    800a58 <event_callback+0x67>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800a0f:	83 ec 0c             	sub    $0xc,%esp
  800a12:	ff 35 44 50 81 00    	pushl  0x815044
  800a18:	e8 ca 46 00 00       	call   8050e7 <sys_sem_wait>
      if (conn->socket < 0) {
  800a1d:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a20:	83 c4 10             	add    $0x10,%esp
  800a23:	85 c0                	test   %eax,%eax
  800a25:	79 20                	jns    800a47 <event_callback+0x56>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800a27:	85 f6                	test   %esi,%esi
  800a29:	75 06                	jne    800a31 <event_callback+0x40>
          conn->socket--;
  800a2b:	83 e8 01             	sub    $0x1,%eax
  800a2e:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  800a31:	83 ec 0c             	sub    $0xc,%esp
  800a34:	ff 35 44 50 81 00    	pushl  0x815044
  800a3a:	e8 9e 95 00 00       	call   809fdd <sys_sem_signal>
        return;
  800a3f:	83 c4 10             	add    $0x10,%esp
  800a42:	e9 42 01 00 00       	jmp    800b89 <event_callback+0x198>
      }
      sys_sem_signal(socksem);
  800a47:	83 ec 0c             	sub    $0xc,%esp
  800a4a:	ff 35 44 50 81 00    	pushl  0x815044
  800a50:	e8 88 95 00 00       	call   809fdd <sys_sem_signal>
  800a55:	83 c4 10             	add    $0x10,%esp
    }

    sock = get_socket(s);
  800a58:	89 d8                	mov    %ebx,%eax
  800a5a:	e8 96 fd ff ff       	call   8007f5 <get_socket>
  800a5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800a62:	85 c0                	test   %eax,%eax
  800a64:	0f 84 1f 01 00 00    	je     800b89 <event_callback+0x198>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800a6a:	83 ec 0c             	sub    $0xc,%esp
  800a6d:	ff 35 40 50 81 00    	pushl  0x815040
  800a73:	e8 6f 46 00 00       	call   8050e7 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800a78:	83 c4 10             	add    $0x10,%esp
  800a7b:	83 fe 01             	cmp    $0x1,%esi
  800a7e:	74 1b                	je     800a9b <event_callback+0xaa>
  800a80:	83 fe 01             	cmp    $0x1,%esi
  800a83:	72 0c                	jb     800a91 <event_callback+0xa0>
  800a85:	83 fe 02             	cmp    $0x2,%esi
  800a88:	74 1b                	je     800aa5 <event_callback+0xb4>
  800a8a:	83 fe 03             	cmp    $0x3,%esi
  800a8d:	74 21                	je     800ab0 <event_callback+0xbf>
  800a8f:	eb 2a                	jmp    800abb <event_callback+0xca>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800a91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a94:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800a99:	eb 37                	jmp    800ad2 <event_callback+0xe1>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800a9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a9e:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800aa3:	eb 2d                	jmp    800ad2 <event_callback+0xe1>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800aa5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800aa8:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800aae:	eb 22                	jmp    800ad2 <event_callback+0xe1>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800ab0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ab3:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800ab9:	eb 17                	jmp    800ad2 <event_callback+0xe1>
    default:
      LWIP_ASSERT("unknown event", 0);
  800abb:	83 ec 04             	sub    $0x4,%esp
  800abe:	68 7d 0f 81 00       	push   $0x810f7d
  800ac3:	68 17 04 00 00       	push   $0x417
  800ac8:	68 8b 0f 81 00       	push   $0x810f8b
  800acd:	e8 78 d9 00 00       	call   80e44a <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800ad2:	83 ec 0c             	sub    $0xc,%esp
  800ad5:	ff 35 40 50 81 00    	pushl  0x815040
  800adb:	e8 fd 94 00 00       	call   809fdd <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800ae0:	8d 73 07             	lea    0x7(%ebx),%esi
  800ae3:	83 c4 10             	add    $0x10,%esp
  800ae6:	85 db                	test   %ebx,%ebx
  800ae8:	0f 49 f3             	cmovns %ebx,%esi
  800aeb:	c1 fe 03             	sar    $0x3,%esi
  800aee:	89 d9                	mov    %ebx,%ecx
  800af0:	83 e1 07             	and    $0x7,%ecx
  800af3:	bf 01 00 00 00       	mov    $0x1,%edi
  800af8:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800afa:	83 ec 0c             	sub    $0xc,%esp
  800afd:	ff 35 40 50 81 00    	pushl  0x815040
  800b03:	e8 df 45 00 00       	call   8050e7 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b08:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800b0e:	83 c4 10             	add    $0x10,%esp
  800b11:	eb 3a                	jmp    800b4d <event_callback+0x15c>
      if (scb->sem_signalled == 0) {
  800b13:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800b17:	75 32                	jne    800b4b <event_callback+0x15a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800b19:	8b 43 04             	mov    0x4(%ebx),%eax
  800b1c:	85 c0                	test   %eax,%eax
  800b1e:	74 12                	je     800b32 <event_callback+0x141>
  800b20:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b24:	85 f8                	test   %edi,%eax
  800b26:	74 0a                	je     800b32 <event_callback+0x141>
          if (sock->rcvevent)
  800b28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b2b:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800b30:	75 21                	jne    800b53 <event_callback+0x162>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800b32:	8b 43 08             	mov    0x8(%ebx),%eax
  800b35:	85 c0                	test   %eax,%eax
  800b37:	74 12                	je     800b4b <event_callback+0x15a>
  800b39:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b3d:	85 f8                	test   %edi,%eax
  800b3f:	74 0a                	je     800b4b <event_callback+0x15a>
          if (sock->sendevent)
  800b41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b44:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b49:	75 08                	jne    800b53 <event_callback+0x162>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b4b:	8b 1b                	mov    (%ebx),%ebx
  800b4d:	85 db                	test   %ebx,%ebx
  800b4f:	75 c2                	jne    800b13 <event_callback+0x122>
  800b51:	eb 25                	jmp    800b78 <event_callback+0x187>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800b53:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b5a:	83 ec 0c             	sub    $0xc,%esp
  800b5d:	ff 35 40 50 81 00    	pushl  0x815040
  800b63:	e8 75 94 00 00       	call   809fdd <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b68:	83 c4 04             	add    $0x4,%esp
  800b6b:	ff 73 14             	pushl  0x14(%ebx)
  800b6e:	e8 6a 94 00 00       	call   809fdd <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800b73:	83 c4 10             	add    $0x10,%esp
  800b76:	eb 82                	jmp    800afa <event_callback+0x109>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800b78:	83 ec 0c             	sub    $0xc,%esp
  800b7b:	ff 35 40 50 81 00    	pushl  0x815040
  800b81:	e8 57 94 00 00       	call   809fdd <sys_sem_signal>
      break;
  800b86:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  800b89:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800b8c:	5b                   	pop    %ebx
  800b8d:	5e                   	pop    %esi
  800b8e:	5f                   	pop    %edi
  800b8f:	5d                   	pop    %ebp
  800b90:	c3                   	ret    

00800b91 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800b91:	55                   	push   %ebp
  800b92:	89 e5                	mov    %esp,%ebp
  800b94:	56                   	push   %esi
  800b95:	53                   	push   %ebx
  800b96:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800b98:	83 ec 0c             	sub    $0xc,%esp
  800b9b:	ff 35 44 50 81 00    	pushl  0x815044
  800ba1:	e8 41 45 00 00       	call   8050e7 <sys_sem_wait>
  800ba6:	b8 60 50 81 00       	mov    $0x815060,%eax
  800bab:	83 c4 10             	add    $0x10,%esp

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800bae:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800bb3:	83 38 00             	cmpl   $0x0,(%eax)
  800bb6:	75 59                	jne    800c11 <alloc_socket+0x80>
      sockets[i].conn       = newconn;
  800bb8:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800bbb:	c1 e2 02             	shl    $0x2,%edx
  800bbe:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800bc4:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800bcb:	00 00 00 
      sockets[i].lastoffset = 0;
  800bce:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800bd5:	00 00 
      sockets[i].rcvevent   = 0;
  800bd7:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800bde:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800be0:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800be7:	01 00 
      sockets[i].flags      = 0;
  800be9:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800bf0:	00 00 
      sockets[i].err        = 0;
  800bf2:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800bf9:	00 00 00 
      sys_sem_signal(socksem);
  800bfc:	83 ec 0c             	sub    $0xc,%esp
  800bff:	ff 35 44 50 81 00    	pushl  0x815044
  800c05:	e8 d3 93 00 00       	call   809fdd <sys_sem_signal>
      return i;
  800c0a:	83 c4 10             	add    $0x10,%esp
  800c0d:	89 d8                	mov    %ebx,%eax
  800c0f:	eb 21                	jmp    800c32 <alloc_socket+0xa1>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800c11:	83 c3 01             	add    $0x1,%ebx
  800c14:	83 c0 14             	add    $0x14,%eax
  800c17:	83 fb 20             	cmp    $0x20,%ebx
  800c1a:	75 97                	jne    800bb3 <alloc_socket+0x22>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800c1c:	83 ec 0c             	sub    $0xc,%esp
  800c1f:	ff 35 44 50 81 00    	pushl  0x815044
  800c25:	e8 b3 93 00 00       	call   809fdd <sys_sem_signal>
  return -1;
  800c2a:	83 c4 10             	add    $0x10,%esp
  800c2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800c32:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800c35:	5b                   	pop    %ebx
  800c36:	5e                   	pop    %esi
  800c37:	5d                   	pop    %ebp
  800c38:	c3                   	ret    

00800c39 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800c39:	55                   	push   %ebp
  800c3a:	89 e5                	mov    %esp,%ebp
  800c3c:	53                   	push   %ebx
  800c3d:	83 ec 04             	sub    $0x4,%esp
  800c40:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c43:	85 c0                	test   %eax,%eax
  800c45:	75 17                	jne    800c5e <lwip_getsockopt_internal+0x25>
  800c47:	83 ec 04             	sub    $0x4,%esp
  800c4a:	68 a2 0f 81 00       	push   $0x810fa2
  800c4f:	68 38 05 00 00       	push   $0x538
  800c54:	68 8b 0f 81 00       	push   $0x810f8b
  800c59:	e8 ec d7 00 00       	call   80e44a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c5e:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800c60:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800c63:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800c66:	8b 40 08             	mov    0x8(%eax),%eax
  800c69:	83 f8 06             	cmp    $0x6,%eax
  800c6c:	0f 84 09 01 00 00    	je     800d7b <lwip_getsockopt_internal+0x142>
  800c72:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800c77:	74 0d                	je     800c86 <lwip_getsockopt_internal+0x4d>
  800c79:	85 c0                	test   %eax,%eax
  800c7b:	0f 85 26 01 00 00    	jne    800da7 <lwip_getsockopt_internal+0x16e>
  800c81:	e9 d1 00 00 00       	jmp    800d57 <lwip_getsockopt_internal+0x11e>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800c86:	83 fa 20             	cmp    $0x20,%edx
  800c89:	74 37                	je     800cc2 <lwip_getsockopt_internal+0x89>
  800c8b:	83 fa 20             	cmp    $0x20,%edx
  800c8e:	7f 10                	jg     800ca0 <lwip_getsockopt_internal+0x67>
  800c90:	83 fa 02             	cmp    $0x2,%edx
  800c93:	74 2d                	je     800cc2 <lwip_getsockopt_internal+0x89>
  800c95:	83 fa 08             	cmp    $0x8,%edx
  800c98:	0f 85 09 01 00 00    	jne    800da7 <lwip_getsockopt_internal+0x16e>
  800c9e:	eb 22                	jmp    800cc2 <lwip_getsockopt_internal+0x89>
  800ca0:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800ca6:	74 2c                	je     800cd4 <lwip_getsockopt_internal+0x9b>
  800ca8:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800cae:	0f 84 93 00 00 00    	je     800d47 <lwip_getsockopt_internal+0x10e>
  800cb4:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800cba:	0f 85 e7 00 00 00    	jne    800da7 <lwip_getsockopt_internal+0x16e>
  800cc0:	eb 4f                	jmp    800d11 <lwip_getsockopt_internal+0xd8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800cc2:	8b 01                	mov    (%ecx),%eax
  800cc4:	8b 40 08             	mov    0x8(%eax),%eax
  800cc7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800ccb:	21 c2                	and    %eax,%edx
  800ccd:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800ccf:	e9 d3 00 00 00       	jmp    800da7 <lwip_getsockopt_internal+0x16e>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800cd4:	8b 01                	mov    (%ecx),%eax
  800cd6:	8b 10                	mov    (%eax),%edx
  800cd8:	89 d0                	mov    %edx,%eax
  800cda:	25 f0 00 00 00       	and    $0xf0,%eax
  800cdf:	83 f8 20             	cmp    $0x20,%eax
  800ce2:	74 22                	je     800d06 <lwip_getsockopt_internal+0xcd>
  800ce4:	83 f8 40             	cmp    $0x40,%eax
  800ce7:	74 12                	je     800cfb <lwip_getsockopt_internal+0xc2>
  800ce9:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800cec:	b8 01 00 00 00       	mov    $0x1,%eax
  800cf1:	0f 44 d0             	cmove  %eax,%edx
  800cf4:	89 13                	mov    %edx,(%ebx)
  800cf6:	e9 ac 00 00 00       	jmp    800da7 <lwip_getsockopt_internal+0x16e>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800cfb:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800d01:	e9 a1 00 00 00       	jmp    800da7 <lwip_getsockopt_internal+0x16e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800d06:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800d0c:	e9 96 00 00 00       	jmp    800da7 <lwip_getsockopt_internal+0x16e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800d11:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800d15:	75 22                	jne    800d39 <lwip_getsockopt_internal+0x100>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800d17:	8b 01                	mov    (%ecx),%eax
  800d19:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800d1d:	f7 d8                	neg    %eax
  800d1f:	ba 05 00 00 00       	mov    $0x5,%edx
  800d24:	83 f8 0e             	cmp    $0xe,%eax
  800d27:	77 07                	ja     800d30 <lwip_getsockopt_internal+0xf7>
  800d29:	8b 14 85 40 10 81 00 	mov    0x811040(,%eax,4),%edx
  800d30:	89 51 10             	mov    %edx,0x10(%ecx)
  800d33:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      } 
      *(int *)optval = sock->err;
  800d39:	8b 41 10             	mov    0x10(%ecx),%eax
  800d3c:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800d3e:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800d45:	eb 60                	jmp    800da7 <lwip_getsockopt_internal+0x16e>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800d47:	8b 01                	mov    (%ecx),%eax
  800d49:	8b 40 08             	mov    0x8(%eax),%eax
  800d4c:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800d50:	83 e0 01             	and    $0x1,%eax
  800d53:	89 03                	mov    %eax,(%ebx)
      break;
  800d55:	eb 50                	jmp    800da7 <lwip_getsockopt_internal+0x16e>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800d57:	83 fa 01             	cmp    $0x1,%edx
  800d5a:	74 12                	je     800d6e <lwip_getsockopt_internal+0x135>
  800d5c:	83 fa 02             	cmp    $0x2,%edx
  800d5f:	75 46                	jne    800da7 <lwip_getsockopt_internal+0x16e>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d61:	8b 01                	mov    (%ecx),%eax
  800d63:	8b 40 08             	mov    0x8(%eax),%eax
  800d66:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800d6a:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800d6c:	eb 39                	jmp    800da7 <lwip_getsockopt_internal+0x16e>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800d6e:	8b 01                	mov    (%ecx),%eax
  800d70:	8b 40 08             	mov    0x8(%eax),%eax
  800d73:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800d77:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800d79:	eb 2c                	jmp    800da7 <lwip_getsockopt_internal+0x16e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800d7b:	83 fa 01             	cmp    $0x1,%edx
  800d7e:	74 07                	je     800d87 <lwip_getsockopt_internal+0x14e>
  800d80:	83 fa 02             	cmp    $0x2,%edx
  800d83:	74 15                	je     800d9a <lwip_getsockopt_internal+0x161>
  800d85:	eb 20                	jmp    800da7 <lwip_getsockopt_internal+0x16e>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800d87:	8b 01                	mov    (%ecx),%eax
  800d89:	8b 40 08             	mov    0x8(%eax),%eax
  800d8c:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800d90:	83 e0 40             	and    $0x40,%eax
  800d93:	0f b6 c0             	movzbl %al,%eax
  800d96:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800d98:	eb 0d                	jmp    800da7 <lwip_getsockopt_internal+0x16e>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800d9a:	8b 01                	mov    (%ecx),%eax
  800d9c:	8b 40 08             	mov    0x8(%eax),%eax
  800d9f:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800da5:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800da7:	83 ec 0c             	sub    $0xc,%esp
  800daa:	8b 01                	mov    (%ecx),%eax
  800dac:	ff 70 10             	pushl  0x10(%eax)
  800daf:	e8 29 92 00 00       	call   809fdd <sys_sem_signal>
}
  800db4:	83 c4 10             	add    $0x10,%esp
  800db7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800dba:	c9                   	leave  
  800dbb:	c3                   	ret    

00800dbc <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800dbc:	55                   	push   %ebp
  800dbd:	89 e5                	mov    %esp,%ebp
  800dbf:	53                   	push   %ebx
  800dc0:	83 ec 04             	sub    $0x4,%esp
  800dc3:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dc6:	85 c0                	test   %eax,%eax
  800dc8:	75 17                	jne    800de1 <lwip_setsockopt_internal+0x25>
  800dca:	83 ec 04             	sub    $0x4,%esp
  800dcd:	68 a2 0f 81 00       	push   $0x810fa2
  800dd2:	68 ae 06 00 00       	push   $0x6ae
  800dd7:	68 8b 0f 81 00       	push   $0x810f8b
  800ddc:	e8 69 d6 00 00       	call   80e44a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800de1:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800de3:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800de6:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800de9:	8b 40 08             	mov    0x8(%eax),%eax
  800dec:	83 f8 06             	cmp    $0x6,%eax
  800def:	0f 84 81 00 00 00    	je     800e76 <lwip_setsockopt_internal+0xba>
  800df5:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800dfa:	74 0a                	je     800e06 <lwip_setsockopt_internal+0x4a>
  800dfc:	85 c0                	test   %eax,%eax
  800dfe:	0f 85 a6 00 00 00    	jne    800eaa <lwip_setsockopt_internal+0xee>
  800e04:	eb 4e                	jmp    800e54 <lwip_setsockopt_internal+0x98>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800e06:	83 fa 20             	cmp    $0x20,%edx
  800e09:	74 11                	je     800e1c <lwip_setsockopt_internal+0x60>
  800e0b:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800e11:	74 26                	je     800e39 <lwip_setsockopt_internal+0x7d>
  800e13:	83 fa 08             	cmp    $0x8,%edx
  800e16:	0f 85 8e 00 00 00    	jne    800eaa <lwip_setsockopt_internal+0xee>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800e1c:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e1f:	74 0b                	je     800e2c <lwip_setsockopt_internal+0x70>
        sock->conn->pcb.ip->so_options |= optname;
  800e21:	8b 01                	mov    (%ecx),%eax
  800e23:	8b 40 08             	mov    0x8(%eax),%eax
  800e26:	66 09 50 08          	or     %dx,0x8(%eax)
  800e2a:	eb 7e                	jmp    800eaa <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800e2c:	8b 01                	mov    (%ecx),%eax
  800e2e:	8b 40 08             	mov    0x8(%eax),%eax
  800e31:	f7 d2                	not    %edx
  800e33:	66 21 50 08          	and    %dx,0x8(%eax)
  800e37:	eb 71                	jmp    800eaa <lwip_setsockopt_internal+0xee>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800e39:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e3c:	74 0b                	je     800e49 <lwip_setsockopt_internal+0x8d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e3e:	8b 01                	mov    (%ecx),%eax
  800e40:	8b 40 08             	mov    0x8(%eax),%eax
  800e43:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e47:	eb 61                	jmp    800eaa <lwip_setsockopt_internal+0xee>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e49:	8b 01                	mov    (%ecx),%eax
  800e4b:	8b 40 08             	mov    0x8(%eax),%eax
  800e4e:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e52:	eb 56                	jmp    800eaa <lwip_setsockopt_internal+0xee>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800e54:	83 fa 01             	cmp    $0x1,%edx
  800e57:	74 11                	je     800e6a <lwip_setsockopt_internal+0xae>
  800e59:	83 fa 02             	cmp    $0x2,%edx
  800e5c:	75 4c                	jne    800eaa <lwip_setsockopt_internal+0xee>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800e5e:	8b 01                	mov    (%ecx),%eax
  800e60:	8b 40 08             	mov    0x8(%eax),%eax
  800e63:	8b 13                	mov    (%ebx),%edx
  800e65:	88 50 0b             	mov    %dl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800e68:	eb 40                	jmp    800eaa <lwip_setsockopt_internal+0xee>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800e6a:	8b 01                	mov    (%ecx),%eax
  800e6c:	8b 40 08             	mov    0x8(%eax),%eax
  800e6f:	8b 13                	mov    (%ebx),%edx
  800e71:	88 50 0a             	mov    %dl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800e74:	eb 34                	jmp    800eaa <lwip_setsockopt_internal+0xee>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800e76:	83 fa 01             	cmp    $0x1,%edx
  800e79:	74 07                	je     800e82 <lwip_setsockopt_internal+0xc6>
  800e7b:	83 fa 02             	cmp    $0x2,%edx
  800e7e:	74 1d                	je     800e9d <lwip_setsockopt_internal+0xe1>
  800e80:	eb 28                	jmp    800eaa <lwip_setsockopt_internal+0xee>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800e82:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e85:	74 0b                	je     800e92 <lwip_setsockopt_internal+0xd6>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800e87:	8b 01                	mov    (%ecx),%eax
  800e89:	8b 40 08             	mov    0x8(%eax),%eax
  800e8c:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800e90:	eb 18                	jmp    800eaa <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800e92:	8b 01                	mov    (%ecx),%eax
  800e94:	8b 40 08             	mov    0x8(%eax),%eax
  800e97:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800e9b:	eb 0d                	jmp    800eaa <lwip_setsockopt_internal+0xee>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800e9d:	8b 01                	mov    (%ecx),%eax
  800e9f:	8b 40 08             	mov    0x8(%eax),%eax
  800ea2:	8b 13                	mov    (%ebx),%edx
  800ea4:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800eaa:	83 ec 0c             	sub    $0xc,%esp
  800ead:	8b 01                	mov    (%ecx),%eax
  800eaf:	ff 70 10             	pushl  0x10(%eax)
  800eb2:	e8 26 91 00 00       	call   809fdd <sys_sem_signal>
}
  800eb7:	83 c4 10             	add    $0x10,%esp
  800eba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800ebd:	c9                   	leave  
  800ebe:	c3                   	ret    

00800ebf <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  800ebf:	55                   	push   %ebp
  800ec0:	89 e5                	mov    %esp,%ebp
  800ec2:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800ec5:	6a 01                	push   $0x1
  800ec7:	e8 65 8e 00 00       	call   809d31 <sys_sem_new>
  800ecc:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800ed1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800ed8:	e8 54 8e 00 00       	call   809d31 <sys_sem_new>
  800edd:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800ee2:	83 c4 10             	add    $0x10,%esp
  800ee5:	c9                   	leave  
  800ee6:	c3                   	ret    

00800ee7 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  800ee7:	55                   	push   %ebp
  800ee8:	89 e5                	mov    %esp,%ebp
  800eea:	57                   	push   %edi
  800eeb:	56                   	push   %esi
  800eec:	53                   	push   %ebx
  800eed:	83 ec 3c             	sub    $0x3c,%esp
  800ef0:	8b 7d 10             	mov    0x10(%ebp),%edi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  800ef3:	8b 45 08             	mov    0x8(%ebp),%eax
  800ef6:	e8 fa f8 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  800efb:	85 c0                	test   %eax,%eax
  800efd:	0f 84 86 01 00 00    	je     801089 <lwip_accept+0x1a2>
  800f03:	89 c6                	mov    %eax,%esi
    return -1;

  newconn = netconn_accept(sock->conn);
  800f05:	83 ec 0c             	sub    $0xc,%esp
  800f08:	ff 30                	pushl  (%eax)
  800f0a:	e8 21 9f 00 00       	call   80ae30 <netconn_accept>
  800f0f:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800f11:	83 c4 10             	add    $0x10,%esp
  800f14:	85 c0                	test   %eax,%eax
  800f16:	75 2c                	jne    800f44 <lwip_accept+0x5d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800f18:	8b 06                	mov    (%esi),%eax
  800f1a:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800f1e:	f7 d8                	neg    %eax
  800f20:	ba 05 00 00 00       	mov    $0x5,%edx
  800f25:	83 f8 0e             	cmp    $0xe,%eax
  800f28:	77 07                	ja     800f31 <lwip_accept+0x4a>
  800f2a:	8b 14 85 40 10 81 00 	mov    0x811040(,%eax,4),%edx
  800f31:	89 56 10             	mov    %edx,0x10(%esi)
  800f34:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f3f:	e9 4a 01 00 00       	jmp    80108e <lwip_accept+0x1a7>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  800f44:	6a 00                	push   $0x0
  800f46:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800f49:	50                   	push   %eax
  800f4a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800f4d:	50                   	push   %eax
  800f4e:	53                   	push   %ebx
  800f4f:	e8 26 9d 00 00       	call   80ac7a <netconn_getaddr>
  800f54:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f57:	83 c4 10             	add    $0x10,%esp
  800f5a:	84 c0                	test   %al,%al
  800f5c:	74 36                	je     800f94 <lwip_accept+0xad>
    netconn_delete(newconn);
  800f5e:	83 ec 0c             	sub    $0xc,%esp
  800f61:	53                   	push   %ebx
  800f62:	e8 ab 9c 00 00       	call   80ac12 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f67:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f6b:	f7 d8                	neg    %eax
  800f6d:	83 c4 10             	add    $0x10,%esp
  800f70:	ba 05 00 00 00       	mov    $0x5,%edx
  800f75:	83 f8 0e             	cmp    $0xe,%eax
  800f78:	77 07                	ja     800f81 <lwip_accept+0x9a>
  800f7a:	8b 14 85 40 10 81 00 	mov    0x811040(,%eax,4),%edx
  800f81:	89 56 10             	mov    %edx,0x10(%esi)
  800f84:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f8f:	e9 fa 00 00 00       	jmp    80108e <lwip_accept+0x1a7>
  }

  memset(&sin, 0, sizeof(sin));
  800f94:	83 ec 04             	sub    $0x4,%esp
  800f97:	6a 10                	push   $0x10
  800f99:	6a 00                	push   $0x0
  800f9b:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f9e:	50                   	push   %eax
  800f9f:	e8 49 dc 00 00       	call   80ebed <memset>
  sin.sin_len = sizeof(sin);
  800fa4:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800fa8:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800fac:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800fb0:	89 04 24             	mov    %eax,(%esp)
  800fb3:	e8 23 67 00 00       	call   8076db <htons>
  800fb8:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800fbf:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  800fc2:	83 c4 10             	add    $0x10,%esp
  800fc5:	83 3f 10             	cmpl   $0x10,(%edi)
  800fc8:	76 06                	jbe    800fd0 <lwip_accept+0xe9>
    *addrlen = sizeof(sin);
  800fca:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(addr, &sin, *addrlen);
  800fd0:	83 ec 04             	sub    $0x4,%esp
  800fd3:	ff 37                	pushl  (%edi)
  800fd5:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800fd8:	50                   	push   %eax
  800fd9:	ff 75 0c             	pushl  0xc(%ebp)
  800fdc:	e8 c1 dc 00 00       	call   80eca2 <memcpy>

  newsock = alloc_socket(newconn);
  800fe1:	89 d8                	mov    %ebx,%eax
  800fe3:	e8 a9 fb ff ff       	call   800b91 <alloc_socket>
  800fe8:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800fea:	83 c4 10             	add    $0x10,%esp
  800fed:	83 f8 ff             	cmp    $0xffffffff,%eax
  800ff0:	75 24                	jne    801016 <lwip_accept+0x12f>
    netconn_delete(newconn);
  800ff2:	83 ec 0c             	sub    $0xc,%esp
  800ff5:	53                   	push   %ebx
  800ff6:	e8 17 9c 00 00       	call   80ac12 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800ffb:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  801002:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801009:	00 00 00 
    return -1;
  80100c:	83 c4 10             	add    $0x10,%esp
  80100f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801014:	eb 78                	jmp    80108e <lwip_accept+0x1a7>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  801016:	83 f8 1f             	cmp    $0x1f,%eax
  801019:	76 17                	jbe    801032 <lwip_accept+0x14b>
  80101b:	83 ec 04             	sub    $0x4,%esp
  80101e:	68 ae 0f 81 00       	push   $0x810fae
  801023:	68 25 01 00 00       	push   $0x125
  801028:	68 8b 0f 81 00       	push   $0x810f8b
  80102d:	e8 18 d4 00 00       	call   80e44a <_panic>
  newconn->callback = event_callback;
  801032:	c7 43 2c f1 09 80 00 	movl   $0x8009f1,0x2c(%ebx)
  nsock = &sockets[newsock];
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  801039:	83 ec 0c             	sub    $0xc,%esp
  80103c:	ff 35 44 50 81 00    	pushl  0x815044
  801042:	e8 a0 40 00 00       	call   8050e7 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  801047:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  80104a:	8d 14 85 60 50 81 00 	lea    0x815060(,%eax,4),%edx
  801051:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  801055:	83 e8 01             	sub    $0x1,%eax
  801058:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  80105c:	66 89 42 0a          	mov    %ax,0xa(%edx)
  newconn->socket = newsock;
  801060:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  801063:	83 c4 04             	add    $0x4,%esp
  801066:	ff 35 44 50 81 00    	pushl  0x815044
  80106c:	e8 6c 8f 00 00       	call   809fdd <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  801071:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801078:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80107f:	00 00 00 
  return newsock;
  801082:	83 c4 10             	add    $0x10,%esp
  801085:	89 f8                	mov    %edi,%eax
  801087:	eb 05                	jmp    80108e <lwip_accept+0x1a7>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801089:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  80108e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801091:	5b                   	pop    %ebx
  801092:	5e                   	pop    %esi
  801093:	5f                   	pop    %edi
  801094:	5d                   	pop    %ebp
  801095:	c3                   	ret    

00801096 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801096:	55                   	push   %ebp
  801097:	89 e5                	mov    %esp,%ebp
  801099:	56                   	push   %esi
  80109a:	53                   	push   %ebx
  80109b:	83 ec 10             	sub    $0x10,%esp
  80109e:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  8010a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8010a4:	e8 4c f7 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  8010a9:	85 c0                	test   %eax,%eax
  8010ab:	0f 84 8f 00 00 00    	je     801140 <lwip_bind+0xaa>
  8010b1:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8010b3:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8010b7:	75 06                	jne    8010bf <lwip_bind+0x29>
  8010b9:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8010bd:	74 17                	je     8010d6 <lwip_bind+0x40>
  8010bf:	83 ec 04             	sub    $0x4,%esp
  8010c2:	68 c3 0f 81 00       	push   $0x810fc3
  8010c7:	68 4a 01 00 00       	push   $0x14a
  8010cc:	68 8b 0f 81 00       	push   $0x810f8b
  8010d1:	e8 74 d3 00 00       	call   80e44a <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8010d6:	8b 46 04             	mov    0x4(%esi),%eax
  8010d9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8010dc:	83 ec 0c             	sub    $0xc,%esp
  8010df:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8010e3:	50                   	push   %eax
  8010e4:	e8 ff 65 00 00       	call   8076e8 <ntohs>
  8010e9:	83 c4 0c             	add    $0xc,%esp
  8010ec:	0f b7 c0             	movzwl %ax,%eax
  8010ef:	50                   	push   %eax
  8010f0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8010f3:	50                   	push   %eax
  8010f4:	ff 33                	pushl  (%ebx)
  8010f6:	e8 0b 9c 00 00       	call   80ad06 <netconn_bind>

  if (err != ERR_OK) {
  8010fb:	83 c4 10             	add    $0x10,%esp
  8010fe:	84 c0                	test   %al,%al
  801100:	74 26                	je     801128 <lwip_bind+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801102:	0f be c0             	movsbl %al,%eax
  801105:	f7 d8                	neg    %eax
  801107:	ba 05 00 00 00       	mov    $0x5,%edx
  80110c:	83 f8 0e             	cmp    $0xe,%eax
  80110f:	77 07                	ja     801118 <lwip_bind+0x82>
  801111:	8b 14 85 40 10 81 00 	mov    0x811040(,%eax,4),%edx
  801118:	89 53 10             	mov    %edx,0x10(%ebx)
  80111b:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801121:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801126:	eb 1d                	jmp    801145 <lwip_bind+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801128:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80112f:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801136:	00 00 00 
  return 0;
  801139:	b8 00 00 00 00       	mov    $0x0,%eax
  80113e:	eb 05                	jmp    801145 <lwip_bind+0xaf>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801140:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801145:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801148:	5b                   	pop    %ebx
  801149:	5e                   	pop    %esi
  80114a:	5d                   	pop    %ebp
  80114b:	c3                   	ret    

0080114c <lwip_close>:

int
lwip_close(int s)
{
  80114c:	55                   	push   %ebp
  80114d:	89 e5                	mov    %esp,%ebp
  80114f:	53                   	push   %ebx
  801150:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  801153:	8b 45 08             	mov    0x8(%ebp),%eax
  801156:	e8 9a f6 ff ff       	call   8007f5 <get_socket>
  if (!sock) {
  80115b:	85 c0                	test   %eax,%eax
  80115d:	74 6c                	je     8011cb <lwip_close+0x7f>
  80115f:	89 c3                	mov    %eax,%ebx
    return -1;
  }

  netconn_delete(sock->conn);
  801161:	83 ec 0c             	sub    $0xc,%esp
  801164:	ff 30                	pushl  (%eax)
  801166:	e8 a7 9a 00 00       	call   80ac12 <netconn_delete>

  sys_sem_wait(socksem);
  80116b:	83 c4 04             	add    $0x4,%esp
  80116e:	ff 35 44 50 81 00    	pushl  0x815044
  801174:	e8 6e 3f 00 00       	call   8050e7 <sys_sem_wait>
  if (sock->lastdata) {
  801179:	8b 43 04             	mov    0x4(%ebx),%eax
  80117c:	83 c4 10             	add    $0x10,%esp
  80117f:	85 c0                	test   %eax,%eax
  801181:	74 0c                	je     80118f <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  801183:	83 ec 0c             	sub    $0xc,%esp
  801186:	50                   	push   %eax
  801187:	e8 6c 13 00 00       	call   8024f8 <netbuf_delete>
  80118c:	83 c4 10             	add    $0x10,%esp
  }
  sock->lastdata   = NULL;
  80118f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801196:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80119c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8011a2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8011a9:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8011b0:	00 00 00 
  sys_sem_signal(socksem);
  8011b3:	83 ec 0c             	sub    $0xc,%esp
  8011b6:	ff 35 44 50 81 00    	pushl  0x815044
  8011bc:	e8 1c 8e 00 00       	call   809fdd <sys_sem_signal>
  return 0;
  8011c1:	83 c4 10             	add    $0x10,%esp
  8011c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8011c9:	eb 05                	jmp    8011d0 <lwip_close+0x84>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  8011cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  8011d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8011d3:	c9                   	leave  
  8011d4:	c3                   	ret    

008011d5 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8011d5:	55                   	push   %ebp
  8011d6:	89 e5                	mov    %esp,%ebp
  8011d8:	56                   	push   %esi
  8011d9:	53                   	push   %ebx
  8011da:	83 ec 10             	sub    $0x10,%esp
  8011dd:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8011e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8011e3:	e8 0d f6 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  8011e8:	85 c0                	test   %eax,%eax
  8011ea:	0f 84 8f 00 00 00    	je     80127f <lwip_connect+0xaa>
  8011f0:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011f2:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8011f6:	75 06                	jne    8011fe <lwip_connect+0x29>
  8011f8:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8011fc:	74 17                	je     801215 <lwip_connect+0x40>
  8011fe:	83 ec 04             	sub    $0x4,%esp
  801201:	68 de 0f 81 00       	push   $0x810fde
  801206:	68 86 01 00 00       	push   $0x186
  80120b:	68 8b 0f 81 00       	push   $0x810f8b
  801210:	e8 35 d2 00 00       	call   80e44a <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801215:	8b 46 04             	mov    0x4(%esi),%eax
  801218:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80121b:	83 ec 0c             	sub    $0xc,%esp
  80121e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801222:	50                   	push   %eax
  801223:	e8 c0 64 00 00       	call   8076e8 <ntohs>
  801228:	83 c4 0c             	add    $0xc,%esp
  80122b:	0f b7 c0             	movzwl %ax,%eax
  80122e:	50                   	push   %eax
  80122f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801232:	50                   	push   %eax
  801233:	ff 33                	pushl  (%ebx)
  801235:	e8 1d 9b 00 00       	call   80ad57 <netconn_connect>
  }

  if (err != ERR_OK) {
  80123a:	83 c4 10             	add    $0x10,%esp
  80123d:	84 c0                	test   %al,%al
  80123f:	74 26                	je     801267 <lwip_connect+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801241:	0f be c0             	movsbl %al,%eax
  801244:	f7 d8                	neg    %eax
  801246:	ba 05 00 00 00       	mov    $0x5,%edx
  80124b:	83 f8 0e             	cmp    $0xe,%eax
  80124e:	77 07                	ja     801257 <lwip_connect+0x82>
  801250:	8b 14 85 40 10 81 00 	mov    0x811040(,%eax,4),%edx
  801257:	89 53 10             	mov    %edx,0x10(%ebx)
  80125a:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801260:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801265:	eb 1d                	jmp    801284 <lwip_connect+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801267:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80126e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801275:	00 00 00 
  return 0;
  801278:	b8 00 00 00 00       	mov    $0x0,%eax
  80127d:	eb 05                	jmp    801284 <lwip_connect+0xaf>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  80127f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801284:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801287:	5b                   	pop    %ebx
  801288:	5e                   	pop    %esi
  801289:	5d                   	pop    %ebp
  80128a:	c3                   	ret    

0080128b <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  80128b:	55                   	push   %ebp
  80128c:	89 e5                	mov    %esp,%ebp
  80128e:	56                   	push   %esi
  80128f:	53                   	push   %ebx
  801290:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  801293:	8b 45 08             	mov    0x8(%ebp),%eax
  801296:	e8 5a f5 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  80129b:	85 c0                	test   %eax,%eax
  80129d:	74 6d                	je     80130c <lwip_listen+0x81>
  80129f:	89 c6                	mov    %eax,%esi
  8012a1:	85 db                	test   %ebx,%ebx
  8012a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8012a8:	0f 48 d8             	cmovs  %eax,%ebx
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  8012ab:	83 ec 08             	sub    $0x8,%esp
  8012ae:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8012b4:	b8 ff 00 00 00       	mov    $0xff,%eax
  8012b9:	0f 4f d8             	cmovg  %eax,%ebx
  8012bc:	0f b6 db             	movzbl %bl,%ebx
  8012bf:	53                   	push   %ebx
  8012c0:	ff 36                	pushl  (%esi)
  8012c2:	e8 25 9b 00 00       	call   80adec <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  8012c7:	83 c4 10             	add    $0x10,%esp
  8012ca:	84 c0                	test   %al,%al
  8012cc:	74 26                	je     8012f4 <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8012ce:	0f be c0             	movsbl %al,%eax
  8012d1:	f7 d8                	neg    %eax
  8012d3:	ba 05 00 00 00       	mov    $0x5,%edx
  8012d8:	83 f8 0e             	cmp    $0xe,%eax
  8012db:	77 07                	ja     8012e4 <lwip_listen+0x59>
  8012dd:	8b 14 85 40 10 81 00 	mov    0x811040(,%eax,4),%edx
  8012e4:	89 56 10             	mov    %edx,0x10(%esi)
  8012e7:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8012ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012f2:	eb 1d                	jmp    801311 <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  8012f4:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8012fb:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801302:	00 00 00 
  return 0;
  801305:	b8 00 00 00 00       	mov    $0x0,%eax
  80130a:	eb 05                	jmp    801311 <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  80130c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  801311:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801314:	5b                   	pop    %ebx
  801315:	5e                   	pop    %esi
  801316:	5d                   	pop    %ebp
  801317:	c3                   	ret    

00801318 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  801318:	55                   	push   %ebp
  801319:	89 e5                	mov    %esp,%ebp
  80131b:	57                   	push   %edi
  80131c:	56                   	push   %esi
  80131d:	53                   	push   %ebx
  80131e:	83 ec 4c             	sub    $0x4c,%esp
  801321:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  801324:	8b 45 08             	mov    0x8(%ebp),%eax
  801327:	e8 c9 f4 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  80132c:	85 c0                	test   %eax,%eax
  80132e:	0f 84 04 02 00 00    	je     801538 <lwip_recvfrom+0x220>
  801334:	89 c7                	mov    %eax,%edi
  801336:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80133c:	89 d8                	mov    %ebx,%eax
  80133e:	83 e0 08             	and    $0x8,%eax
  801341:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801344:	83 e3 01             	and    $0x1,%ebx
  801347:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80134a:	8b 77 04             	mov    0x4(%edi),%esi
  80134d:	85 f6                	test   %esi,%esi
  80134f:	0f 85 80 00 00 00    	jne    8013d5 <lwip_recvfrom+0xbd>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801355:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801359:	75 06                	jne    801361 <lwip_recvfrom+0x49>
  80135b:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  80135f:	74 22                	je     801383 <lwip_recvfrom+0x6b>
  801361:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801366:	75 1b                	jne    801383 <lwip_recvfrom+0x6b>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  801368:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  80136f:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801376:	00 00 00 
        return -1;
  801379:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80137e:	e9 ba 01 00 00       	jmp    80153d <lwip_recvfrom+0x225>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  801383:	83 ec 0c             	sub    $0xc,%esp
  801386:	ff 37                	pushl  (%edi)
  801388:	e8 15 9b 00 00       	call   80aea2 <netconn_recv>
  80138d:	89 c6                	mov    %eax,%esi
  80138f:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801392:	83 c4 10             	add    $0x10,%esp
  801395:	85 c0                	test   %eax,%eax
  801397:	75 3c                	jne    8013d5 <lwip_recvfrom+0xbd>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801399:	8b 17                	mov    (%edi),%edx
  80139b:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80139f:	74 0b                	je     8013ac <lwip_recvfrom+0x94>
  8013a1:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8013a6:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8013aa:	74 17                	je     8013c3 <lwip_recvfrom+0xab>
  8013ac:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8013b0:	f7 da                	neg    %edx
  8013b2:	b8 05 00 00 00       	mov    $0x5,%eax
  8013b7:	83 fa 0e             	cmp    $0xe,%edx
  8013ba:	77 07                	ja     8013c3 <lwip_recvfrom+0xab>
  8013bc:	8b 04 95 40 10 81 00 	mov    0x811040(,%edx,4),%eax
  8013c3:	89 47 10             	mov    %eax,0x10(%edi)
  8013c6:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  8013cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8013d0:	e9 68 01 00 00       	jmp    80153d <lwip_recvfrom+0x225>
      }
    }

    buflen = netbuf_len(buf);
  8013d5:	8b 16                	mov    (%esi),%edx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  8013d7:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8013db:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  8013df:	29 c3                	sub    %eax,%ebx

    if (len > buflen) {
  8013e1:	0f b7 cb             	movzwl %bx,%ecx
  8013e4:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  8013e7:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  8013ea:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8013ef:	0f b7 cb             	movzwl %bx,%ecx
  8013f2:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8013f5:	0f b7 c0             	movzwl %ax,%eax
  8013f8:	50                   	push   %eax
  8013f9:	51                   	push   %ecx
  8013fa:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8013fe:	03 45 0c             	add    0xc(%ebp),%eax
  801401:	50                   	push   %eax
  801402:	52                   	push   %edx
  801403:	e8 72 3b 00 00       	call   804f7a <pbuf_copy_partial>

    off += copylen;
  801408:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80140c:	83 c4 04             	add    $0x4,%esp
  80140f:	ff 37                	pushl  (%edi)
  801411:	e8 3c 98 00 00       	call   80ac52 <netconn_type>
  801416:	83 c4 10             	add    $0x10,%esp
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  801419:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80141d:	83 f8 10             	cmp    $0x10,%eax
  801420:	75 1d                	jne    80143f <lwip_recvfrom+0x127>
      len -= copylen;
  801422:	8b 45 c0             	mov    -0x40(%ebp),%eax
  801425:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801428:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80142c:	7e 11                	jle    80143f <lwip_recvfrom+0x127>
  80142e:	8b 06                	mov    (%esi),%eax
  801430:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  801434:	75 09                	jne    80143f <lwip_recvfrom+0x127>
        done = 1;
  801436:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80143b:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80143f:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801443:	75 3d                	jne    801482 <lwip_recvfrom+0x16a>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801445:	8b 07                	mov    (%edi),%eax
  801447:	83 38 10             	cmpl   $0x10,(%eax)
  80144a:	75 13                	jne    80145f <lwip_recvfrom+0x147>
  80144c:	8b 45 bc             	mov    -0x44(%ebp),%eax
  80144f:	2b 45 c0             	sub    -0x40(%ebp),%eax
  801452:	85 c0                	test   %eax,%eax
  801454:	7e 09                	jle    80145f <lwip_recvfrom+0x147>
        sock->lastdata = buf;
  801456:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  801459:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  80145d:	eb 19                	jmp    801478 <lwip_recvfrom+0x160>
      } else {
        sock->lastdata = NULL;
  80145f:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801466:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80146c:	83 ec 0c             	sub    $0xc,%esp
  80146f:	56                   	push   %esi
  801470:	e8 83 10 00 00       	call   8024f8 <netbuf_delete>
  801475:	83 c4 10             	add    $0x10,%esp
      }
    } else {
      done = 1;
    }
  } while (!done);
  801478:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80147c:	0f 84 c8 fe ff ff    	je     80134a <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  801482:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801486:	0f 84 95 00 00 00    	je     801521 <lwip_recvfrom+0x209>
  80148c:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801490:	0f 84 8b 00 00 00    	je     801521 <lwip_recvfrom+0x209>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801496:	83 ec 0c             	sub    $0xc,%esp
  801499:	ff 37                	pushl  (%edi)
  80149b:	e8 b2 97 00 00       	call   80ac52 <netconn_type>
  8014a0:	83 c4 10             	add    $0x10,%esp
  8014a3:	83 f8 10             	cmp    $0x10,%eax
  8014a6:	75 19                	jne    8014c1 <lwip_recvfrom+0x1a9>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  8014a8:	6a 00                	push   $0x0
  8014aa:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8014ad:	50                   	push   %eax
  8014ae:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8014b1:	50                   	push   %eax
  8014b2:	ff 37                	pushl  (%edi)
  8014b4:	e8 c1 97 00 00       	call   80ac7a <netconn_getaddr>
  8014b9:	83 c4 10             	add    $0x10,%esp
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8014bc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8014bf:	eb 0b                	jmp    8014cc <lwip_recvfrom+0x1b4>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  8014c1:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8014c4:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8014c8:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  8014cc:	83 ec 04             	sub    $0x4,%esp
  8014cf:	6a 10                	push   $0x10
  8014d1:	6a 00                	push   $0x0
  8014d3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014d6:	50                   	push   %eax
  8014d7:	e8 11 d7 00 00       	call   80ebed <memset>
    sin.sin_len = sizeof(sin);
  8014dc:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8014e0:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8014e4:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8014e8:	89 04 24             	mov    %eax,(%esp)
  8014eb:	e8 eb 61 00 00       	call   8076db <htons>
  8014f0:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8014f4:	8b 03                	mov    (%ebx),%eax
  8014f6:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8014f9:	83 c4 10             	add    $0x10,%esp
  8014fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014ff:	83 38 10             	cmpl   $0x10,(%eax)
  801502:	76 06                	jbe    80150a <lwip_recvfrom+0x1f2>
      *fromlen = sizeof(sin);
  801504:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  80150a:	83 ec 04             	sub    $0x4,%esp
  80150d:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801510:	ff 30                	pushl  (%eax)
  801512:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801515:	50                   	push   %eax
  801516:	ff 75 18             	pushl  0x18(%ebp)
  801519:	e8 84 d7 00 00       	call   80eca2 <memcpy>
  80151e:	83 c4 10             	add    $0x10,%esp
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  801521:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801528:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80152f:	00 00 00 
  return off;
  801532:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  801536:	eb 05                	jmp    80153d <lwip_recvfrom+0x225>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801538:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  80153d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801540:	5b                   	pop    %ebx
  801541:	5e                   	pop    %esi
  801542:	5f                   	pop    %edi
  801543:	5d                   	pop    %ebp
  801544:	c3                   	ret    

00801545 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  801545:	55                   	push   %ebp
  801546:	89 e5                	mov    %esp,%ebp
  801548:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  80154b:	6a 00                	push   $0x0
  80154d:	6a 00                	push   $0x0
  80154f:	6a 00                	push   $0x0
  801551:	ff 75 10             	pushl  0x10(%ebp)
  801554:	ff 75 0c             	pushl  0xc(%ebp)
  801557:	ff 75 08             	pushl  0x8(%ebp)
  80155a:	e8 b9 fd ff ff       	call   801318 <lwip_recvfrom>
}
  80155f:	c9                   	leave  
  801560:	c3                   	ret    

00801561 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  801561:	55                   	push   %ebp
  801562:	89 e5                	mov    %esp,%ebp
  801564:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801567:	6a 00                	push   $0x0
  801569:	6a 00                	push   $0x0
  80156b:	ff 75 14             	pushl  0x14(%ebp)
  80156e:	ff 75 10             	pushl  0x10(%ebp)
  801571:	ff 75 0c             	pushl  0xc(%ebp)
  801574:	ff 75 08             	pushl  0x8(%ebp)
  801577:	e8 9c fd ff ff       	call   801318 <lwip_recvfrom>
}
  80157c:	c9                   	leave  
  80157d:	c3                   	ret    

0080157e <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80157e:	55                   	push   %ebp
  80157f:	89 e5                	mov    %esp,%ebp
  801581:	57                   	push   %edi
  801582:	56                   	push   %esi
  801583:	53                   	push   %ebx
  801584:	83 ec 2c             	sub    $0x2c,%esp
  801587:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80158a:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80158d:	8b 45 08             	mov    0x8(%ebp),%eax
  801590:	e8 60 f2 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  801595:	85 c0                	test   %eax,%eax
  801597:	0f 84 21 01 00 00    	je     8016be <lwip_sendto+0x140>
  80159d:	89 c7                	mov    %eax,%edi
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80159f:	8b 00                	mov    (%eax),%eax
  8015a1:	83 38 10             	cmpl   $0x10,(%eax)
  8015a4:	75 17                	jne    8015bd <lwip_sendto+0x3f>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8015a6:	ff 75 14             	pushl  0x14(%ebp)
  8015a9:	53                   	push   %ebx
  8015aa:	ff 75 0c             	pushl  0xc(%ebp)
  8015ad:	ff 75 08             	pushl  0x8(%ebp)
  8015b0:	e8 16 01 00 00       	call   8016cb <lwip_send>
  8015b5:	83 c4 10             	add    $0x10,%esp
  8015b8:	e9 06 01 00 00       	jmp    8016c3 <lwip_sendto+0x145>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8015bd:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8015c3:	76 17                	jbe    8015dc <lwip_sendto+0x5e>
  8015c5:	83 ec 04             	sub    $0x4,%esp
  8015c8:	68 1c 10 81 00       	push   $0x81101c
  8015cd:	68 97 02 00 00       	push   $0x297
  8015d2:	68 8b 0f 81 00       	push   $0x810f8b
  8015d7:	e8 6e ce 00 00       	call   80e44a <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8015dc:	85 f6                	test   %esi,%esi
  8015de:	75 06                	jne    8015e6 <lwip_sendto+0x68>
  8015e0:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8015e4:	74 23                	je     801609 <lwip_sendto+0x8b>
  8015e6:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8015ea:	75 06                	jne    8015f2 <lwip_sendto+0x74>
  8015ec:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8015f0:	74 17                	je     801609 <lwip_sendto+0x8b>
  8015f2:	83 ec 04             	sub    $0x4,%esp
  8015f5:	68 fc 0f 81 00       	push   $0x810ffc
  8015fa:	68 9b 02 00 00       	push   $0x29b
  8015ff:	68 8b 0f 81 00       	push   $0x810f8b
  801604:	e8 41 ce 00 00       	call   80e44a <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801609:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801610:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801617:	85 f6                	test   %esi,%esi
  801619:	74 22                	je     80163d <lwip_sendto+0xbf>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80161b:	8b 46 04             	mov    0x4(%esi),%eax
  80161e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801621:	83 ec 0c             	sub    $0xc,%esp
  801624:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801628:	50                   	push   %eax
  801629:	e8 ba 60 00 00       	call   8076e8 <ntohs>
    buf.addr         = &remote_addr;
  80162e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801631:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801634:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801638:	83 c4 10             	add    $0x10,%esp
  80163b:	eb 14                	jmp    801651 <lwip_sendto+0xd3>
  } else {
    remote_addr.addr = 0;
  80163d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801644:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80164b:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801651:	83 ec 04             	sub    $0x4,%esp
  801654:	0f b7 c3             	movzwl %bx,%eax
  801657:	50                   	push   %eax
  801658:	ff 75 0c             	pushl  0xc(%ebp)
  80165b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80165e:	50                   	push   %eax
  80165f:	e8 96 0f 00 00       	call   8025fa <netbuf_ref>
  801664:	0f be f0             	movsbl %al,%esi
  801667:	83 c4 10             	add    $0x10,%esp
  80166a:	85 f6                	test   %esi,%esi
  80166c:	75 14                	jne    801682 <lwip_sendto+0x104>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  80166e:	83 ec 08             	sub    $0x8,%esp
  801671:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801674:	50                   	push   %eax
  801675:	ff 37                	pushl  (%edi)
  801677:	e8 c8 99 00 00       	call   80b044 <netconn_send>
  80167c:	0f be f0             	movsbl %al,%esi
  80167f:	83 c4 10             	add    $0x10,%esp
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  801682:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801685:	85 c0                	test   %eax,%eax
  801687:	74 0c                	je     801695 <lwip_sendto+0x117>
    pbuf_free(buf.p);
  801689:	83 ec 0c             	sub    $0xc,%esp
  80168c:	50                   	push   %eax
  80168d:	e8 98 31 00 00       	call   80482a <pbuf_free>
  801692:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  801695:	89 f2                	mov    %esi,%edx
  801697:	f7 da                	neg    %edx
  801699:	b8 05 00 00 00       	mov    $0x5,%eax
  80169e:	83 fa 0e             	cmp    $0xe,%edx
  8016a1:	77 07                	ja     8016aa <lwip_sendto+0x12c>
  8016a3:	8b 04 95 40 10 81 00 	mov    0x811040(,%edx,4),%eax
  8016aa:	89 47 10             	mov    %eax,0x10(%edi)
  8016ad:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016b2:	85 f6                	test   %esi,%esi
  8016b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016b9:	0f 44 c3             	cmove  %ebx,%eax
  8016bc:	eb 05                	jmp    8016c3 <lwip_sendto+0x145>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8016be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8016c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8016c6:	5b                   	pop    %ebx
  8016c7:	5e                   	pop    %esi
  8016c8:	5f                   	pop    %edi
  8016c9:	5d                   	pop    %ebp
  8016ca:	c3                   	ret    

008016cb <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8016cb:	55                   	push   %ebp
  8016cc:	89 e5                	mov    %esp,%ebp
  8016ce:	57                   	push   %edi
  8016cf:	56                   	push   %esi
  8016d0:	53                   	push   %ebx
  8016d1:	83 ec 0c             	sub    $0xc,%esp
  8016d4:	8b 7d 08             	mov    0x8(%ebp),%edi
  8016d7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8016da:	89 f8                	mov    %edi,%eax
  8016dc:	e8 14 f1 ff ff       	call   8007f5 <get_socket>
  if (!sock)
  8016e1:	85 c0                	test   %eax,%eax
  8016e3:	74 6c                	je     801751 <lwip_send+0x86>
  8016e5:	89 c6                	mov    %eax,%esi
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8016e7:	8b 10                	mov    (%eax),%edx
  8016e9:	83 3a 10             	cmpl   $0x10,(%edx)
  8016ec:	74 19                	je     801707 <lwip_send+0x3c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8016ee:	83 ec 08             	sub    $0x8,%esp
  8016f1:	6a 00                	push   $0x0
  8016f3:	6a 00                	push   $0x0
  8016f5:	ff 75 14             	pushl  0x14(%ebp)
  8016f8:	53                   	push   %ebx
  8016f9:	ff 75 0c             	pushl  0xc(%ebp)
  8016fc:	57                   	push   %edi
  8016fd:	e8 7c fe ff ff       	call   80157e <lwip_sendto>
  801702:	83 c4 20             	add    $0x20,%esp
  801705:	eb 4f                	jmp    801756 <lwip_send+0x8b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801707:	8b 45 14             	mov    0x14(%ebp),%eax
  80170a:	83 e0 10             	and    $0x10,%eax
  80170d:	83 f8 01             	cmp    $0x1,%eax
  801710:	19 c0                	sbb    %eax,%eax
  801712:	83 e0 fe             	and    $0xfffffffe,%eax
  801715:	83 c0 03             	add    $0x3,%eax
  801718:	50                   	push   %eax
  801719:	53                   	push   %ebx
  80171a:	ff 75 0c             	pushl  0xc(%ebp)
  80171d:	52                   	push   %edx
  80171e:	e8 9d 99 00 00       	call   80b0c0 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801723:	0f be d0             	movsbl %al,%edx
  801726:	f7 da                	neg    %edx
  801728:	83 c4 10             	add    $0x10,%esp
  80172b:	b9 05 00 00 00       	mov    $0x5,%ecx
  801730:	83 fa 0e             	cmp    $0xe,%edx
  801733:	77 07                	ja     80173c <lwip_send+0x71>
  801735:	8b 0c 95 40 10 81 00 	mov    0x811040(,%edx,4),%ecx
  80173c:	89 4e 10             	mov    %ecx,0x10(%esi)
  80173f:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801745:	84 c0                	test   %al,%al
  801747:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80174c:	0f 44 c3             	cmove  %ebx,%eax
  80174f:	eb 05                	jmp    801756 <lwip_send+0x8b>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801751:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801756:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801759:	5b                   	pop    %ebx
  80175a:	5e                   	pop    %esi
  80175b:	5f                   	pop    %edi
  80175c:	5d                   	pop    %ebp
  80175d:	c3                   	ret    

0080175e <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  80175e:	55                   	push   %ebp
  80175f:	89 e5                	mov    %esp,%ebp
  801761:	53                   	push   %ebx
  801762:	83 ec 04             	sub    $0x4,%esp
  801765:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  801768:	83 f8 02             	cmp    $0x2,%eax
  80176b:	74 27                	je     801794 <lwip_socket+0x36>
  80176d:	83 f8 03             	cmp    $0x3,%eax
  801770:	74 07                	je     801779 <lwip_socket+0x1b>
  801772:	83 f8 01             	cmp    $0x1,%eax
  801775:	75 5c                	jne    8017d3 <lwip_socket+0x75>
  801777:	eb 42                	jmp    8017bb <lwip_socket+0x5d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801779:	83 ec 04             	sub    $0x4,%esp
  80177c:	68 f1 09 80 00       	push   $0x8009f1
  801781:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801785:	50                   	push   %eax
  801786:	6a 40                	push   $0x40
  801788:	e8 97 93 00 00       	call   80ab24 <netconn_new_with_proto_and_callback>
  80178d:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80178f:	83 c4 10             	add    $0x10,%esp
  801792:	eb 50                	jmp    8017e4 <lwip_socket+0x86>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801794:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80179b:	0f 94 c0             	sete   %al
  80179e:	0f b6 c0             	movzbl %al,%eax
  8017a1:	83 c0 20             	add    $0x20,%eax
  8017a4:	83 ec 04             	sub    $0x4,%esp
  8017a7:	68 f1 09 80 00       	push   $0x8009f1
  8017ac:	6a 00                	push   $0x0
  8017ae:	50                   	push   %eax
  8017af:	e8 70 93 00 00       	call   80ab24 <netconn_new_with_proto_and_callback>
  8017b4:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8017b6:	83 c4 10             	add    $0x10,%esp
  8017b9:	eb 29                	jmp    8017e4 <lwip_socket+0x86>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8017bb:	83 ec 04             	sub    $0x4,%esp
  8017be:	68 f1 09 80 00       	push   $0x8009f1
  8017c3:	6a 00                	push   $0x0
  8017c5:	6a 10                	push   $0x10
  8017c7:	e8 58 93 00 00       	call   80ab24 <netconn_new_with_proto_and_callback>
  8017cc:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8017ce:	83 c4 10             	add    $0x10,%esp
  8017d1:	eb 11                	jmp    8017e4 <lwip_socket+0x86>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8017d3:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8017da:	00 00 00 
    return -1;
  8017dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017e2:	eb 4b                	jmp    80182f <lwip_socket+0xd1>
  }

  if (!conn) {
  8017e4:	85 db                	test   %ebx,%ebx
  8017e6:	75 11                	jne    8017f9 <lwip_socket+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8017e8:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  8017ef:	00 00 00 
    return -1;
  8017f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017f7:	eb 36                	jmp    80182f <lwip_socket+0xd1>
  }

  i = alloc_socket(conn);
  8017f9:	89 d8                	mov    %ebx,%eax
  8017fb:	e8 91 f3 ff ff       	call   800b91 <alloc_socket>

  if (i == -1) {
  801800:	83 f8 ff             	cmp    $0xffffffff,%eax
  801803:	75 1d                	jne    801822 <lwip_socket+0xc4>
    netconn_delete(conn);
  801805:	83 ec 0c             	sub    $0xc,%esp
  801808:	53                   	push   %ebx
  801809:	e8 04 94 00 00       	call   80ac12 <netconn_delete>
    set_errno(ENFILE);
  80180e:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801815:	00 00 00 
    return -1;
  801818:	83 c4 10             	add    $0x10,%esp
  80181b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801820:	eb 0d                	jmp    80182f <lwip_socket+0xd1>
  }
  conn->socket = i;
  801822:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801825:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80182c:	00 00 00 
  return i;
}
  80182f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801832:	c9                   	leave  
  801833:	c3                   	ret    

00801834 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801834:	55                   	push   %ebp
  801835:	89 e5                	mov    %esp,%ebp
  801837:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  80183a:	6a 00                	push   $0x0
  80183c:	ff 75 10             	pushl  0x10(%ebp)
  80183f:	ff 75 0c             	pushl  0xc(%ebp)
  801842:	ff 75 08             	pushl  0x8(%ebp)
  801845:	e8 81 fe ff ff       	call   8016cb <lwip_send>
}
  80184a:	c9                   	leave  
  80184b:	c3                   	ret    

0080184c <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  80184c:	55                   	push   %ebp
  80184d:	89 e5                	mov    %esp,%ebp
  80184f:	57                   	push   %edi
  801850:	56                   	push   %esi
  801851:	53                   	push   %ebx
  801852:	83 ec 58             	sub    $0x58,%esp
  801855:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801858:	8b 75 10             	mov    0x10(%ebp),%esi
  80185b:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  80185e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801865:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801868:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80186b:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  80186e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801875:	ff 35 40 50 81 00    	pushl  0x815040
  80187b:	e8 67 38 00 00       	call   8050e7 <sys_sem_wait>

  if (readset)
  801880:	83 c4 10             	add    $0x10,%esp
  801883:	85 ff                	test   %edi,%edi
  801885:	74 07                	je     80188e <lwip_select+0x42>
    lreadset = *readset;
  801887:	8b 07                	mov    (%edi),%eax
  801889:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80188c:	eb 13                	jmp    8018a1 <lwip_select+0x55>
  else
    FD_ZERO(&lreadset);
  80188e:	83 ec 04             	sub    $0x4,%esp
  801891:	6a 04                	push   $0x4
  801893:	6a 00                	push   $0x0
  801895:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801898:	50                   	push   %eax
  801899:	e8 4f d3 00 00       	call   80ebed <memset>
  80189e:	83 c4 10             	add    $0x10,%esp
  if (writeset)
  8018a1:	85 f6                	test   %esi,%esi
  8018a3:	74 07                	je     8018ac <lwip_select+0x60>
    lwriteset = *writeset;
  8018a5:	8b 06                	mov    (%esi),%eax
  8018a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8018aa:	eb 13                	jmp    8018bf <lwip_select+0x73>
  else
    FD_ZERO(&lwriteset);
  8018ac:	83 ec 04             	sub    $0x4,%esp
  8018af:	6a 04                	push   $0x4
  8018b1:	6a 00                	push   $0x0
  8018b3:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8018b6:	50                   	push   %eax
  8018b7:	e8 31 d3 00 00       	call   80ebed <memset>
  8018bc:	83 c4 10             	add    $0x10,%esp
  if (exceptset)
  8018bf:	85 db                	test   %ebx,%ebx
  8018c1:	74 07                	je     8018ca <lwip_select+0x7e>
    lexceptset = *exceptset;
  8018c3:	8b 03                	mov    (%ebx),%eax
  8018c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8018c8:	eb 13                	jmp    8018dd <lwip_select+0x91>
  else
    FD_ZERO(&lexceptset);
  8018ca:	83 ec 04             	sub    $0x4,%esp
  8018cd:	6a 04                	push   $0x4
  8018cf:	6a 00                	push   $0x0
  8018d1:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018d4:	50                   	push   %eax
  8018d5:	e8 13 d3 00 00       	call   80ebed <memset>
  8018da:	83 c4 10             	add    $0x10,%esp

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8018dd:	83 ec 0c             	sub    $0xc,%esp
  8018e0:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018e3:	50                   	push   %eax
  8018e4:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8018e7:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8018ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8018ed:	e8 4e ef ff ff       	call   800840 <lwip_selscan>
  8018f2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8018f5:	83 c4 10             	add    $0x10,%esp
  8018f8:	85 c0                	test   %eax,%eax
  8018fa:	0f 85 b5 01 00 00    	jne    801ab5 <lwip_select+0x269>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801900:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801904:	0f 84 4f 02 00 00    	je     801b59 <lwip_select+0x30d>
  80190a:	8b 45 18             	mov    0x18(%ebp),%eax
  80190d:	83 38 00             	cmpl   $0x0,(%eax)
  801910:	0f 85 dd 01 00 00    	jne    801af3 <lwip_select+0x2a7>
  801916:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80191a:	0f 85 d3 01 00 00    	jne    801af3 <lwip_select+0x2a7>
      sys_sem_signal(selectsem);
  801920:	83 ec 0c             	sub    $0xc,%esp
  801923:	ff 35 40 50 81 00    	pushl  0x815040
  801929:	e8 af 86 00 00       	call   809fdd <sys_sem_signal>
      if (readset)
  80192e:	83 c4 10             	add    $0x10,%esp
  801931:	85 ff                	test   %edi,%edi
  801933:	74 10                	je     801945 <lwip_select+0xf9>
        FD_ZERO(readset);
  801935:	83 ec 04             	sub    $0x4,%esp
  801938:	6a 04                	push   $0x4
  80193a:	6a 00                	push   $0x0
  80193c:	57                   	push   %edi
  80193d:	e8 ab d2 00 00       	call   80ebed <memset>
  801942:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801945:	85 f6                	test   %esi,%esi
  801947:	74 10                	je     801959 <lwip_select+0x10d>
        FD_ZERO(writeset);
  801949:	83 ec 04             	sub    $0x4,%esp
  80194c:	6a 04                	push   $0x4
  80194e:	6a 00                	push   $0x0
  801950:	56                   	push   %esi
  801951:	e8 97 d2 00 00       	call   80ebed <memset>
  801956:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801959:	85 db                	test   %ebx,%ebx
  80195b:	74 10                	je     80196d <lwip_select+0x121>
        FD_ZERO(exceptset);
  80195d:	83 ec 04             	sub    $0x4,%esp
  801960:	6a 04                	push   $0x4
  801962:	6a 00                	push   $0x0
  801964:	53                   	push   %ebx
  801965:	e8 83 d2 00 00       	call   80ebed <memset>
  80196a:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  80196d:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801974:	00 00 00 
  
      return 0;
  801977:	b8 00 00 00 00       	mov    $0x0,%eax
  80197c:	e9 10 02 00 00       	jmp    801b91 <lwip_select+0x345>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801981:	83 ec 08             	sub    $0x8,%esp
  801984:	52                   	push   %edx
  801985:	ff 75 d8             	pushl  -0x28(%ebp)
  801988:	e8 19 39 00 00       	call   8052a6 <sys_sem_wait_timeout>
  80198d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  801990:	83 c4 04             	add    $0x4,%esp
  801993:	ff 35 40 50 81 00    	pushl  0x815040
  801999:	e8 49 37 00 00       	call   8050e7 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  80199e:	a1 48 50 81 00       	mov    0x815048,%eax
  8019a3:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8019a6:	83 c4 10             	add    $0x10,%esp
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8019a9:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  8019ab:	39 d0                	cmp    %edx,%eax
  8019ad:	75 19                	jne    8019c8 <lwip_select+0x17c>
      select_cb_list = select_cb.next;
  8019af:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8019b2:	a3 48 50 81 00       	mov    %eax,0x815048
  8019b7:	eb 13                	jmp    8019cc <lwip_select+0x180>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8019b9:	8b 10                	mov    (%eax),%edx
  8019bb:	39 ca                	cmp    %ecx,%edx
  8019bd:	75 07                	jne    8019c6 <lwip_select+0x17a>
          p_selcb->next = select_cb.next;
  8019bf:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8019c2:	89 10                	mov    %edx,(%eax)
          break;
  8019c4:	eb 06                	jmp    8019cc <lwip_select+0x180>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8019c6:	89 d0                	mov    %edx,%eax
  8019c8:	85 c0                	test   %eax,%eax
  8019ca:	75 ed                	jne    8019b9 <lwip_select+0x16d>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  8019cc:	83 ec 0c             	sub    $0xc,%esp
  8019cf:	ff 35 40 50 81 00    	pushl  0x815040
  8019d5:	e8 03 86 00 00       	call   809fdd <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  8019da:	83 c4 04             	add    $0x4,%esp
  8019dd:	ff 75 d8             	pushl  -0x28(%ebp)
  8019e0:	e8 cd 83 00 00       	call   809db2 <sys_sem_free>
    if (i == 0)  {
  8019e5:	83 c4 10             	add    $0x10,%esp
  8019e8:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8019ec:	75 50                	jne    801a3e <lwip_select+0x1f2>
      /* Timeout */
      if (readset)
  8019ee:	85 ff                	test   %edi,%edi
  8019f0:	74 10                	je     801a02 <lwip_select+0x1b6>
        FD_ZERO(readset);
  8019f2:	83 ec 04             	sub    $0x4,%esp
  8019f5:	6a 04                	push   $0x4
  8019f7:	6a 00                	push   $0x0
  8019f9:	57                   	push   %edi
  8019fa:	e8 ee d1 00 00       	call   80ebed <memset>
  8019ff:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801a02:	85 f6                	test   %esi,%esi
  801a04:	74 10                	je     801a16 <lwip_select+0x1ca>
        FD_ZERO(writeset);
  801a06:	83 ec 04             	sub    $0x4,%esp
  801a09:	6a 04                	push   $0x4
  801a0b:	6a 00                	push   $0x0
  801a0d:	56                   	push   %esi
  801a0e:	e8 da d1 00 00       	call   80ebed <memset>
  801a13:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a16:	85 db                	test   %ebx,%ebx
  801a18:	74 10                	je     801a2a <lwip_select+0x1de>
        FD_ZERO(exceptset);
  801a1a:	83 ec 04             	sub    $0x4,%esp
  801a1d:	6a 04                	push   $0x4
  801a1f:	6a 00                	push   $0x0
  801a21:	53                   	push   %ebx
  801a22:	e8 c6 d1 00 00       	call   80ebed <memset>
  801a27:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801a2a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a31:	00 00 00 
  
      return 0;
  801a34:	b8 00 00 00 00       	mov    $0x0,%eax
  801a39:	e9 53 01 00 00       	jmp    801b91 <lwip_select+0x345>
    }
    
    if (readset)
  801a3e:	85 ff                	test   %edi,%edi
  801a40:	74 07                	je     801a49 <lwip_select+0x1fd>
      lreadset = *readset;
  801a42:	8b 07                	mov    (%edi),%eax
  801a44:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801a47:	eb 13                	jmp    801a5c <lwip_select+0x210>
    else
      FD_ZERO(&lreadset);
  801a49:	83 ec 04             	sub    $0x4,%esp
  801a4c:	6a 04                	push   $0x4
  801a4e:	6a 00                	push   $0x0
  801a50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a53:	50                   	push   %eax
  801a54:	e8 94 d1 00 00       	call   80ebed <memset>
  801a59:	83 c4 10             	add    $0x10,%esp
    if (writeset)
  801a5c:	85 f6                	test   %esi,%esi
  801a5e:	74 07                	je     801a67 <lwip_select+0x21b>
      lwriteset = *writeset;
  801a60:	8b 06                	mov    (%esi),%eax
  801a62:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801a65:	eb 13                	jmp    801a7a <lwip_select+0x22e>
    else
      FD_ZERO(&lwriteset);
  801a67:	83 ec 04             	sub    $0x4,%esp
  801a6a:	6a 04                	push   $0x4
  801a6c:	6a 00                	push   $0x0
  801a6e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a71:	50                   	push   %eax
  801a72:	e8 76 d1 00 00       	call   80ebed <memset>
  801a77:	83 c4 10             	add    $0x10,%esp
    if (exceptset)
  801a7a:	85 db                	test   %ebx,%ebx
  801a7c:	74 07                	je     801a85 <lwip_select+0x239>
      lexceptset = *exceptset;
  801a7e:	8b 03                	mov    (%ebx),%eax
  801a80:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801a83:	eb 13                	jmp    801a98 <lwip_select+0x24c>
    else
      FD_ZERO(&lexceptset);
  801a85:	83 ec 04             	sub    $0x4,%esp
  801a88:	6a 04                	push   $0x4
  801a8a:	6a 00                	push   $0x0
  801a8c:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a8f:	50                   	push   %eax
  801a90:	e8 58 d1 00 00       	call   80ebed <memset>
  801a95:	83 c4 10             	add    $0x10,%esp
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a98:	83 ec 0c             	sub    $0xc,%esp
  801a9b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a9e:	50                   	push   %eax
  801a9f:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801aa2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801aa5:	8b 45 08             	mov    0x8(%ebp),%eax
  801aa8:	e8 93 ed ff ff       	call   800840 <lwip_selscan>
  801aad:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801ab0:	83 c4 10             	add    $0x10,%esp
  801ab3:	eb 11                	jmp    801ac6 <lwip_select+0x27a>
  } else
    sys_sem_signal(selectsem);
  801ab5:	83 ec 0c             	sub    $0xc,%esp
  801ab8:	ff 35 40 50 81 00    	pushl  0x815040
  801abe:	e8 1a 85 00 00       	call   809fdd <sys_sem_signal>
  801ac3:	83 c4 10             	add    $0x10,%esp
  
  if (readset)
  801ac6:	85 ff                	test   %edi,%edi
  801ac8:	74 05                	je     801acf <lwip_select+0x283>
    *readset = lreadset;
  801aca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801acd:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801acf:	85 f6                	test   %esi,%esi
  801ad1:	74 05                	je     801ad8 <lwip_select+0x28c>
    *writeset = lwriteset;
  801ad3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801ad6:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801ad8:	85 db                	test   %ebx,%ebx
  801ada:	74 05                	je     801ae1 <lwip_select+0x295>
    *exceptset = lexceptset;
  801adc:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801adf:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801ae1:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801ae8:	00 00 00 
  
  return nready;
  801aeb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801aee:	e9 9e 00 00 00       	jmp    801b91 <lwip_select+0x345>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801af3:	83 ec 0c             	sub    $0xc,%esp
  801af6:	6a 00                	push   $0x0
  801af8:	e8 34 82 00 00       	call   809d31 <sys_sem_new>
  801afd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801b00:	a1 48 50 81 00       	mov    0x815048,%eax
  801b05:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b08:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b0b:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801b10:	83 c4 04             	add    $0x4,%esp
  801b13:	ff 35 40 50 81 00    	pushl  0x815040
  801b19:	e8 bf 84 00 00       	call   809fdd <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801b1e:	8b 45 18             	mov    0x18(%ebp),%eax
  801b21:	8b 40 04             	mov    0x4(%eax),%eax
  801b24:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801b27:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801b2d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801b32:	89 c8                	mov    %ecx,%eax
  801b34:	f7 ea                	imul   %edx
  801b36:	c1 fa 06             	sar    $0x6,%edx
  801b39:	c1 f9 1f             	sar    $0x1f,%ecx
  801b3c:	29 ca                	sub    %ecx,%edx
  801b3e:	8b 45 18             	mov    0x18(%ebp),%eax
  801b41:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801b47:	83 c4 10             	add    $0x10,%esp
  801b4a:	01 c2                	add    %eax,%edx
        msectimeout = 1;
  801b4c:	b8 01 00 00 00       	mov    $0x1,%eax
  801b51:	0f 44 d0             	cmove  %eax,%edx
  801b54:	e9 28 fe ff ff       	jmp    801981 <lwip_select+0x135>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801b59:	83 ec 0c             	sub    $0xc,%esp
  801b5c:	6a 00                	push   $0x0
  801b5e:	e8 ce 81 00 00       	call   809d31 <sys_sem_new>
  801b63:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801b66:	a1 48 50 81 00       	mov    0x815048,%eax
  801b6b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b6e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b71:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801b76:	83 c4 04             	add    $0x4,%esp
  801b79:	ff 35 40 50 81 00    	pushl  0x815040
  801b7f:	e8 59 84 00 00       	call   809fdd <sys_sem_signal>
  801b84:	83 c4 10             	add    $0x10,%esp
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801b87:	ba 00 00 00 00       	mov    $0x0,%edx
  801b8c:	e9 f0 fd ff ff       	jmp    801981 <lwip_select+0x135>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801b91:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801b94:	5b                   	pop    %ebx
  801b95:	5e                   	pop    %esi
  801b96:	5f                   	pop    %edi
  801b97:	5d                   	pop    %ebp
  801b98:	c3                   	ret    

00801b99 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801b99:	55                   	push   %ebp
  801b9a:	89 e5                	mov    %esp,%ebp
  801b9c:	83 ec 14             	sub    $0x14,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b9f:	ff 75 08             	pushl  0x8(%ebp)
  801ba2:	e8 a5 f5 ff ff       	call   80114c <lwip_close>
}
  801ba7:	c9                   	leave  
  801ba8:	c3                   	ret    

00801ba9 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801ba9:	55                   	push   %ebp
  801baa:	89 e5                	mov    %esp,%ebp
  801bac:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801baf:	6a 00                	push   $0x0
  801bb1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bb4:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bb7:	8b 45 08             	mov    0x8(%ebp),%eax
  801bba:	e8 87 ed ff ff       	call   800946 <lwip_getaddrname>
}
  801bbf:	c9                   	leave  
  801bc0:	c3                   	ret    

00801bc1 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801bc1:	55                   	push   %ebp
  801bc2:	89 e5                	mov    %esp,%ebp
  801bc4:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801bc7:	6a 01                	push   $0x1
  801bc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bcc:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bcf:	8b 45 08             	mov    0x8(%ebp),%eax
  801bd2:	e8 6f ed ff ff       	call   800946 <lwip_getaddrname>
}
  801bd7:	c9                   	leave  
  801bd8:	c3                   	ret    

00801bd9 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801bd9:	55                   	push   %ebp
  801bda:	89 e5                	mov    %esp,%ebp
  801bdc:	57                   	push   %edi
  801bdd:	56                   	push   %esi
  801bde:	53                   	push   %ebx
  801bdf:	83 ec 2c             	sub    $0x2c,%esp
  801be2:	8b 75 0c             	mov    0xc(%ebp),%esi
  801be5:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801be8:	8b 45 08             	mov    0x8(%ebp),%eax
  801beb:	e8 05 ec ff ff       	call   8007f5 <get_socket>
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801bf0:	85 c0                	test   %eax,%eax
  801bf2:	0f 84 7c 01 00 00    	je     801d74 <lwip_getsockopt+0x19b>
  801bf8:	89 c3                	mov    %eax,%ebx
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801bfa:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801bfe:	74 04                	je     801c04 <lwip_getsockopt+0x2b>
  801c00:	85 ff                	test   %edi,%edi
  801c02:	75 1b                	jne    801c1f <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801c04:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801c0b:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801c12:	00 00 00 
    return -1;
  801c15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c1a:	e9 95 01 00 00       	jmp    801db4 <lwip_getsockopt+0x1db>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801c1f:	83 fe 06             	cmp    $0x6,%esi
  801c22:	0f 84 9c 00 00 00    	je     801cc4 <lwip_getsockopt+0xeb>
  801c28:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801c2e:	74 0f                	je     801c3f <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801c30:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801c35:	85 f6                	test   %esi,%esi
  801c37:	0f 85 c4 00 00 00    	jne    801d01 <lwip_getsockopt+0x128>
  801c3d:	eb 6f                	jmp    801cae <lwip_getsockopt+0xd5>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801c3f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801c43:	74 39                	je     801c7e <lwip_getsockopt+0xa5>
  801c45:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801c49:	7f 12                	jg     801c5d <lwip_getsockopt+0x84>
  801c4b:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801c4f:	74 2d                	je     801c7e <lwip_getsockopt+0xa5>
  801c51:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801c55:	0f 85 93 00 00 00    	jne    801cee <lwip_getsockopt+0x115>
  801c5b:	eb 21                	jmp    801c7e <lwip_getsockopt+0xa5>
  801c5d:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801c64:	0f 8c 84 00 00 00    	jl     801cee <lwip_getsockopt+0x115>
  801c6a:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801c71:	7e 0b                	jle    801c7e <lwip_getsockopt+0xa5>
  801c73:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801c7a:	74 10                	je     801c8c <lwip_getsockopt+0xb3>
  801c7c:	eb 70                	jmp    801cee <lwip_getsockopt+0x115>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801c7e:	83 3f 03             	cmpl   $0x3,(%edi)
  801c81:	0f 86 f4 00 00 00    	jbe    801d7b <lwip_getsockopt+0x1a2>
  801c87:	e9 8e 00 00 00       	jmp    801d1a <lwip_getsockopt+0x141>
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801c8c:	83 3f 04             	cmpl   $0x4,(%edi)
  801c8f:	19 c0                	sbb    %eax,%eax
  801c91:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801c94:	8b 13                	mov    (%ebx),%edx
  801c96:	83 3a 20             	cmpl   $0x20,(%edx)
  801c99:	0f 85 e3 00 00 00    	jne    801d82 <lwip_getsockopt+0x1a9>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c9f:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801ca2:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801ca6:	0f 85 e0 00 00 00    	jne    801d8c <lwip_getsockopt+0x1b3>
  801cac:	eb 53                	jmp    801d01 <lwip_getsockopt+0x128>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801cae:	8b 45 10             	mov    0x10(%ebp),%eax
  801cb1:	83 e8 01             	sub    $0x1,%eax
  801cb4:	83 f8 01             	cmp    $0x1,%eax
  801cb7:	77 3c                	ja     801cf5 <lwip_getsockopt+0x11c>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801cb9:	83 3f 03             	cmpl   $0x3,(%edi)
  801cbc:	0f 86 d4 00 00 00    	jbe    801d96 <lwip_getsockopt+0x1bd>
  801cc2:	eb 56                	jmp    801d1a <lwip_getsockopt+0x141>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801cc4:	83 3f 03             	cmpl   $0x3,(%edi)
  801cc7:	0f 86 d3 00 00 00    	jbe    801da0 <lwip_getsockopt+0x1c7>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801ccd:	8b 10                	mov    (%eax),%edx
      return 0;
  801ccf:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801cd4:	83 3a 10             	cmpl   $0x10,(%edx)
  801cd7:	0f 85 d7 00 00 00    	jne    801db4 <lwip_getsockopt+0x1db>
      return 0;

    switch (optname) {
  801cdd:	8b 45 10             	mov    0x10(%ebp),%eax
  801ce0:	83 e8 01             	sub    $0x1,%eax
  801ce3:	83 f8 01             	cmp    $0x1,%eax
  801ce6:	0f 87 be 00 00 00    	ja     801daa <lwip_getsockopt+0x1d1>
  801cec:	eb 0e                	jmp    801cfc <lwip_getsockopt+0x123>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801cee:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cf3:	eb 0c                	jmp    801d01 <lwip_getsockopt+0x128>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801cf5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cfa:	eb 05                	jmp    801d01 <lwip_getsockopt+0x128>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801cfc:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801d01:	84 c0                	test   %al,%al
  801d03:	74 15                	je     801d1a <lwip_getsockopt+0x141>
    sock_set_errno(sock, err);
  801d05:	0f be c0             	movsbl %al,%eax
  801d08:	89 43 10             	mov    %eax,0x10(%ebx)
  801d0b:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d15:	e9 9a 00 00 00       	jmp    801db4 <lwip_getsockopt+0x1db>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801d1a:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801d1d:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801d20:	8b 45 10             	mov    0x10(%ebp),%eax
  801d23:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801d26:	8b 45 14             	mov    0x14(%ebp),%eax
  801d29:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801d2c:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801d2f:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801d33:	83 ec 04             	sub    $0x4,%esp
  801d36:	6a 01                	push   $0x1
  801d38:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801d3b:	50                   	push   %eax
  801d3c:	68 39 0c 80 00       	push   $0x800c39
  801d41:	e8 d4 05 00 00       	call   80231a <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801d46:	83 c4 08             	add    $0x8,%esp
  801d49:	6a 00                	push   $0x0
  801d4b:	8b 03                	mov    (%ebx),%eax
  801d4d:	ff 70 10             	pushl  0x10(%eax)
  801d50:	e8 f6 82 00 00       	call   80a04b <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801d55:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801d59:	0f be d0             	movsbl %al,%edx
  801d5c:	89 53 10             	mov    %edx,0x10(%ebx)
  801d5f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801d65:	83 c4 10             	add    $0x10,%esp
  801d68:	84 c0                	test   %al,%al
  801d6a:	0f 95 c0             	setne  %al
  801d6d:	0f b6 c0             	movzbl %al,%eax
  801d70:	f7 d8                	neg    %eax
  801d72:	eb 40                	jmp    801db4 <lwip_getsockopt+0x1db>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801d74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d79:	eb 39                	jmp    801db4 <lwip_getsockopt+0x1db>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801d7b:	b8 16 00 00 00       	mov    $0x16,%eax
  801d80:	eb 83                	jmp    801d05 <lwip_getsockopt+0x12c>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801d82:	b8 61 00 00 00       	mov    $0x61,%eax
  801d87:	e9 79 ff ff ff       	jmp    801d05 <lwip_getsockopt+0x12c>
  801d8c:	b8 61 00 00 00       	mov    $0x61,%eax
  801d91:	e9 6f ff ff ff       	jmp    801d05 <lwip_getsockopt+0x12c>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801d96:	b8 16 00 00 00       	mov    $0x16,%eax
  801d9b:	e9 65 ff ff ff       	jmp    801d05 <lwip_getsockopt+0x12c>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  801da0:	b8 16 00 00 00       	mov    $0x16,%eax
  801da5:	e9 5b ff ff ff       	jmp    801d05 <lwip_getsockopt+0x12c>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801daa:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801daf:	e9 51 ff ff ff       	jmp    801d05 <lwip_getsockopt+0x12c>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801db4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801db7:	5b                   	pop    %ebx
  801db8:	5e                   	pop    %esi
  801db9:	5f                   	pop    %edi
  801dba:	5d                   	pop    %ebp
  801dbb:	c3                   	ret    

00801dbc <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  801dbc:	55                   	push   %ebp
  801dbd:	89 e5                	mov    %esp,%ebp
  801dbf:	57                   	push   %edi
  801dc0:	56                   	push   %esi
  801dc1:	53                   	push   %ebx
  801dc2:	83 ec 2c             	sub    $0x2c,%esp
  801dc5:	8b 75 0c             	mov    0xc(%ebp),%esi
  801dc8:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801dcb:	8b 45 08             	mov    0x8(%ebp),%eax
  801dce:	e8 22 ea ff ff       	call   8007f5 <get_socket>
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801dd3:	85 c0                	test   %eax,%eax
  801dd5:	0f 84 47 01 00 00    	je     801f22 <lwip_setsockopt+0x166>
  801ddb:	89 c3                	mov    %eax,%ebx
    return -1;

  if (NULL == optval) {
  801ddd:	85 ff                	test   %edi,%edi
  801ddf:	75 1b                	jne    801dfc <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  801de1:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801de8:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801def:	00 00 00 
    return -1;
  801df2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801df7:	e9 63 01 00 00       	jmp    801f5f <lwip_setsockopt+0x1a3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801dfc:	83 fe 06             	cmp    $0x6,%esi
  801dff:	74 7e                	je     801e7f <lwip_setsockopt+0xc3>
  801e01:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801e07:	74 0f                	je     801e18 <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  801e09:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801e0e:	85 f6                	test   %esi,%esi
  801e10:	0f 85 a0 00 00 00    	jne    801eb6 <lwip_setsockopt+0xfa>
  801e16:	eb 50                	jmp    801e68 <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801e18:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801e1c:	74 18                	je     801e36 <lwip_setsockopt+0x7a>
  801e1e:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801e25:	74 1e                	je     801e45 <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801e27:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801e2c:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801e30:	0f 85 80 00 00 00    	jne    801eb6 <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  801e36:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e3a:	0f 86 e9 00 00 00    	jbe    801f29 <lwip_setsockopt+0x16d>
  801e40:	e9 87 00 00 00       	jmp    801ecc <lwip_setsockopt+0x110>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e45:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801e49:	19 c0                	sbb    %eax,%eax
  801e4b:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801e4e:	8b 13                	mov    (%ebx),%edx
  801e50:	83 3a 20             	cmpl   $0x20,(%edx)
  801e53:	0f 85 d7 00 00 00    	jne    801f30 <lwip_setsockopt+0x174>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e59:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801e5c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e60:	0f 85 d1 00 00 00    	jne    801f37 <lwip_setsockopt+0x17b>
  801e66:	eb 4e                	jmp    801eb6 <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801e68:	8b 45 10             	mov    0x10(%ebp),%eax
  801e6b:	83 e8 01             	sub    $0x1,%eax
  801e6e:	83 f8 01             	cmp    $0x1,%eax
  801e71:	77 37                	ja     801eaa <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  801e73:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e77:	0f 86 c4 00 00 00    	jbe    801f41 <lwip_setsockopt+0x185>
  801e7d:	eb 4d                	jmp    801ecc <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  801e7f:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e83:	0f 86 c2 00 00 00    	jbe    801f4b <lwip_setsockopt+0x18f>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801e89:	8b 10                	mov    (%eax),%edx
      return 0;
  801e8b:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801e90:	83 3a 10             	cmpl   $0x10,(%edx)
  801e93:	0f 85 c6 00 00 00    	jne    801f5f <lwip_setsockopt+0x1a3>
      return 0;

    switch (optname) {
  801e99:	8b 45 10             	mov    0x10(%ebp),%eax
  801e9c:	83 e8 01             	sub    $0x1,%eax
  801e9f:	83 f8 01             	cmp    $0x1,%eax
  801ea2:	0f 87 ad 00 00 00    	ja     801f55 <lwip_setsockopt+0x199>
  801ea8:	eb 07                	jmp    801eb1 <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  801eaa:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801eaf:	eb 05                	jmp    801eb6 <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  801eb1:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  801eb6:	85 c0                	test   %eax,%eax
  801eb8:	74 12                	je     801ecc <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  801eba:	89 43 10             	mov    %eax,0x10(%ebx)
  801ebd:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801ec2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ec7:	e9 93 00 00 00       	jmp    801f5f <lwip_setsockopt+0x1a3>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  801ecc:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801ecf:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801ed2:	8b 45 10             	mov    0x10(%ebp),%eax
  801ed5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801ed8:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801edb:	8d 45 18             	lea    0x18(%ebp),%eax
  801ede:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801ee1:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801ee5:	83 ec 04             	sub    $0x4,%esp
  801ee8:	6a 01                	push   $0x1
  801eea:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801eed:	50                   	push   %eax
  801eee:	68 bc 0d 80 00       	push   $0x800dbc
  801ef3:	e8 22 04 00 00       	call   80231a <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801ef8:	83 c4 08             	add    $0x8,%esp
  801efb:	6a 00                	push   $0x0
  801efd:	8b 03                	mov    (%ebx),%eax
  801eff:	ff 70 10             	pushl  0x10(%eax)
  801f02:	e8 44 81 00 00       	call   80a04b <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  801f07:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801f0b:	89 43 10             	mov    %eax,0x10(%ebx)
  801f0e:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801f13:	83 c4 10             	add    $0x10,%esp
  801f16:	85 c0                	test   %eax,%eax
  801f18:	0f 95 c0             	setne  %al
  801f1b:	0f b6 c0             	movzbl %al,%eax
  801f1e:	f7 d8                	neg    %eax
  801f20:	eb 3d                	jmp    801f5f <lwip_setsockopt+0x1a3>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801f22:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f27:	eb 36                	jmp    801f5f <lwip_setsockopt+0x1a3>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801f29:	b8 16 00 00 00       	mov    $0x16,%eax
  801f2e:	eb 8a                	jmp    801eba <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801f30:	b8 61 00 00 00       	mov    $0x61,%eax
  801f35:	eb 83                	jmp    801eba <lwip_setsockopt+0xfe>
  801f37:	b8 61 00 00 00       	mov    $0x61,%eax
  801f3c:	e9 79 ff ff ff       	jmp    801eba <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801f41:	b8 16 00 00 00       	mov    $0x16,%eax
  801f46:	e9 6f ff ff ff       	jmp    801eba <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  801f4b:	b8 16 00 00 00       	mov    $0x16,%eax
  801f50:	e9 65 ff ff ff       	jmp    801eba <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801f55:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f5a:	e9 5b ff ff ff       	jmp    801eba <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801f5f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801f62:	5b                   	pop    %ebx
  801f63:	5e                   	pop    %esi
  801f64:	5f                   	pop    %edi
  801f65:	5d                   	pop    %ebp
  801f66:	c3                   	ret    

00801f67 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801f67:	55                   	push   %ebp
  801f68:	89 e5                	mov    %esp,%ebp
  801f6a:	56                   	push   %esi
  801f6b:	53                   	push   %ebx
  801f6c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f6f:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801f72:	8b 45 08             	mov    0x8(%ebp),%eax
  801f75:	e8 7b e8 ff ff       	call   8007f5 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801f7a:	85 c0                	test   %eax,%eax
  801f7c:	0f 84 af 00 00 00    	je     802031 <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  801f82:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801f88:	74 60                	je     801fea <lwip_ioctl+0x83>
  801f8a:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801f90:	0f 85 83 00 00 00    	jne    802019 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  801f96:	85 f6                	test   %esi,%esi
  801f98:	75 1b                	jne    801fb5 <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  801f9a:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801fa1:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801fa8:	00 00 00 
      return -1;
  801fab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fb0:	e9 81 00 00 00       	jmp    802036 <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801fb5:	8b 10                	mov    (%eax),%edx
  801fb7:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801fbb:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801fbe:	8b 48 04             	mov    0x4(%eax),%ecx
  801fc1:	85 c9                	test   %ecx,%ecx
  801fc3:	74 0d                	je     801fd2 <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  801fc5:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801fc7:	66 03 51 08          	add    0x8(%ecx),%dx
  801fcb:	66 2b 50 08          	sub    0x8(%eax),%dx
  801fcf:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801fd2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fd9:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801fe0:	00 00 00 
    return 0;
  801fe3:	b8 00 00 00 00       	mov    $0x0,%eax
  801fe8:	eb 4c                	jmp    802036 <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801fea:	85 f6                	test   %esi,%esi
  801fec:	74 0d                	je     801ffb <lwip_ioctl+0x94>
  801fee:	83 3e 00             	cmpl   $0x0,(%esi)
  801ff1:	74 08                	je     801ffb <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  801ff3:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  801ff9:	eb 06                	jmp    802001 <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  801ffb:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  802001:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802008:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80200f:	00 00 00 
    return 0;
  802012:	b8 00 00 00 00       	mov    $0x0,%eax
  802017:	eb 1d                	jmp    802036 <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  802019:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  802020:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  802027:	00 00 00 
    return -1;
  80202a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80202f:	eb 05                	jmp    802036 <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  802031:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  802036:	5b                   	pop    %ebx
  802037:	5e                   	pop    %esi
  802038:	5d                   	pop    %ebp
  802039:	c3                   	ret    

0080203a <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  80203a:	55                   	push   %ebp
  80203b:	89 e5                	mov    %esp,%ebp
  80203d:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802040:	e8 fe 40 00 00       	call   806143 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802045:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  80204c:	75 09                	jne    802057 <tcpip_tcp_timer+0x1d>
  80204e:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802055:	74 19                	je     802070 <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802057:	83 ec 04             	sub    $0x4,%esp
  80205a:	6a 00                	push   $0x0
  80205c:	68 3a 20 80 00       	push   $0x80203a
  802061:	68 fa 00 00 00       	push   $0xfa
  802066:	e8 0a 31 00 00       	call   805175 <sys_timeout>
  80206b:	83 c4 10             	add    $0x10,%esp
  80206e:	eb 0a                	jmp    80207a <tcpip_tcp_timer+0x40>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  802070:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  802077:	00 00 00 
  }
}
  80207a:	c9                   	leave  
  80207b:	c3                   	ret    

0080207c <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  80207c:	55                   	push   %ebp
  80207d:	89 e5                	mov    %esp,%ebp
  80207f:	53                   	push   %ebx
  802080:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802083:	6a 00                	push   $0x0
  802085:	68 32 22 80 00       	push   $0x802232
  80208a:	68 e8 03 00 00       	push   $0x3e8
  80208f:	e8 e1 30 00 00       	call   805175 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802094:	83 c4 0c             	add    $0xc,%esp
  802097:	6a 00                	push   $0x0
  802099:	68 0e 22 80 00       	push   $0x80220e
  80209e:	68 88 13 00 00       	push   $0x1388
  8020a3:	e8 cd 30 00 00       	call   805175 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8020a8:	83 c4 0c             	add    $0xc,%esp
  8020ab:	6a 00                	push   $0x0
  8020ad:	68 ea 21 80 00       	push   $0x8021ea
  8020b2:	68 60 ea 00 00       	push   $0xea60
  8020b7:	e8 b9 30 00 00       	call   805175 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8020bc:	83 c4 0c             	add    $0xc,%esp
  8020bf:	6a 00                	push   $0x0
  8020c1:	68 c6 21 80 00       	push   $0x8021c6
  8020c6:	68 f4 01 00 00       	push   $0x1f4
  8020cb:	e8 a5 30 00 00       	call   805175 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8020d0:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8020d5:	83 c4 10             	add    $0x10,%esp
  8020d8:	85 c0                	test   %eax,%eax
  8020da:	74 0e                	je     8020ea <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  8020dc:	83 ec 0c             	sub    $0xc,%esp
  8020df:	ff 35 e4 52 81 00    	pushl  0x8152e4
  8020e5:	ff d0                	call   *%eax
  8020e7:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8020ea:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8020ed:	83 ec 08             	sub    $0x8,%esp
  8020f0:	53                   	push   %ebx
  8020f1:	ff 35 00 40 81 00    	pushl  0x814000
  8020f7:	e8 57 2f 00 00       	call   805053 <sys_mbox_fetch>
    switch (msg->type) {
  8020fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8020ff:	83 c4 10             	add    $0x10,%esp
  802102:	8b 02                	mov    (%edx),%eax
  802104:	83 f8 01             	cmp    $0x1,%eax
  802107:	74 22                	je     80212b <tcpip_thread+0xaf>
  802109:	83 f8 01             	cmp    $0x1,%eax
  80210c:	72 0c                	jb     80211a <tcpip_thread+0x9e>
  80210e:	83 f8 02             	cmp    $0x2,%eax
  802111:	74 53                	je     802166 <tcpip_thread+0xea>
  802113:	83 f8 03             	cmp    $0x3,%eax
  802116:	74 6c                	je     802184 <tcpip_thread+0x108>
  802118:	eb d3                	jmp    8020ed <tcpip_thread+0x71>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80211a:	8b 42 08             	mov    0x8(%edx),%eax
  80211d:	83 ec 0c             	sub    $0xc,%esp
  802120:	8d 50 04             	lea    0x4(%eax),%edx
  802123:	52                   	push   %edx
  802124:	ff 10                	call   *(%eax)
      break;
  802126:	83 c4 10             	add    $0x10,%esp
  802129:	eb c2                	jmp    8020ed <tcpip_thread+0x71>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  80212b:	8b 42 0c             	mov    0xc(%edx),%eax
  80212e:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802132:	74 11                	je     802145 <tcpip_thread+0xc9>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  802134:	83 ec 08             	sub    $0x8,%esp
  802137:	50                   	push   %eax
  802138:	ff 72 08             	pushl  0x8(%edx)
  80213b:	e8 4b 7a 00 00       	call   809b8b <ethernet_input>
  802140:	83 c4 10             	add    $0x10,%esp
  802143:	eb 0f                	jmp    802154 <tcpip_thread+0xd8>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  802145:	83 ec 08             	sub    $0x8,%esp
  802148:	50                   	push   %eax
  802149:	ff 72 08             	pushl  0x8(%edx)
  80214c:	e8 2c 44 00 00       	call   80657d <ip_input>
  802151:	83 c4 10             	add    $0x10,%esp
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802154:	83 ec 08             	sub    $0x8,%esp
  802157:	ff 75 f4             	pushl  -0xc(%ebp)
  80215a:	6a 09                	push   $0x9
  80215c:	e8 56 23 00 00       	call   8044b7 <memp_free>
      break;
  802161:	83 c4 10             	add    $0x10,%esp
  802164:	eb 87                	jmp    8020ed <tcpip_thread+0x71>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802166:	83 ec 0c             	sub    $0xc,%esp
  802169:	ff 72 0c             	pushl  0xc(%edx)
  80216c:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80216f:	83 c4 08             	add    $0x8,%esp
  802172:	ff 75 f4             	pushl  -0xc(%ebp)
  802175:	6a 08                	push   $0x8
  802177:	e8 3b 23 00 00       	call   8044b7 <memp_free>
      break;
  80217c:	83 c4 10             	add    $0x10,%esp
  80217f:	e9 69 ff ff ff       	jmp    8020ed <tcpip_thread+0x71>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802184:	8b 42 08             	mov    0x8(%edx),%eax
  802187:	83 f8 ff             	cmp    $0xffffffff,%eax
  80218a:	74 14                	je     8021a0 <tcpip_thread+0x124>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  80218c:	83 ec 04             	sub    $0x4,%esp
  80218f:	ff 72 10             	pushl  0x10(%edx)
  802192:	ff 72 0c             	pushl  0xc(%edx)
  802195:	50                   	push   %eax
  802196:	e8 da 2f 00 00       	call   805175 <sys_timeout>
  80219b:	83 c4 10             	add    $0x10,%esp
  80219e:	eb 11                	jmp    8021b1 <tcpip_thread+0x135>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8021a0:	83 ec 08             	sub    $0x8,%esp
  8021a3:	ff 72 10             	pushl  0x10(%edx)
  8021a6:	ff 72 0c             	pushl  0xc(%edx)
  8021a9:	e8 76 30 00 00       	call   805224 <sys_untimeout>
  8021ae:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8021b1:	83 ec 08             	sub    $0x8,%esp
  8021b4:	ff 75 f4             	pushl  -0xc(%ebp)
  8021b7:	6a 08                	push   $0x8
  8021b9:	e8 f9 22 00 00       	call   8044b7 <memp_free>
      break;
  8021be:	83 c4 10             	add    $0x10,%esp
  8021c1:	e9 27 ff ff ff       	jmp    8020ed <tcpip_thread+0x71>

008021c6 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8021c6:	55                   	push   %ebp
  8021c7:	89 e5                	mov    %esp,%ebp
  8021c9:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8021cc:	e8 00 1b 00 00       	call   803cd1 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8021d1:	83 ec 04             	sub    $0x4,%esp
  8021d4:	6a 00                	push   $0x0
  8021d6:	68 c6 21 80 00       	push   $0x8021c6
  8021db:	68 f4 01 00 00       	push   $0x1f4
  8021e0:	e8 90 2f 00 00       	call   805175 <sys_timeout>
}
  8021e5:	83 c4 10             	add    $0x10,%esp
  8021e8:	c9                   	leave  
  8021e9:	c3                   	ret    

008021ea <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8021ea:	55                   	push   %ebp
  8021eb:	89 e5                	mov    %esp,%ebp
  8021ed:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8021f0:	e8 18 19 00 00       	call   803b0d <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8021f5:	83 ec 04             	sub    $0x4,%esp
  8021f8:	6a 00                	push   $0x0
  8021fa:	68 ea 21 80 00       	push   $0x8021ea
  8021ff:	68 60 ea 00 00       	push   $0xea60
  802204:	e8 6c 2f 00 00       	call   805175 <sys_timeout>
}
  802209:	83 c4 10             	add    $0x10,%esp
  80220c:	c9                   	leave  
  80220d:	c3                   	ret    

0080220e <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  80220e:	55                   	push   %ebp
  80220f:	89 e5                	mov    %esp,%ebp
  802211:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  802214:	e8 31 72 00 00       	call   80944a <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802219:	83 ec 04             	sub    $0x4,%esp
  80221c:	6a 00                	push   $0x0
  80221e:	68 0e 22 80 00       	push   $0x80220e
  802223:	68 88 13 00 00       	push   $0x1388
  802228:	e8 48 2f 00 00       	call   805175 <sys_timeout>
}
  80222d:	83 c4 10             	add    $0x10,%esp
  802230:	c9                   	leave  
  802231:	c3                   	ret    

00802232 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  802232:	55                   	push   %ebp
  802233:	89 e5                	mov    %esp,%ebp
  802235:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  802238:	e8 09 4a 00 00       	call   806c46 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80223d:	83 ec 04             	sub    $0x4,%esp
  802240:	6a 00                	push   $0x0
  802242:	68 32 22 80 00       	push   $0x802232
  802247:	68 e8 03 00 00       	push   $0x3e8
  80224c:	e8 24 2f 00 00       	call   805175 <sys_timeout>
}
  802251:	83 c4 10             	add    $0x10,%esp
  802254:	c9                   	leave  
  802255:	c3                   	ret    

00802256 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802256:	55                   	push   %ebp
  802257:	89 e5                	mov    %esp,%ebp
  802259:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  80225c:	ff 75 08             	pushl  0x8(%ebp)
  80225f:	e8 c6 25 00 00       	call   80482a <pbuf_free>
}
  802264:	83 c4 10             	add    $0x10,%esp
  802267:	c9                   	leave  
  802268:	c3                   	ret    

00802269 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802269:	55                   	push   %ebp
  80226a:	89 e5                	mov    %esp,%ebp
  80226c:	83 ec 08             	sub    $0x8,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80226f:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  802276:	75 33                	jne    8022ab <tcp_timer_needed+0x42>
  802278:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  80227f:	75 09                	jne    80228a <tcp_timer_needed+0x21>
  802281:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802288:	74 21                	je     8022ab <tcp_timer_needed+0x42>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80228a:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  802291:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802294:	83 ec 04             	sub    $0x4,%esp
  802297:	6a 00                	push   $0x0
  802299:	68 3a 20 80 00       	push   $0x80203a
  80229e:	68 fa 00 00 00       	push   $0xfa
  8022a3:	e8 cd 2e 00 00       	call   805175 <sys_timeout>
  8022a8:	83 c4 10             	add    $0x10,%esp
  }
}
  8022ab:	c9                   	leave  
  8022ac:	c3                   	ret    

008022ad <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8022ad:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022b4:	74 54                	je     80230a <tcpip_input+0x5d>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8022b6:	55                   	push   %ebp
  8022b7:	89 e5                	mov    %esp,%ebp
  8022b9:	53                   	push   %ebx
  8022ba:	83 ec 10             	sub    $0x10,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8022bd:	6a 09                	push   $0x9
  8022bf:	e8 9d 21 00 00       	call   804461 <memp_malloc>
  8022c4:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8022c6:	83 c4 10             	add    $0x10,%esp
  8022c9:	85 c0                	test   %eax,%eax
  8022cb:	74 43                	je     802310 <tcpip_input+0x63>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  8022cd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8022d3:	8b 45 08             	mov    0x8(%ebp),%eax
  8022d6:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8022d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022dc:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022df:	83 ec 08             	sub    $0x8,%esp
  8022e2:	53                   	push   %ebx
  8022e3:	ff 35 00 40 81 00    	pushl  0x814000
  8022e9:	e8 6b 7e 00 00       	call   80a159 <sys_mbox_trypost>
  8022ee:	83 c4 10             	add    $0x10,%esp
  8022f1:	84 c0                	test   %al,%al
  8022f3:	74 20                	je     802315 <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022f5:	83 ec 08             	sub    $0x8,%esp
  8022f8:	53                   	push   %ebx
  8022f9:	6a 09                	push   $0x9
  8022fb:	e8 b7 21 00 00       	call   8044b7 <memp_free>
      return ERR_MEM;
  802300:	83 c4 10             	add    $0x10,%esp
  802303:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802308:	eb 0b                	jmp    802315 <tcpip_input+0x68>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  80230a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80230f:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  802310:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  802315:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802318:	c9                   	leave  
  802319:	c3                   	ret    

0080231a <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  80231a:	55                   	push   %ebp
  80231b:	89 e5                	mov    %esp,%ebp
  80231d:	56                   	push   %esi
  80231e:	53                   	push   %ebx
  80231f:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  802322:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802329:	74 6f                	je     80239a <tcpip_callback_with_block+0x80>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80232b:	83 ec 0c             	sub    $0xc,%esp
  80232e:	6a 08                	push   $0x8
  802330:	e8 2c 21 00 00       	call   804461 <memp_malloc>
  802335:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802337:	83 c4 10             	add    $0x10,%esp
  80233a:	85 c0                	test   %eax,%eax
  80233c:	74 63                	je     8023a1 <tcpip_callback_with_block+0x87>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  80233e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802344:	8b 45 08             	mov    0x8(%ebp),%eax
  802347:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  80234a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80234d:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802350:	89 f0                	mov    %esi,%eax
  802352:	84 c0                	test   %al,%al
  802354:	74 19                	je     80236f <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802356:	83 ec 08             	sub    $0x8,%esp
  802359:	53                   	push   %ebx
  80235a:	ff 35 00 40 81 00    	pushl  0x814000
  802360:	e8 b7 7e 00 00       	call   80a21c <sys_mbox_post>
  802365:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802368:	b8 00 00 00 00       	mov    $0x0,%eax
  80236d:	eb 37                	jmp    8023a6 <tcpip_callback_with_block+0x8c>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80236f:	83 ec 08             	sub    $0x8,%esp
  802372:	53                   	push   %ebx
  802373:	ff 35 00 40 81 00    	pushl  0x814000
  802379:	e8 db 7d 00 00       	call   80a159 <sys_mbox_trypost>
  80237e:	83 c4 10             	add    $0x10,%esp
  802381:	84 c0                	test   %al,%al
  802383:	74 21                	je     8023a6 <tcpip_callback_with_block+0x8c>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802385:	83 ec 08             	sub    $0x8,%esp
  802388:	53                   	push   %ebx
  802389:	6a 08                	push   $0x8
  80238b:	e8 27 21 00 00       	call   8044b7 <memp_free>
        return ERR_MEM;
  802390:	83 c4 10             	add    $0x10,%esp
  802393:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802398:	eb 0c                	jmp    8023a6 <tcpip_callback_with_block+0x8c>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  80239a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80239f:	eb 05                	jmp    8023a6 <tcpip_callback_with_block+0x8c>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8023a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8023a6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8023a9:	5b                   	pop    %ebx
  8023aa:	5e                   	pop    %esi
  8023ab:	5d                   	pop    %ebp
  8023ac:	c3                   	ret    

008023ad <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8023ad:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8023b4:	74 45                	je     8023fb <tcpip_timeout+0x4e>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8023b6:	55                   	push   %ebp
  8023b7:	89 e5                	mov    %esp,%ebp
  8023b9:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8023bc:	6a 08                	push   $0x8
  8023be:	e8 9e 20 00 00       	call   804461 <memp_malloc>
    if (msg == NULL) {
  8023c3:	83 c4 10             	add    $0x10,%esp
  8023c6:	85 c0                	test   %eax,%eax
  8023c8:	74 37                	je     802401 <tcpip_timeout+0x54>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8023ca:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8023d0:	8b 55 08             	mov    0x8(%ebp),%edx
  8023d3:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8023d6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8023d9:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8023dc:	8b 55 10             	mov    0x10(%ebp),%edx
  8023df:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8023e2:	83 ec 08             	sub    $0x8,%esp
  8023e5:	50                   	push   %eax
  8023e6:	ff 35 00 40 81 00    	pushl  0x814000
  8023ec:	e8 2b 7e 00 00       	call   80a21c <sys_mbox_post>
    return ERR_OK;
  8023f1:	83 c4 10             	add    $0x10,%esp
  8023f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8023f9:	eb 0b                	jmp    802406 <tcpip_timeout+0x59>
  }
  return ERR_VAL;
  8023fb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802400:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  802401:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802406:	c9                   	leave  
  802407:	c3                   	ret    

00802408 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  802408:	55                   	push   %ebp
  802409:	89 e5                	mov    %esp,%ebp
  80240b:	53                   	push   %ebx
  80240c:	83 ec 24             	sub    $0x24,%esp
  80240f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  802412:	a1 00 40 81 00       	mov    0x814000,%eax
  802417:	83 f8 ff             	cmp    $0xffffffff,%eax
  80241a:	74 31                	je     80244d <tcpip_apimsg+0x45>
    msg.type = TCPIP_MSG_API;
  80241c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802423:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802426:	83 ec 08             	sub    $0x8,%esp
  802429:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80242c:	52                   	push   %edx
  80242d:	50                   	push   %eax
  80242e:	e8 e9 7d 00 00       	call   80a21c <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802433:	83 c4 08             	add    $0x8,%esp
  802436:	6a 00                	push   $0x0
  802438:	8b 43 04             	mov    0x4(%ebx),%eax
  80243b:	ff 70 10             	pushl  0x10(%eax)
  80243e:	e8 08 7c 00 00       	call   80a04b <sys_arch_sem_wait>
    return ERR_OK;
  802443:	83 c4 10             	add    $0x10,%esp
  802446:	b8 00 00 00 00       	mov    $0x0,%eax
  80244b:	eb 05                	jmp    802452 <tcpip_apimsg+0x4a>
  }
  return ERR_VAL;
  80244d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802452:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802455:	c9                   	leave  
  802456:	c3                   	ret    

00802457 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802457:	55                   	push   %ebp
  802458:	89 e5                	mov    %esp,%ebp
  80245a:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  80245d:	e8 6f 03 00 00       	call   8027d1 <lwip_init>

  tcpip_init_done = initfunc;
  802462:	8b 45 08             	mov    0x8(%ebp),%eax
  802465:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  80246a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80246d:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  802472:	83 ec 0c             	sub    $0xc,%esp
  802475:	6a 00                	push   $0x0
  802477:	e8 5e 7a 00 00       	call   809eda <sys_mbox_new>
  80247c:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  802481:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802488:	6a 00                	push   $0x0
  80248a:	6a 00                	push   $0x0
  80248c:	68 7c 20 80 00       	push   $0x80207c
  802491:	68 7c 10 81 00       	push   $0x81107c
  802496:	e8 b2 7e 00 00       	call   80a34d <sys_thread_new>
}
  80249b:	83 c4 20             	add    $0x20,%esp
  80249e:	c9                   	leave  
  80249f:	c3                   	ret    

008024a0 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8024a0:	55                   	push   %ebp
  8024a1:	89 e5                	mov    %esp,%ebp
  8024a3:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8024a6:	6a 00                	push   $0x0
  8024a8:	ff 75 08             	pushl  0x8(%ebp)
  8024ab:	68 56 22 80 00       	push   $0x802256
  8024b0:	e8 65 fe ff ff       	call   80231a <tcpip_callback_with_block>
}
  8024b5:	c9                   	leave  
  8024b6:	c3                   	ret    

008024b7 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8024b7:	55                   	push   %ebp
  8024b8:	89 e5                	mov    %esp,%ebp
  8024ba:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8024bd:	6a 00                	push   $0x0
  8024bf:	ff 75 08             	pushl  0x8(%ebp)
  8024c2:	68 88 3f 80 00       	push   $0x803f88
  8024c7:	e8 4e fe ff ff       	call   80231a <tcpip_callback_with_block>
}
  8024cc:	c9                   	leave  
  8024cd:	c3                   	ret    

008024ce <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8024ce:	55                   	push   %ebp
  8024cf:	89 e5                	mov    %esp,%ebp
  8024d1:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8024d4:	6a 06                	push   $0x6
  8024d6:	e8 86 1f 00 00       	call   804461 <memp_malloc>
  if (buf != NULL) {
  8024db:	83 c4 10             	add    $0x10,%esp
  8024de:	85 c0                	test   %eax,%eax
  8024e0:	74 14                	je     8024f6 <netbuf_new+0x28>
    buf->p = NULL;
  8024e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8024e8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8024ef:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8024f6:	c9                   	leave  
  8024f7:	c3                   	ret    

008024f8 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8024f8:	55                   	push   %ebp
  8024f9:	89 e5                	mov    %esp,%ebp
  8024fb:	53                   	push   %ebx
  8024fc:	83 ec 04             	sub    $0x4,%esp
  8024ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802502:	85 db                	test   %ebx,%ebx
  802504:	74 2d                	je     802533 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802506:	8b 03                	mov    (%ebx),%eax
  802508:	85 c0                	test   %eax,%eax
  80250a:	74 19                	je     802525 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  80250c:	83 ec 0c             	sub    $0xc,%esp
  80250f:	50                   	push   %eax
  802510:	e8 15 23 00 00       	call   80482a <pbuf_free>
      buf->p = buf->ptr = NULL;
  802515:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80251c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802522:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802525:	83 ec 08             	sub    $0x8,%esp
  802528:	53                   	push   %ebx
  802529:	6a 06                	push   $0x6
  80252b:	e8 87 1f 00 00       	call   8044b7 <memp_free>
  802530:	83 c4 10             	add    $0x10,%esp
  }
}
  802533:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802536:	c9                   	leave  
  802537:	c3                   	ret    

00802538 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802538:	55                   	push   %ebp
  802539:	89 e5                	mov    %esp,%ebp
  80253b:	56                   	push   %esi
  80253c:	53                   	push   %ebx
  80253d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802540:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802543:	85 db                	test   %ebx,%ebx
  802545:	75 14                	jne    80255b <netbuf_alloc+0x23>
  802547:	83 ec 04             	sub    $0x4,%esp
  80254a:	68 89 10 81 00       	push   $0x811089
  80254f:	6a 63                	push   $0x63
  802551:	68 a3 10 81 00       	push   $0x8110a3
  802556:	e8 ef be 00 00       	call   80e44a <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  80255b:	8b 03                	mov    (%ebx),%eax
  80255d:	85 c0                	test   %eax,%eax
  80255f:	74 0c                	je     80256d <netbuf_alloc+0x35>
    pbuf_free(buf->p);
  802561:	83 ec 0c             	sub    $0xc,%esp
  802564:	50                   	push   %eax
  802565:	e8 c0 22 00 00       	call   80482a <pbuf_free>
  80256a:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  80256d:	83 ec 04             	sub    $0x4,%esp
  802570:	6a 00                	push   $0x0
  802572:	0f b7 c6             	movzwl %si,%eax
  802575:	50                   	push   %eax
  802576:	6a 00                	push   $0x0
  802578:	e8 73 23 00 00       	call   8048f0 <pbuf_alloc>
  80257d:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80257f:	83 c4 10             	add    $0x10,%esp
  802582:	85 c0                	test   %eax,%eax
  802584:	74 22                	je     8025a8 <netbuf_alloc+0x70>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802586:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80258a:	76 14                	jbe    8025a0 <netbuf_alloc+0x68>
  80258c:	83 ec 04             	sub    $0x4,%esp
  80258f:	68 70 11 81 00       	push   $0x811170
  802594:	6a 6e                	push   $0x6e
  802596:	68 a3 10 81 00       	push   $0x8110a3
  80259b:	e8 aa be 00 00       	call   80e44a <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8025a0:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8025a3:	8b 40 04             	mov    0x4(%eax),%eax
  8025a6:	eb 05                	jmp    8025ad <netbuf_alloc+0x75>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8025a8:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8025ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025b0:	5b                   	pop    %ebx
  8025b1:	5e                   	pop    %esi
  8025b2:	5d                   	pop    %ebp
  8025b3:	c3                   	ret    

008025b4 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8025b4:	55                   	push   %ebp
  8025b5:	89 e5                	mov    %esp,%ebp
  8025b7:	53                   	push   %ebx
  8025b8:	83 ec 04             	sub    $0x4,%esp
  8025bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025be:	85 db                	test   %ebx,%ebx
  8025c0:	75 14                	jne    8025d6 <netbuf_free+0x22>
  8025c2:	83 ec 04             	sub    $0x4,%esp
  8025c5:	68 b9 10 81 00       	push   $0x8110b9
  8025ca:	6a 7b                	push   $0x7b
  8025cc:	68 a3 10 81 00       	push   $0x8110a3
  8025d1:	e8 74 be 00 00       	call   80e44a <_panic>
  if (buf->p != NULL) {
  8025d6:	8b 03                	mov    (%ebx),%eax
  8025d8:	85 c0                	test   %eax,%eax
  8025da:	74 0c                	je     8025e8 <netbuf_free+0x34>
    pbuf_free(buf->p);
  8025dc:	83 ec 0c             	sub    $0xc,%esp
  8025df:	50                   	push   %eax
  8025e0:	e8 45 22 00 00       	call   80482a <pbuf_free>
  8025e5:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8025e8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8025ef:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8025f5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025f8:	c9                   	leave  
  8025f9:	c3                   	ret    

008025fa <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8025fa:	55                   	push   %ebp
  8025fb:	89 e5                	mov    %esp,%ebp
  8025fd:	56                   	push   %esi
  8025fe:	53                   	push   %ebx
  8025ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802602:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802605:	85 db                	test   %ebx,%ebx
  802607:	75 17                	jne    802620 <netbuf_ref+0x26>
  802609:	83 ec 04             	sub    $0x4,%esp
  80260c:	68 d2 10 81 00       	push   $0x8110d2
  802611:	68 8e 00 00 00       	push   $0x8e
  802616:	68 a3 10 81 00       	push   $0x8110a3
  80261b:	e8 2a be 00 00       	call   80e44a <_panic>
  if (buf->p != NULL) {
  802620:	8b 03                	mov    (%ebx),%eax
  802622:	85 c0                	test   %eax,%eax
  802624:	74 0c                	je     802632 <netbuf_ref+0x38>
    pbuf_free(buf->p);
  802626:	83 ec 0c             	sub    $0xc,%esp
  802629:	50                   	push   %eax
  80262a:	e8 fb 21 00 00       	call   80482a <pbuf_free>
  80262f:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802632:	83 ec 04             	sub    $0x4,%esp
  802635:	6a 02                	push   $0x2
  802637:	6a 00                	push   $0x0
  802639:	6a 00                	push   $0x0
  80263b:	e8 b0 22 00 00       	call   8048f0 <pbuf_alloc>
  802640:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802642:	83 c4 10             	add    $0x10,%esp
  802645:	85 c0                	test   %eax,%eax
  802647:	75 0e                	jne    802657 <netbuf_ref+0x5d>
    buf->ptr = NULL;
  802649:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  802650:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802655:	eb 1a                	jmp    802671 <netbuf_ref+0x77>
  }
  buf->p->payload = (void*)dataptr;
  802657:	8b 55 0c             	mov    0xc(%ebp),%edx
  80265a:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  80265d:	8b 03                	mov    (%ebx),%eax
  80265f:	66 89 70 08          	mov    %si,0x8(%eax)
  802663:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802667:	8b 03                	mov    (%ebx),%eax
  802669:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80266c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802671:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802674:	5b                   	pop    %ebx
  802675:	5e                   	pop    %esi
  802676:	5d                   	pop    %ebp
  802677:	c3                   	ret    

00802678 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802678:	55                   	push   %ebp
  802679:	89 e5                	mov    %esp,%ebp
  80267b:	56                   	push   %esi
  80267c:	53                   	push   %ebx
  80267d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802680:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802683:	85 db                	test   %ebx,%ebx
  802685:	75 17                	jne    80269e <netbuf_chain+0x26>
  802687:	83 ec 04             	sub    $0x4,%esp
  80268a:	68 ea 10 81 00       	push   $0x8110ea
  80268f:	68 a6 00 00 00       	push   $0xa6
  802694:	68 a3 10 81 00       	push   $0x8110a3
  802699:	e8 ac bd 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80269e:	85 f6                	test   %esi,%esi
  8026a0:	75 17                	jne    8026b9 <netbuf_chain+0x41>
  8026a2:	83 ec 04             	sub    $0x4,%esp
  8026a5:	68 03 11 81 00       	push   $0x811103
  8026aa:	68 a7 00 00 00       	push   $0xa7
  8026af:	68 a3 10 81 00       	push   $0x8110a3
  8026b4:	e8 91 bd 00 00       	call   80e44a <_panic>
  pbuf_chain(head->p, tail->p);
  8026b9:	83 ec 08             	sub    $0x8,%esp
  8026bc:	ff 36                	pushl  (%esi)
  8026be:	ff 33                	pushl  (%ebx)
  8026c0:	e8 59 26 00 00       	call   804d1e <pbuf_chain>
  head->ptr = head->p;
  8026c5:	8b 03                	mov    (%ebx),%eax
  8026c7:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8026ca:	83 c4 08             	add    $0x8,%esp
  8026cd:	56                   	push   %esi
  8026ce:	6a 06                	push   $0x6
  8026d0:	e8 e2 1d 00 00       	call   8044b7 <memp_free>
}
  8026d5:	83 c4 10             	add    $0x10,%esp
  8026d8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026db:	5b                   	pop    %ebx
  8026dc:	5e                   	pop    %esi
  8026dd:	5d                   	pop    %ebp
  8026de:	c3                   	ret    

008026df <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8026df:	55                   	push   %ebp
  8026e0:	89 e5                	mov    %esp,%ebp
  8026e2:	53                   	push   %ebx
  8026e3:	83 ec 04             	sub    $0x4,%esp
  8026e6:	8b 45 08             	mov    0x8(%ebp),%eax
  8026e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8026ec:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8026ef:	85 c0                	test   %eax,%eax
  8026f1:	75 17                	jne    80270a <netbuf_data+0x2b>
  8026f3:	83 ec 04             	sub    $0x4,%esp
  8026f6:	68 1e 11 81 00       	push   $0x81111e
  8026fb:	68 b9 00 00 00       	push   $0xb9
  802700:	68 a3 10 81 00       	push   $0x8110a3
  802705:	e8 40 bd 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80270a:	85 c9                	test   %ecx,%ecx
  80270c:	75 17                	jne    802725 <netbuf_data+0x46>
  80270e:	83 ec 04             	sub    $0x4,%esp
  802711:	68 37 11 81 00       	push   $0x811137
  802716:	68 ba 00 00 00       	push   $0xba
  80271b:	68 a3 10 81 00       	push   $0x8110a3
  802720:	e8 25 bd 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802725:	85 d2                	test   %edx,%edx
  802727:	75 17                	jne    802740 <netbuf_data+0x61>
  802729:	83 ec 04             	sub    $0x4,%esp
  80272c:	68 54 11 81 00       	push   $0x811154
  802731:	68 bb 00 00 00       	push   $0xbb
  802736:	68 a3 10 81 00       	push   $0x8110a3
  80273b:	e8 0a bd 00 00       	call   80e44a <_panic>

  if (buf->ptr == NULL) {
  802740:	8b 58 04             	mov    0x4(%eax),%ebx
  802743:	85 db                	test   %ebx,%ebx
  802745:	74 16                	je     80275d <netbuf_data+0x7e>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802747:	8b 5b 04             	mov    0x4(%ebx),%ebx
  80274a:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  80274c:	8b 40 04             	mov    0x4(%eax),%eax
  80274f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802753:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802756:	b8 00 00 00 00       	mov    $0x0,%eax
  80275b:	eb 05                	jmp    802762 <netbuf_data+0x83>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  80275d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802762:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802765:	c9                   	leave  
  802766:	c3                   	ret    

00802767 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802767:	55                   	push   %ebp
  802768:	89 e5                	mov    %esp,%ebp
  80276a:	83 ec 08             	sub    $0x8,%esp
  80276d:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802770:	85 c0                	test   %eax,%eax
  802772:	75 17                	jne    80278b <netbuf_next+0x24>
  802774:	83 ec 04             	sub    $0x4,%esp
  802777:	68 b9 10 81 00       	push   $0x8110b9
  80277c:	68 d2 00 00 00       	push   $0xd2
  802781:	68 a3 10 81 00       	push   $0x8110a3
  802786:	e8 bf bc 00 00       	call   80e44a <_panic>
  if (buf->ptr->next == NULL) {
  80278b:	8b 50 04             	mov    0x4(%eax),%edx
  80278e:	8b 12                	mov    (%edx),%edx
  802790:	85 d2                	test   %edx,%edx
  802792:	74 0b                	je     80279f <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802794:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  802797:	83 3a 00             	cmpl   $0x0,(%edx)
  80279a:	0f 94 c0             	sete   %al
  80279d:	eb 05                	jmp    8027a4 <netbuf_next+0x3d>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  80279f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  8027a4:	c9                   	leave  
  8027a5:	c3                   	ret    

008027a6 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8027a6:	55                   	push   %ebp
  8027a7:	89 e5                	mov    %esp,%ebp
  8027a9:	83 ec 08             	sub    $0x8,%esp
  8027ac:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8027af:	85 c0                	test   %eax,%eax
  8027b1:	75 17                	jne    8027ca <netbuf_first+0x24>
  8027b3:	83 ec 04             	sub    $0x4,%esp
  8027b6:	68 b9 10 81 00       	push   $0x8110b9
  8027bb:	68 e7 00 00 00       	push   $0xe7
  8027c0:	68 a3 10 81 00       	push   $0x8110a3
  8027c5:	e8 80 bc 00 00       	call   80e44a <_panic>
  buf->ptr = buf->p;
  8027ca:	8b 10                	mov    (%eax),%edx
  8027cc:	89 50 04             	mov    %edx,0x4(%eax)
}
  8027cf:	c9                   	leave  
  8027d0:	c3                   	ret    

008027d1 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8027d1:	55                   	push   %ebp
  8027d2:	89 e5                	mov    %esp,%ebp
  8027d4:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8027d7:	e8 c0 74 00 00       	call   809c9c <sys_init>
  mem_init();
  8027dc:	e8 41 17 00 00       	call   803f22 <mem_init>
  memp_init();
  8027e1:	e8 24 1c 00 00       	call   80440a <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8027e6:	e8 d4 e6 ff ff       	call   800ebf <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8027eb:	c9                   	leave  
  8027ec:	c3                   	ret    

008027ed <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  8027ed:	55                   	push   %ebp
  8027ee:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  8027f0:	38 10                	cmp    %dl,(%eax)
  8027f2:	74 06                	je     8027fa <dhcp_set_state+0xd>
    dhcp->state = new_state;
  8027f4:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8027f6:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8027fa:	5d                   	pop    %ebp
  8027fb:	c3                   	ret    

008027fc <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8027fc:	55                   	push   %ebp
  8027fd:	89 e5                	mov    %esp,%ebp
  8027ff:	57                   	push   %edi
  802800:	56                   	push   %esi
  802801:	53                   	push   %ebx
  802802:	83 ec 08             	sub    $0x8,%esp
  802805:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802808:	8b 70 14             	mov    0x14(%eax),%esi
  80280b:	85 f6                	test   %esi,%esi
  80280d:	0f 84 d5 00 00 00    	je     8028e8 <dhcp_get_option_ptr+0xec>
  802813:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802817:	b9 00 00 00 00       	mov    $0x0,%ecx
  80281c:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802820:	b8 00 00 00 00       	mov    $0x0,%eax
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802825:	66 85 ff             	test   %di,%di
  802828:	0f 84 d2 00 00 00    	je     802900 <dhcp_get_option_ptr+0x104>
  80282e:	eb 2d                	jmp    80285d <dhcp_get_option_ptr+0x61>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802830:	80 fb 34             	cmp    $0x34,%bl
  802833:	75 12                	jne    802847 <dhcp_get_option_ptr+0x4b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802835:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802838:	83 c1 03             	add    $0x3,%ecx
  80283b:	0f b7 c0             	movzwl %ax,%eax
  80283e:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802842:	88 45 f0             	mov    %al,-0x10(%ebp)
  802845:	eb 16                	jmp    80285d <dhcp_get_option_ptr+0x61>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802847:	38 d3                	cmp    %dl,%bl
  802849:	0f 84 b1 00 00 00    	je     802900 <dhcp_get_option_ptr+0x104>
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80284f:	8d 41 01             	lea    0x1(%ecx),%eax
  802852:	0f b7 c0             	movzwl %ax,%eax
  802855:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802859:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80285d:	66 39 f9             	cmp    %di,%cx
  802860:	73 0d                	jae    80286f <dhcp_get_option_ptr+0x73>
  802862:	0f b7 c1             	movzwl %cx,%eax
  802865:	01 f0                	add    %esi,%eax
  802867:	0f b6 18             	movzbl (%eax),%ebx
  80286a:	80 fb ff             	cmp    $0xff,%bl
  80286d:	75 c1                	jne    802830 <dhcp_get_option_ptr+0x34>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80286f:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  802873:	84 c0                	test   %al,%al
  802875:	74 78                	je     8028ef <dhcp_get_option_ptr+0xf3>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802877:	3c 01                	cmp    $0x1,%al
  802879:	75 10                	jne    80288b <dhcp_get_option_ptr+0x8f>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80287b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80287e:	8b 58 10             	mov    0x10(%eax),%ebx
  802881:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  802884:	be 80 00 00 00       	mov    $0x80,%esi
  802889:	eb 24                	jmp    8028af <dhcp_get_option_ptr+0xb3>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80288b:	80 7d f0 02          	cmpb   $0x2,-0x10(%ebp)
  80288f:	75 10                	jne    8028a1 <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802891:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802894:	8b 58 10             	mov    0x10(%eax),%ebx
  802897:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  80289a:	be 40 00 00 00       	mov    $0x40,%esi
  80289f:	eb 0e                	jmp    8028af <dhcp_get_option_ptr+0xb3>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8028a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8028a4:	8b 58 10             	mov    0x10(%eax),%ebx
  8028a7:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8028aa:	be c0 00 00 00       	mov    $0xc0,%esi
      }
      offset = 0;
  8028af:	b9 00 00 00 00       	mov    $0x0,%ecx
  8028b4:	89 d7                	mov    %edx,%edi

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028b6:	eb 14                	jmp    8028cc <dhcp_get_option_ptr+0xd0>
        if (options[offset] == option_type) {
  8028b8:	89 f8                	mov    %edi,%eax
  8028ba:	38 d0                	cmp    %dl,%al
  8028bc:	74 3f                	je     8028fd <dhcp_get_option_ptr+0x101>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
          offset += 1 + options[offset];
  8028be:	8d 41 01             	lea    0x1(%ecx),%eax
  8028c1:	0f b7 c0             	movzwl %ax,%eax
  8028c4:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  8028c8:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028cc:	66 39 f1             	cmp    %si,%cx
  8028cf:	73 25                	jae    8028f6 <dhcp_get_option_ptr+0xfa>
  8028d1:	0f b7 c1             	movzwl %cx,%eax
  8028d4:	01 d8                	add    %ebx,%eax
  8028d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8028d9:	0f b6 10             	movzbl (%eax),%edx
  8028dc:	80 fa ff             	cmp    $0xff,%dl
  8028df:	75 d7                	jne    8028b8 <dhcp_get_option_ptr+0xbc>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  8028e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8028e6:	eb 18                	jmp    802900 <dhcp_get_option_ptr+0x104>
  8028e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8028ed:	eb 11                	jmp    802900 <dhcp_get_option_ptr+0x104>
  8028ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8028f4:	eb 0a                	jmp    802900 <dhcp_get_option_ptr+0x104>
  8028f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8028fb:	eb 03                	jmp    802900 <dhcp_get_option_ptr+0x104>
  8028fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  802900:	83 c4 08             	add    $0x8,%esp
  802903:	5b                   	pop    %ebx
  802904:	5e                   	pop    %esi
  802905:	5f                   	pop    %edi
  802906:	5d                   	pop    %ebp
  802907:	c3                   	ret    

00802908 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802908:	55                   	push   %ebp
  802909:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80290b:	0f b6 10             	movzbl (%eax),%edx
  80290e:	89 d1                	mov    %edx,%ecx
  802910:	c1 e1 18             	shl    $0x18,%ecx
  802913:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802917:	c1 e2 10             	shl    $0x10,%edx
  80291a:	09 ca                	or     %ecx,%edx
  80291c:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  802920:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  802922:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802926:	c1 e0 08             	shl    $0x8,%eax
  802929:	09 d0                	or     %edx,%eax
}
  80292b:	5d                   	pop    %ebp
  80292c:	c3                   	ret    

0080292d <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80292d:	55                   	push   %ebp
  80292e:	89 e5                	mov    %esp,%ebp
  802930:	56                   	push   %esi
  802931:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802932:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802936:	66 83 f9 43          	cmp    $0x43,%cx
  80293a:	76 17                	jbe    802953 <dhcp_option_byte+0x26>
  80293c:	83 ec 04             	sub    $0x4,%esp
  80293f:	68 94 11 81 00       	push   $0x811194
  802944:	68 65 04 00 00       	push   $0x465
  802949:	68 e2 14 81 00       	push   $0x8114e2
  80294e:	e8 f7 ba 00 00       	call   80e44a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802953:	8b 58 20             	mov    0x20(%eax),%ebx
  802956:	8d 71 01             	lea    0x1(%ecx),%esi
  802959:	66 89 70 24          	mov    %si,0x24(%eax)
  80295d:	0f b7 c9             	movzwl %cx,%ecx
  802960:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802967:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80296a:	5b                   	pop    %ebx
  80296b:	5e                   	pop    %esi
  80296c:	5d                   	pop    %ebp
  80296d:	c3                   	ret    

0080296e <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80296e:	55                   	push   %ebp
  80296f:	89 e5                	mov    %esp,%ebp
  802971:	57                   	push   %edi
  802972:	56                   	push   %esi
  802973:	53                   	push   %ebx
  802974:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802977:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  80297b:	0f b7 fb             	movzwl %bx,%edi
  80297e:	0f b6 f1             	movzbl %cl,%esi
  802981:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802985:	83 fe 44             	cmp    $0x44,%esi
  802988:	76 17                	jbe    8029a1 <dhcp_option+0x33>
  80298a:	83 ec 04             	sub    $0x4,%esp
  80298d:	68 d0 11 81 00       	push   $0x8111d0
  802992:	68 5a 04 00 00       	push   $0x45a
  802997:	68 e2 14 81 00       	push   $0x8114e2
  80299c:	e8 a9 ba 00 00       	call   80e44a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8029a1:	8b 70 20             	mov    0x20(%eax),%esi
  8029a4:	8d 7b 01             	lea    0x1(%ebx),%edi
  8029a7:	66 89 78 24          	mov    %di,0x24(%eax)
  8029ab:	0f b7 db             	movzwl %bx,%ebx
  8029ae:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8029b5:	8b 58 20             	mov    0x20(%eax),%ebx
  8029b8:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029bc:	8d 72 01             	lea    0x1(%edx),%esi
  8029bf:	66 89 70 24          	mov    %si,0x24(%eax)
  8029c3:	0f b7 d2             	movzwl %dx,%edx
  8029c6:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8029cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8029d0:	5b                   	pop    %ebx
  8029d1:	5e                   	pop    %esi
  8029d2:	5f                   	pop    %edi
  8029d3:	5d                   	pop    %ebp
  8029d4:	c3                   	ret    

008029d5 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  8029d5:	55                   	push   %ebp
  8029d6:	89 e5                	mov    %esp,%ebp
  8029d8:	56                   	push   %esi
  8029d9:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  8029da:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029de:	0f b7 d9             	movzwl %cx,%ebx
  8029e1:	83 c3 02             	add    $0x2,%ebx
  8029e4:	83 fb 44             	cmp    $0x44,%ebx
  8029e7:	76 17                	jbe    802a00 <dhcp_option_short+0x2b>
  8029e9:	83 ec 04             	sub    $0x4,%esp
  8029ec:	68 18 12 81 00       	push   $0x811218
  8029f1:	68 6c 04 00 00       	push   $0x46c
  8029f6:	68 e2 14 81 00       	push   $0x8114e2
  8029fb:	e8 4a ba 00 00       	call   80e44a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802a00:	8d 71 01             	lea    0x1(%ecx),%esi
  802a03:	66 89 70 24          	mov    %si,0x24(%eax)
  802a07:	0f b7 c9             	movzwl %cx,%ecx
  802a0a:	89 d3                	mov    %edx,%ebx
  802a0c:	66 c1 eb 08          	shr    $0x8,%bx
  802a10:	8b 70 20             	mov    0x20(%eax),%esi
  802a13:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802a1a:	8b 58 20             	mov    0x20(%eax),%ebx
  802a1d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a21:	8d 71 01             	lea    0x1(%ecx),%esi
  802a24:	66 89 70 24          	mov    %si,0x24(%eax)
  802a28:	0f b7 c9             	movzwl %cx,%ecx
  802a2b:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a32:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a35:	5b                   	pop    %ebx
  802a36:	5e                   	pop    %esi
  802a37:	5d                   	pop    %ebp
  802a38:	c3                   	ret    

00802a39 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802a39:	55                   	push   %ebp
  802a3a:	89 e5                	mov    %esp,%ebp
  802a3c:	53                   	push   %ebx
  802a3d:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a40:	85 c0                	test   %eax,%eax
  802a42:	75 17                	jne    802a5b <dhcp_option_trailer+0x22>
  802a44:	83 ec 04             	sub    $0x4,%esp
  802a47:	68 5c 12 81 00       	push   $0x81125c
  802a4c:	68 80 05 00 00       	push   $0x580
  802a51:	68 e2 14 81 00       	push   $0x8114e2
  802a56:	e8 ef b9 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a5b:	8b 48 20             	mov    0x20(%eax),%ecx
  802a5e:	85 c9                	test   %ecx,%ecx
  802a60:	75 17                	jne    802a79 <dhcp_option_trailer+0x40>
  802a62:	83 ec 04             	sub    $0x4,%esp
  802a65:	68 80 12 81 00       	push   $0x811280
  802a6a:	68 81 05 00 00       	push   $0x581
  802a6f:	68 e2 14 81 00       	push   $0x8114e2
  802a74:	e8 d1 b9 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a79:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a7d:	66 83 fa 43          	cmp    $0x43,%dx
  802a81:	76 17                	jbe    802a9a <dhcp_option_trailer+0x61>
  802a83:	83 ec 04             	sub    $0x4,%esp
  802a86:	68 ac 12 81 00       	push   $0x8112ac
  802a8b:	68 82 05 00 00       	push   $0x582
  802a90:	68 e2 14 81 00       	push   $0x8114e2
  802a95:	e8 b0 b9 00 00       	call   80e44a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802a9a:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a9d:	66 89 58 24          	mov    %bx,0x24(%eax)
  802aa1:	0f b7 d2             	movzwl %dx,%edx
  802aa4:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802aab:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802aac:	eb 2c                	jmp    802ada <dhcp_option_trailer+0xa1>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802aae:	83 ec 04             	sub    $0x4,%esp
  802ab1:	68 ac 12 81 00       	push   $0x8112ac
  802ab6:	68 87 05 00 00       	push   $0x587
  802abb:	68 e2 14 81 00       	push   $0x8114e2
  802ac0:	e8 85 b9 00 00       	call   80e44a <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802ac5:	8b 48 20             	mov    0x20(%eax),%ecx
  802ac8:	8d 5a 01             	lea    0x1(%edx),%ebx
  802acb:	66 89 58 24          	mov    %bx,0x24(%eax)
  802acf:	0f b7 d2             	movzwl %dx,%edx
  802ad2:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802ad9:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802ada:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ade:	66 83 fa 43          	cmp    $0x43,%dx
  802ae2:	76 e1                	jbe    802ac5 <dhcp_option_trailer+0x8c>
  802ae4:	f6 c2 03             	test   $0x3,%dl
  802ae7:	75 c5                	jne    802aae <dhcp_option_trailer+0x75>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802ae9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802aec:	c9                   	leave  
  802aed:	c3                   	ret    

00802aee <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802aee:	55                   	push   %ebp
  802aef:	89 e5                	mov    %esp,%ebp
  802af1:	56                   	push   %esi
  802af2:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802af3:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802af7:	0f b7 d9             	movzwl %cx,%ebx
  802afa:	83 c3 04             	add    $0x4,%ebx
  802afd:	83 fb 44             	cmp    $0x44,%ebx
  802b00:	76 17                	jbe    802b19 <dhcp_option_long+0x2b>
  802b02:	83 ec 04             	sub    $0x4,%esp
  802b05:	68 ec 12 81 00       	push   $0x8112ec
  802b0a:	68 74 04 00 00       	push   $0x474
  802b0f:	68 e2 14 81 00       	push   $0x8114e2
  802b14:	e8 31 b9 00 00       	call   80e44a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802b19:	8d 71 01             	lea    0x1(%ecx),%esi
  802b1c:	66 89 70 24          	mov    %si,0x24(%eax)
  802b20:	0f b7 c9             	movzwl %cx,%ecx
  802b23:	89 d3                	mov    %edx,%ebx
  802b25:	c1 eb 18             	shr    $0x18,%ebx
  802b28:	8b 70 20             	mov    0x20(%eax),%esi
  802b2b:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802b32:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b36:	8d 71 01             	lea    0x1(%ecx),%esi
  802b39:	66 89 70 24          	mov    %si,0x24(%eax)
  802b3d:	0f b7 c9             	movzwl %cx,%ecx
  802b40:	89 d3                	mov    %edx,%ebx
  802b42:	c1 eb 10             	shr    $0x10,%ebx
  802b45:	8b 70 20             	mov    0x20(%eax),%esi
  802b48:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802b4f:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b53:	8d 71 01             	lea    0x1(%ecx),%esi
  802b56:	66 89 70 24          	mov    %si,0x24(%eax)
  802b5a:	0f b7 c9             	movzwl %cx,%ecx
  802b5d:	0f b6 de             	movzbl %dh,%ebx
  802b60:	8b 70 20             	mov    0x20(%eax),%esi
  802b63:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802b6a:	8b 58 20             	mov    0x20(%eax),%ebx
  802b6d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b71:	8d 71 01             	lea    0x1(%ecx),%esi
  802b74:	66 89 70 24          	mov    %si,0x24(%eax)
  802b78:	0f b7 c9             	movzwl %cx,%ecx
  802b7b:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b82:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b85:	5b                   	pop    %ebx
  802b86:	5e                   	pop    %esi
  802b87:	5d                   	pop    %ebp
  802b88:	c3                   	ret    

00802b89 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802b89:	55                   	push   %ebp
  802b8a:	89 e5                	mov    %esp,%ebp
  802b8c:	57                   	push   %edi
  802b8d:	56                   	push   %esi
  802b8e:	53                   	push   %ebx
  802b8f:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802b92:	85 c0                	test   %eax,%eax
  802b94:	75 17                	jne    802bad <dhcp_create_request+0x24>
  802b96:	83 ec 04             	sub    $0x4,%esp
  802b99:	68 2c 13 81 00       	push   $0x81132c
  802b9e:	68 2d 05 00 00       	push   $0x52d
  802ba3:	68 e2 14 81 00       	push   $0x8114e2
  802ba8:	e8 9d b8 00 00       	call   80e44a <_panic>
  802bad:	89 c7                	mov    %eax,%edi
  dhcp = netif->dhcp;
  802baf:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bb2:	85 db                	test   %ebx,%ebx
  802bb4:	75 17                	jne    802bcd <dhcp_create_request+0x44>
  802bb6:	83 ec 04             	sub    $0x4,%esp
  802bb9:	68 50 13 81 00       	push   $0x811350
  802bbe:	68 2f 05 00 00       	push   $0x52f
  802bc3:	68 e2 14 81 00       	push   $0x8114e2
  802bc8:	e8 7d b8 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802bcd:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802bd1:	74 17                	je     802bea <dhcp_create_request+0x61>
  802bd3:	83 ec 04             	sub    $0x4,%esp
  802bd6:	68 74 13 81 00       	push   $0x811374
  802bdb:	68 30 05 00 00       	push   $0x530
  802be0:	68 e2 14 81 00       	push   $0x8114e2
  802be5:	e8 60 b8 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802bea:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802bee:	74 17                	je     802c07 <dhcp_create_request+0x7e>
  802bf0:	83 ec 04             	sub    $0x4,%esp
  802bf3:	68 a0 13 81 00       	push   $0x8113a0
  802bf8:	68 31 05 00 00       	push   $0x531
  802bfd:	68 e2 14 81 00       	push   $0x8114e2
  802c02:	e8 43 b8 00 00       	call   80e44a <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802c07:	83 ec 04             	sub    $0x4,%esp
  802c0a:	6a 00                	push   $0x0
  802c0c:	68 34 01 00 00       	push   $0x134
  802c11:	6a 00                	push   $0x0
  802c13:	e8 d8 1c 00 00       	call   8048f0 <pbuf_alloc>
  802c18:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802c1b:	83 c4 10             	add    $0x10,%esp
  802c1e:	85 c0                	test   %eax,%eax
  802c20:	0f 84 37 01 00 00    	je     802d5d <dhcp_create_request+0x1d4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c26:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802c2c:	77 17                	ja     802c45 <dhcp_create_request+0xbc>
  802c2e:	83 ec 04             	sub    $0x4,%esp
  802c31:	68 cc 13 81 00       	push   $0x8113cc
  802c36:	68 38 05 00 00       	push   $0x538
  802c3b:	68 e2 14 81 00       	push   $0x8114e2
  802c40:	e8 05 b8 00 00       	call   80e44a <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  802c45:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802c4b:	8d 4a 01             	lea    0x1(%edx),%ecx
  802c4e:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802c54:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802c57:	8b 40 04             	mov    0x4(%eax),%eax
  802c5a:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802c5d:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802c60:	8b 43 20             	mov    0x20(%ebx),%eax
  802c63:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802c67:	8b 43 20             	mov    0x20(%ebx),%eax
  802c6a:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802c6e:	8b 43 20             	mov    0x20(%ebx),%eax
  802c71:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802c75:	8b 73 20             	mov    0x20(%ebx),%esi
  802c78:	83 ec 0c             	sub    $0xc,%esp
  802c7b:	ff 73 04             	pushl  0x4(%ebx)
  802c7e:	e8 72 4a 00 00       	call   8076f5 <htonl>
  802c83:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  802c86:	8b 43 20             	mov    0x20(%ebx),%eax
  802c89:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802c8f:	8b 43 20             	mov    0x20(%ebx),%eax
  802c92:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802c98:	8b 43 20             	mov    0x20(%ebx),%eax
  802c9b:	8b 57 04             	mov    0x4(%edi),%edx
  802c9e:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802ca1:	8b 43 20             	mov    0x20(%ebx),%eax
  802ca4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802cab:	8b 43 20             	mov    0x20(%ebx),%eax
  802cae:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802cb5:	8b 43 20             	mov    0x20(%ebx),%eax
  802cb8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802cbf:	83 c4 10             	add    $0x10,%esp
  802cc2:	b8 00 00 00 00       	mov    $0x0,%eax
  802cc7:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802cca:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  802ccd:	8b 59 20             	mov    0x20(%ecx),%ebx
  802cd0:	89 c1                	mov    %eax,%ecx
  802cd2:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  802cd6:	ba 00 00 00 00       	mov    $0x0,%edx
  802cdb:	66 39 c6             	cmp    %ax,%si
  802cde:	76 05                	jbe    802ce5 <dhcp_create_request+0x15c>
  802ce0:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  802ce5:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  802ce9:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802cec:	83 f8 10             	cmp    $0x10,%eax
  802cef:	75 d9                	jne    802cca <dhcp_create_request+0x141>
  802cf1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  802cf4:	b8 00 00 00 00       	mov    $0x0,%eax
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  802cf9:	8b 53 20             	mov    0x20(%ebx),%edx
  802cfc:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802d01:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802d04:	83 f8 40             	cmp    $0x40,%eax
  802d07:	75 f0                	jne    802cf9 <dhcp_create_request+0x170>
  802d09:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  802d0e:	8b 53 20             	mov    0x20(%ebx),%edx
  802d11:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802d16:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802d19:	3d 80 00 00 00       	cmp    $0x80,%eax
  802d1e:	75 ee                	jne    802d0e <dhcp_create_request+0x185>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802d20:	8b 73 20             	mov    0x20(%ebx),%esi
  802d23:	83 ec 0c             	sub    $0xc,%esp
  802d26:	68 63 53 82 63       	push   $0x63825363
  802d2b:	e8 c5 49 00 00       	call   8076f5 <htonl>
  802d30:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802d36:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802d3c:	83 c4 10             	add    $0x10,%esp
  802d3f:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802d44:	8b 53 20             	mov    0x20(%ebx),%edx
  802d47:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802d4e:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802d51:	83 f8 44             	cmp    $0x44,%eax
  802d54:	75 ee                	jne    802d44 <dhcp_create_request+0x1bb>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  802d56:	b8 00 00 00 00       	mov    $0x0,%eax
  802d5b:	eb 05                	jmp    802d62 <dhcp_create_request+0x1d9>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  802d5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  802d62:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802d65:	5b                   	pop    %ebx
  802d66:	5e                   	pop    %esi
  802d67:	5f                   	pop    %edi
  802d68:	5d                   	pop    %ebp
  802d69:	c3                   	ret    

00802d6a <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802d6a:	55                   	push   %ebp
  802d6b:	89 e5                	mov    %esp,%ebp
  802d6d:	53                   	push   %ebx
  802d6e:	83 ec 04             	sub    $0x4,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d71:	85 c0                	test   %eax,%eax
  802d73:	75 17                	jne    802d8c <dhcp_delete_request+0x22>
  802d75:	83 ec 04             	sub    $0x4,%esp
  802d78:	68 10 14 81 00       	push   $0x811410
  802d7d:	68 69 05 00 00       	push   $0x569
  802d82:	68 e2 14 81 00       	push   $0x8114e2
  802d87:	e8 be b6 00 00       	call   80e44a <_panic>
  dhcp = netif->dhcp;
  802d8c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d8f:	85 db                	test   %ebx,%ebx
  802d91:	75 17                	jne    802daa <dhcp_delete_request+0x40>
  802d93:	83 ec 04             	sub    $0x4,%esp
  802d96:	68 34 14 81 00       	push   $0x811434
  802d9b:	68 6b 05 00 00       	push   $0x56b
  802da0:	68 e2 14 81 00       	push   $0x8114e2
  802da5:	e8 a0 b6 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802daa:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802dad:	85 c0                	test   %eax,%eax
  802daf:	75 17                	jne    802dc8 <dhcp_delete_request+0x5e>
  802db1:	83 ec 04             	sub    $0x4,%esp
  802db4:	68 58 14 81 00       	push   $0x811458
  802db9:	68 6c 05 00 00       	push   $0x56c
  802dbe:	68 e2 14 81 00       	push   $0x8114e2
  802dc3:	e8 82 b6 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802dc8:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802dcc:	75 17                	jne    802de5 <dhcp_delete_request+0x7b>
  802dce:	83 ec 04             	sub    $0x4,%esp
  802dd1:	68 84 14 81 00       	push   $0x811484
  802dd6:	68 6d 05 00 00       	push   $0x56d
  802ddb:	68 e2 14 81 00       	push   $0x8114e2
  802de0:	e8 65 b6 00 00       	call   80e44a <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802de5:	83 ec 0c             	sub    $0xc,%esp
  802de8:	50                   	push   %eax
  802de9:	e8 3c 1a 00 00       	call   80482a <pbuf_free>
  }
  dhcp->p_out = NULL;
  802dee:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802df5:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802dfc:	83 c4 10             	add    $0x10,%esp
  802dff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802e02:	c9                   	leave  
  802e03:	c3                   	ret    

00802e04 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  802e04:	55                   	push   %ebp
  802e05:	89 e5                	mov    %esp,%ebp
  802e07:	57                   	push   %edi
  802e08:	56                   	push   %esi
  802e09:	53                   	push   %ebx
  802e0a:	83 ec 0c             	sub    $0xc,%esp
  802e0d:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e0f:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802e12:	ba 04 00 00 00       	mov    $0x4,%edx
  802e17:	89 d8                	mov    %ebx,%eax
  802e19:	e8 cf f9 ff ff       	call   8027ed <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802e1e:	89 f8                	mov    %edi,%eax
  802e20:	e8 64 fd ff ff       	call   802b89 <dhcp_create_request>
  802e25:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e27:	84 c0                	test   %al,%al
  802e29:	0f 85 89 00 00 00    	jne    802eb8 <dhcp_rebind+0xb4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e2f:	b9 01 00 00 00       	mov    $0x1,%ecx
  802e34:	ba 35 00 00 00       	mov    $0x35,%edx
  802e39:	89 d8                	mov    %ebx,%eax
  802e3b:	e8 2e fb ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802e40:	ba 03 00 00 00       	mov    $0x3,%edx
  802e45:	89 d8                	mov    %ebx,%eax
  802e47:	e8 e1 fa ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e4c:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e51:	ba 39 00 00 00       	mov    $0x39,%edx
  802e56:	89 d8                	mov    %ebx,%eax
  802e58:	e8 11 fb ff ff       	call   80296e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e5d:	ba 40 02 00 00       	mov    $0x240,%edx
  802e62:	89 d8                	mov    %ebx,%eax
  802e64:	e8 6c fb ff ff       	call   8029d5 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  802e69:	89 d8                	mov    %ebx,%eax
  802e6b:	e8 c9 fb ff ff       	call   802a39 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802e70:	83 ec 08             	sub    $0x8,%esp
  802e73:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e77:	66 05 f0 00          	add    $0xf0,%ax
  802e7b:	0f b7 c0             	movzwl %ax,%eax
  802e7e:	50                   	push   %eax
  802e7f:	ff 73 1c             	pushl  0x1c(%ebx)
  802e82:	e8 ec 1c 00 00       	call   804b73 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e87:	83 c4 0c             	add    $0xc,%esp
  802e8a:	6a 43                	push   $0x43
  802e8c:	68 a4 1d 81 00       	push   $0x811da4
  802e91:	ff 73 08             	pushl  0x8(%ebx)
  802e94:	e8 f6 5f 00 00       	call   808e8f <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802e99:	89 3c 24             	mov    %edi,(%esp)
  802e9c:	6a 43                	push   $0x43
  802e9e:	68 a0 1d 81 00       	push   $0x811da0
  802ea3:	ff 73 1c             	pushl  0x1c(%ebx)
  802ea6:	ff 73 08             	pushl  0x8(%ebx)
  802ea9:	e8 fb 5d 00 00       	call   808ca9 <udp_sendto_if>
    dhcp_delete_request(netif);
  802eae:	83 c4 20             	add    $0x20,%esp
  802eb1:	89 f8                	mov    %edi,%eax
  802eb3:	e8 b2 fe ff ff       	call   802d6a <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802eb8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802ebc:	83 c0 01             	add    $0x1,%eax
  802ebf:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802ec2:	ba 10 27 00 00       	mov    $0x2710,%edx
  802ec7:	3c 09                	cmp    $0x9,%al
  802ec9:	77 08                	ja     802ed3 <dhcp_rebind+0xcf>
  802ecb:	0f b6 c0             	movzbl %al,%eax
  802ece:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802ed3:	0f b7 c2             	movzwl %dx,%eax
  802ed6:	05 f3 01 00 00       	add    $0x1f3,%eax
  802edb:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802ee0:	f7 ea                	imul   %edx
  802ee2:	c1 fa 05             	sar    $0x5,%edx
  802ee5:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802ee9:	89 f0                	mov    %esi,%eax
  802eeb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802eee:	5b                   	pop    %ebx
  802eef:	5e                   	pop    %esi
  802ef0:	5f                   	pop    %edi
  802ef1:	5d                   	pop    %ebp
  802ef2:	c3                   	ret    

00802ef3 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  802ef3:	55                   	push   %ebp
  802ef4:	89 e5                	mov    %esp,%ebp
  802ef6:	57                   	push   %edi
  802ef7:	56                   	push   %esi
  802ef8:	53                   	push   %ebx
  802ef9:	83 ec 0c             	sub    $0xc,%esp
  802efc:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802efe:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802f01:	a1 a4 1d 81 00       	mov    0x811da4,%eax
  802f06:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802f09:	89 f8                	mov    %edi,%eax
  802f0b:	e8 79 fc ff ff       	call   802b89 <dhcp_create_request>
  802f10:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f12:	84 c0                	test   %al,%al
  802f14:	0f 85 d6 00 00 00    	jne    802ff0 <dhcp_discover+0xfd>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f1a:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f1f:	ba 35 00 00 00       	mov    $0x35,%edx
  802f24:	89 d8                	mov    %ebx,%eax
  802f26:	e8 43 fa ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802f2b:	ba 01 00 00 00       	mov    $0x1,%edx
  802f30:	89 d8                	mov    %ebx,%eax
  802f32:	e8 f6 f9 ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802f37:	b9 02 00 00 00       	mov    $0x2,%ecx
  802f3c:	ba 39 00 00 00       	mov    $0x39,%edx
  802f41:	89 d8                	mov    %ebx,%eax
  802f43:	e8 26 fa ff ff       	call   80296e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f48:	ba 40 02 00 00       	mov    $0x240,%edx
  802f4d:	89 d8                	mov    %ebx,%eax
  802f4f:	e8 81 fa ff ff       	call   8029d5 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802f54:	b9 04 00 00 00       	mov    $0x4,%ecx
  802f59:	ba 37 00 00 00       	mov    $0x37,%edx
  802f5e:	89 d8                	mov    %ebx,%eax
  802f60:	e8 09 fa ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802f65:	ba 01 00 00 00       	mov    $0x1,%edx
  802f6a:	89 d8                	mov    %ebx,%eax
  802f6c:	e8 bc f9 ff ff       	call   80292d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802f71:	ba 03 00 00 00       	mov    $0x3,%edx
  802f76:	89 d8                	mov    %ebx,%eax
  802f78:	e8 b0 f9 ff ff       	call   80292d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f7d:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f82:	89 d8                	mov    %ebx,%eax
  802f84:	e8 a4 f9 ff ff       	call   80292d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f89:	ba 06 00 00 00       	mov    $0x6,%edx
  802f8e:	89 d8                	mov    %ebx,%eax
  802f90:	e8 98 f9 ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  802f95:	89 d8                	mov    %ebx,%eax
  802f97:	e8 9d fa ff ff       	call   802a39 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f9c:	83 ec 08             	sub    $0x8,%esp
  802f9f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802fa3:	66 05 f0 00          	add    $0xf0,%ax
  802fa7:	0f b7 c0             	movzwl %ax,%eax
  802faa:	50                   	push   %eax
  802fab:	ff 73 1c             	pushl  0x1c(%ebx)
  802fae:	e8 c0 1b 00 00       	call   804b73 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802fb3:	83 c4 0c             	add    $0xc,%esp
  802fb6:	6a 43                	push   $0x43
  802fb8:	68 a4 1d 81 00       	push   $0x811da4
  802fbd:	ff 73 08             	pushl  0x8(%ebx)
  802fc0:	e8 ca 5e 00 00       	call   808e8f <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802fc5:	89 3c 24             	mov    %edi,(%esp)
  802fc8:	6a 43                	push   $0x43
  802fca:	68 a0 1d 81 00       	push   $0x811da0
  802fcf:	ff 73 1c             	pushl  0x1c(%ebx)
  802fd2:	ff 73 08             	pushl  0x8(%ebx)
  802fd5:	e8 cf 5c 00 00       	call   808ca9 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  802fda:	83 c4 20             	add    $0x20,%esp
  802fdd:	89 f8                	mov    %edi,%eax
  802fdf:	e8 86 fd ff ff       	call   802d6a <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802fe4:	ba 06 00 00 00       	mov    $0x6,%edx
  802fe9:	89 d8                	mov    %ebx,%eax
  802feb:	e8 fd f7 ff ff       	call   8027ed <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802ff0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802ff4:	83 c0 01             	add    $0x1,%eax
  802ff7:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802ffa:	ba 10 27 00 00       	mov    $0x2710,%edx
  802fff:	3c 03                	cmp    $0x3,%al
  803001:	77 0b                	ja     80300e <dhcp_discover+0x11b>
  803003:	0f b6 c0             	movzbl %al,%eax
  803006:	83 c0 01             	add    $0x1,%eax
  803009:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80300e:	0f b7 c2             	movzwl %dx,%eax
  803011:	05 f3 01 00 00       	add    $0x1f3,%eax
  803016:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80301b:	f7 ea                	imul   %edx
  80301d:	c1 fa 05             	sar    $0x5,%edx
  803020:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803024:	89 f0                	mov    %esi,%eax
  803026:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803029:	5b                   	pop    %ebx
  80302a:	5e                   	pop    %esi
  80302b:	5f                   	pop    %edi
  80302c:	5d                   	pop    %ebp
  80302d:	c3                   	ret    

0080302e <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80302e:	55                   	push   %ebp
  80302f:	89 e5                	mov    %esp,%ebp
  803031:	57                   	push   %edi
  803032:	56                   	push   %esi
  803033:	53                   	push   %ebx
  803034:	83 ec 0c             	sub    $0xc,%esp
  803037:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803039:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80303c:	e8 48 fb ff ff       	call   802b89 <dhcp_create_request>
  803041:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803043:	84 c0                	test   %al,%al
  803045:	0f 85 20 01 00 00    	jne    80316b <dhcp_select+0x13d>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80304b:	b9 01 00 00 00       	mov    $0x1,%ecx
  803050:	ba 35 00 00 00       	mov    $0x35,%edx
  803055:	89 d8                	mov    %ebx,%eax
  803057:	e8 12 f9 ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80305c:	ba 03 00 00 00       	mov    $0x3,%edx
  803061:	89 d8                	mov    %ebx,%eax
  803063:	e8 c5 f8 ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803068:	b9 02 00 00 00       	mov    $0x2,%ecx
  80306d:	ba 39 00 00 00       	mov    $0x39,%edx
  803072:	89 d8                	mov    %ebx,%eax
  803074:	e8 f5 f8 ff ff       	call   80296e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803079:	ba 40 02 00 00       	mov    $0x240,%edx
  80307e:	89 d8                	mov    %ebx,%eax
  803080:	e8 50 f9 ff ff       	call   8029d5 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803085:	b9 04 00 00 00       	mov    $0x4,%ecx
  80308a:	ba 32 00 00 00       	mov    $0x32,%edx
  80308f:	89 d8                	mov    %ebx,%eax
  803091:	e8 d8 f8 ff ff       	call   80296e <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803096:	83 ec 0c             	sub    $0xc,%esp
  803099:	ff 73 30             	pushl  0x30(%ebx)
  80309c:	e8 75 48 00 00       	call   807916 <ntohl>
  8030a1:	89 c2                	mov    %eax,%edx
  8030a3:	89 d8                	mov    %ebx,%eax
  8030a5:	e8 44 fa ff ff       	call   802aee <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8030aa:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030af:	ba 36 00 00 00       	mov    $0x36,%edx
  8030b4:	89 d8                	mov    %ebx,%eax
  8030b6:	e8 b3 f8 ff ff       	call   80296e <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8030bb:	83 c4 04             	add    $0x4,%esp
  8030be:	ff 73 2c             	pushl  0x2c(%ebx)
  8030c1:	e8 50 48 00 00       	call   807916 <ntohl>
  8030c6:	89 c2                	mov    %eax,%edx
  8030c8:	89 d8                	mov    %ebx,%eax
  8030ca:	e8 1f fa ff ff       	call   802aee <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030cf:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030d4:	ba 37 00 00 00       	mov    $0x37,%edx
  8030d9:	89 d8                	mov    %ebx,%eax
  8030db:	e8 8e f8 ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8030e0:	ba 01 00 00 00       	mov    $0x1,%edx
  8030e5:	89 d8                	mov    %ebx,%eax
  8030e7:	e8 41 f8 ff ff       	call   80292d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8030ec:	ba 03 00 00 00       	mov    $0x3,%edx
  8030f1:	89 d8                	mov    %ebx,%eax
  8030f3:	e8 35 f8 ff ff       	call   80292d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8030f8:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8030fd:	89 d8                	mov    %ebx,%eax
  8030ff:	e8 29 f8 ff ff       	call   80292d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803104:	ba 06 00 00 00       	mov    $0x6,%edx
  803109:	89 d8                	mov    %ebx,%eax
  80310b:	e8 1d f8 ff ff       	call   80292d <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  803110:	89 d8                	mov    %ebx,%eax
  803112:	e8 22 f9 ff ff       	call   802a39 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803117:	83 c4 08             	add    $0x8,%esp
  80311a:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80311e:	66 05 f0 00          	add    $0xf0,%ax
  803122:	0f b7 c0             	movzwl %ax,%eax
  803125:	50                   	push   %eax
  803126:	ff 73 1c             	pushl  0x1c(%ebx)
  803129:	e8 45 1a 00 00       	call   804b73 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80312e:	89 3c 24             	mov    %edi,(%esp)
  803131:	6a 43                	push   $0x43
  803133:	68 a0 1d 81 00       	push   $0x811da0
  803138:	ff 73 1c             	pushl  0x1c(%ebx)
  80313b:	ff 73 08             	pushl  0x8(%ebx)
  80313e:	e8 66 5b 00 00       	call   808ca9 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803143:	83 c4 1c             	add    $0x1c,%esp
  803146:	6a 43                	push   $0x43
  803148:	68 a4 1d 81 00       	push   $0x811da4
  80314d:	ff 73 08             	pushl  0x8(%ebx)
  803150:	e8 3a 5d 00 00       	call   808e8f <udp_connect>
    dhcp_delete_request(netif);
  803155:	89 f8                	mov    %edi,%eax
  803157:	e8 0e fc ff ff       	call   802d6a <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80315c:	ba 01 00 00 00       	mov    $0x1,%edx
  803161:	89 d8                	mov    %ebx,%eax
  803163:	e8 85 f6 ff ff       	call   8027ed <dhcp_set_state>
  803168:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80316b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80316f:	83 c0 01             	add    $0x1,%eax
  803172:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803175:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  80317a:	3c 03                	cmp    $0x3,%al
  80317c:	77 08                	ja     803186 <dhcp_select+0x158>
  80317e:	0f b6 c0             	movzbl %al,%eax
  803181:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803186:	0f b7 c2             	movzwl %dx,%eax
  803189:	05 f3 01 00 00       	add    $0x1f3,%eax
  80318e:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803193:	f7 ea                	imul   %edx
  803195:	c1 fa 05             	sar    $0x5,%edx
  803198:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80319c:	89 f0                	mov    %esi,%eax
  80319e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8031a1:	5b                   	pop    %ebx
  8031a2:	5e                   	pop    %esi
  8031a3:	5f                   	pop    %edi
  8031a4:	5d                   	pop    %ebp
  8031a5:	c3                   	ret    

008031a6 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8031a6:	55                   	push   %ebp
  8031a7:	89 e5                	mov    %esp,%ebp
  8031a9:	53                   	push   %ebx
  8031aa:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8031ad:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8031b0:	6a 00                	push   $0x0
  8031b2:	8d 53 30             	lea    0x30(%ebx),%edx
  8031b5:	52                   	push   %edx
  8031b6:	50                   	push   %eax
  8031b7:	e8 9e 66 00 00       	call   80985a <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8031bc:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8031c0:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8031c6:	ba 08 00 00 00       	mov    $0x8,%edx
  8031cb:	89 d8                	mov    %ebx,%eax
  8031cd:	e8 1b f6 ff ff       	call   8027ed <dhcp_set_state>
}
  8031d2:	83 c4 10             	add    $0x10,%esp
  8031d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8031d8:	c9                   	leave  
  8031d9:	c3                   	ret    

008031da <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8031da:	55                   	push   %ebp
  8031db:	89 e5                	mov    %esp,%ebp
  8031dd:	56                   	push   %esi
  8031de:	53                   	push   %ebx
  8031df:	83 ec 10             	sub    $0x10,%esp
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8031e2:	85 c0                	test   %eax,%eax
  8031e4:	75 17                	jne    8031fd <dhcp_bind+0x23>
  8031e6:	83 ec 04             	sub    $0x4,%esp
  8031e9:	68 f7 14 81 00       	push   $0x8114f7
  8031ee:	68 3d 03 00 00       	push   $0x33d
  8031f3:	68 e2 14 81 00       	push   $0x8114e2
  8031f8:	e8 4d b2 00 00       	call   80e44a <_panic>
  8031fd:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  8031ff:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803202:	85 db                	test   %ebx,%ebx
  803204:	75 17                	jne    80321d <dhcp_bind+0x43>
  803206:	83 ec 04             	sub    $0x4,%esp
  803209:	68 10 15 81 00       	push   $0x811510
  80320e:	68 3f 03 00 00       	push   $0x33f
  803213:	68 e2 14 81 00       	push   $0x8114e2
  803218:	e8 2d b2 00 00       	call   80e44a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80321d:	8b 53 50             	mov    0x50(%ebx),%edx
  803220:	83 fa ff             	cmp    $0xffffffff,%edx
  803223:	74 2c                	je     803251 <dhcp_bind+0x77>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803225:	83 c2 1e             	add    $0x1e,%edx
  803228:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80322d:	89 d0                	mov    %edx,%eax
  80322f:	f7 e1                	mul    %ecx
  803231:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  803234:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  80323a:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80323f:	0f 47 d0             	cmova  %eax,%edx
  803242:	66 85 d2             	test   %dx,%dx
  803245:	b8 01 00 00 00       	mov    $0x1,%eax
  80324a:	0f 44 d0             	cmove  %eax,%edx
  80324d:	66 89 53 28          	mov    %dx,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803251:	8b 53 54             	mov    0x54(%ebx),%edx
  803254:	83 fa ff             	cmp    $0xffffffff,%edx
  803257:	74 2c                	je     803285 <dhcp_bind+0xab>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803259:	83 c2 1e             	add    $0x1e,%edx
  80325c:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803261:	89 d0                	mov    %edx,%eax
  803263:	f7 e1                	mul    %ecx
  803265:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  803268:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  80326e:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803273:	0f 47 d0             	cmova  %eax,%edx
  803276:	66 85 d2             	test   %dx,%dx
  803279:	b8 01 00 00 00       	mov    $0x1,%eax
  80327e:	0f 44 d0             	cmove  %eax,%edx
  803281:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803285:	83 fb cc             	cmp    $0xffffffcc,%ebx
  803288:	0f 84 c4 00 00 00    	je     803352 <dhcp_bind+0x178>
  80328e:	8b 43 34             	mov    0x34(%ebx),%eax
  803291:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  803294:	85 c0                	test   %eax,%eax
  803296:	75 55                	jne    8032ed <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  803298:	83 ec 0c             	sub    $0xc,%esp
  80329b:	6a 00                	push   $0x0
  80329d:	e8 74 46 00 00       	call   807916 <ntohl>
  8032a2:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8032a5:	83 c4 10             	add    $0x10,%esp
  8032a8:	84 c0                	test   %al,%al
  8032aa:	78 15                	js     8032c1 <dhcp_bind+0xe7>
      sn_mask.addr = htonl(0xff000000);
  8032ac:	83 ec 0c             	sub    $0xc,%esp
  8032af:	68 00 00 00 ff       	push   $0xff000000
  8032b4:	e8 3c 44 00 00       	call   8076f5 <htonl>
  8032b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032bc:	83 c4 10             	add    $0x10,%esp
  8032bf:	eb 2c                	jmp    8032ed <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  8032c1:	3c bf                	cmp    $0xbf,%al
  8032c3:	76 15                	jbe    8032da <dhcp_bind+0x100>
      sn_mask.addr = htonl(0xffffff00);
  8032c5:	83 ec 0c             	sub    $0xc,%esp
  8032c8:	68 00 ff ff ff       	push   $0xffffff00
  8032cd:	e8 23 44 00 00       	call   8076f5 <htonl>
  8032d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032d5:	83 c4 10             	add    $0x10,%esp
  8032d8:	eb 13                	jmp    8032ed <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8032da:	83 ec 0c             	sub    $0xc,%esp
  8032dd:	68 00 00 ff ff       	push   $0xffff0000
  8032e2:	e8 0e 44 00 00       	call   8076f5 <htonl>
  8032e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032ea:	83 c4 10             	add    $0x10,%esp
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8032ed:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8032f0:	74 0a                	je     8032fc <dhcp_bind+0x122>
  8032f2:	8b 43 38             	mov    0x38(%ebx),%eax
  8032f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  8032f8:	85 c0                	test   %eax,%eax
  8032fa:	75 19                	jne    803315 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8032fc:	8b 43 30             	mov    0x30(%ebx),%eax
  8032ff:	23 45 f4             	and    -0xc(%ebp),%eax
  803302:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803305:	83 ec 0c             	sub    $0xc,%esp
  803308:	6a 01                	push   $0x1
  80330a:	e8 e6 43 00 00       	call   8076f5 <htonl>
  80330f:	09 45 f0             	or     %eax,-0x10(%ebp)
  803312:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803315:	83 ec 08             	sub    $0x8,%esp
  803318:	8d 43 30             	lea    0x30(%ebx),%eax
  80331b:	50                   	push   %eax
  80331c:	56                   	push   %esi
  80331d:	e8 55 12 00 00       	call   804577 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  803322:	83 c4 08             	add    $0x8,%esp
  803325:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803328:	50                   	push   %eax
  803329:	56                   	push   %esi
  80332a:	e8 ab 13 00 00       	call   8046da <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80332f:	83 c4 08             	add    $0x8,%esp
  803332:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803335:	50                   	push   %eax
  803336:	56                   	push   %esi
  803337:	e8 83 13 00 00       	call   8046bf <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  80333c:	89 34 24             	mov    %esi,(%esp)
  80333f:	e8 be 13 00 00       	call   804702 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803344:	ba 0a 00 00 00       	mov    $0xa,%edx
  803349:	89 d8                	mov    %ebx,%eax
  80334b:	e8 9d f4 ff ff       	call   8027ed <dhcp_set_state>
}
  803350:	eb 0c                	jmp    80335e <dhcp_bind+0x184>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803352:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  803359:	e9 3a ff ff ff       	jmp    803298 <dhcp_bind+0xbe>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  80335e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803361:	5b                   	pop    %ebx
  803362:	5e                   	pop    %esi
  803363:	5d                   	pop    %ebp
  803364:	c3                   	ret    

00803365 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  803365:	55                   	push   %ebp
  803366:	89 e5                	mov    %esp,%ebp
  803368:	53                   	push   %ebx
  803369:	83 ec 04             	sub    $0x4,%esp
  80336c:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  80336e:	8b 40 10             	mov    0x10(%eax),%eax
  803371:	85 c0                	test   %eax,%eax
  803373:	74 13                	je     803388 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  803375:	83 ec 0c             	sub    $0xc,%esp
  803378:	50                   	push   %eax
  803379:	e8 0a 0c 00 00       	call   803f88 <mem_free>
    dhcp->msg_in = NULL;
  80337e:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803385:	83 c4 10             	add    $0x10,%esp
  }
  if (dhcp->options_in) {
  803388:	8b 43 14             	mov    0x14(%ebx),%eax
  80338b:	85 c0                	test   %eax,%eax
  80338d:	74 19                	je     8033a8 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  80338f:	83 ec 0c             	sub    $0xc,%esp
  803392:	50                   	push   %eax
  803393:	e8 f0 0b 00 00       	call   803f88 <mem_free>
    dhcp->options_in = NULL;
  803398:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  80339f:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  8033a5:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  8033a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8033ab:	c9                   	leave  
  8033ac:	c3                   	ret    

008033ad <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8033ad:	55                   	push   %ebp
  8033ae:	89 e5                	mov    %esp,%ebp
  8033b0:	57                   	push   %edi
  8033b1:	56                   	push   %esi
  8033b2:	53                   	push   %ebx
  8033b3:	83 ec 1c             	sub    $0x1c,%esp
  8033b6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8033b9:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8033bc:	8b 45 10             	mov    0x10(%ebp),%eax
  8033bf:	8b 48 04             	mov    0x4(%eax),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8033c2:	89 46 0c             	mov    %eax,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8033c5:	80 39 02             	cmpb   $0x2,(%ecx)
  8033c8:	0f 85 b8 03 00 00    	jne    803786 <dhcp_recv+0x3d9>
  8033ce:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8033d7:	eb 12                	jmp    8033eb <dhcp_recv+0x3e>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8033d9:	0f b6 54 03 25       	movzbl 0x25(%ebx,%eax,1),%edx
  8033de:	83 c0 01             	add    $0x1,%eax
  8033e1:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  8033e5:	0f 85 9b 03 00 00    	jne    803786 <dhcp_recv+0x3d9>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033eb:	39 f8                	cmp    %edi,%eax
  8033ed:	75 ea                	jne    8033d9 <dhcp_recv+0x2c>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8033ef:	83 ec 0c             	sub    $0xc,%esp
  8033f2:	ff 71 04             	pushl  0x4(%ecx)
  8033f5:	e8 1c 45 00 00       	call   807916 <ntohl>
  8033fa:	83 c4 10             	add    $0x10,%esp
  8033fd:	3b 46 04             	cmp    0x4(%esi),%eax
  803400:	0f 85 80 03 00 00    	jne    803786 <dhcp_recv+0x3d9>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  803406:	85 f6                	test   %esi,%esi
  803408:	75 17                	jne    803421 <dhcp_recv+0x74>
  80340a:	83 ec 04             	sub    $0x4,%esp
  80340d:	68 1b 15 81 00       	push   $0x81151b
  803412:	68 89 04 00 00       	push   $0x489
  803417:	68 e2 14 81 00       	push   $0x8114e2
  80341c:	e8 29 b0 00 00       	call   80e44a <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  803421:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  803425:	75 17                	jne    80343e <dhcp_recv+0x91>
  803427:	83 ec 04             	sub    $0x4,%esp
  80342a:	68 28 15 81 00       	push   $0x811528
  80342f:	68 8a 04 00 00       	push   $0x48a
  803434:	68 e2 14 81 00       	push   $0x8114e2
  803439:	e8 0c b0 00 00       	call   80e44a <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80343e:	89 f0                	mov    %esi,%eax
  803440:	e8 20 ff ff ff       	call   803365 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  803445:	8b 46 0c             	mov    0xc(%esi),%eax
  803448:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80344c:	66 3d f0 00          	cmp    $0xf0,%ax
  803450:	76 22                	jbe    803474 <dhcp_recv+0xc7>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803452:	66 2d f0 00          	sub    $0xf0,%ax
  803456:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80345a:	83 ec 0c             	sub    $0xc,%esp
  80345d:	0f b7 c0             	movzwl %ax,%eax
  803460:	50                   	push   %eax
  803461:	e8 d4 0d 00 00       	call   80423a <mem_malloc>
  803466:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  803469:	83 c4 10             	add    $0x10,%esp
  80346c:	85 c0                	test   %eax,%eax
  80346e:	0f 84 12 03 00 00    	je     803786 <dhcp_recv+0x3d9>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803474:	83 ec 0c             	sub    $0xc,%esp
  803477:	68 f0 00 00 00       	push   $0xf0
  80347c:	e8 b9 0d 00 00       	call   80423a <mem_malloc>
  803481:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  803484:	83 c4 10             	add    $0x10,%esp
  803487:	85 c0                	test   %eax,%eax
  803489:	75 1a                	jne    8034a5 <dhcp_recv+0xf8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80348b:	83 ec 0c             	sub    $0xc,%esp
  80348e:	ff 76 14             	pushl  0x14(%esi)
  803491:	e8 f2 0a 00 00       	call   803f88 <mem_free>
    dhcp->options_in = NULL;
  803496:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  80349d:	83 c4 10             	add    $0x10,%esp
  8034a0:	e9 e1 02 00 00       	jmp    803786 <dhcp_recv+0x3d9>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8034a5:	6a 00                	push   $0x0
  8034a7:	68 f0 00 00 00       	push   $0xf0
  8034ac:	50                   	push   %eax
  8034ad:	ff 76 0c             	pushl  0xc(%esi)
  8034b0:	e8 c5 1a 00 00       	call   804f7a <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034b5:	83 c4 10             	add    $0x10,%esp
  8034b8:	66 3d f0 00          	cmp    $0xf0,%ax
  8034bc:	74 17                	je     8034d5 <dhcp_recv+0x128>
  8034be:	83 ec 04             	sub    $0x4,%esp
  8034c1:	68 b0 14 81 00       	push   $0x8114b0
  8034c6:	68 a0 04 00 00       	push   $0x4a0
  8034cb:	68 e2 14 81 00       	push   $0x8114e2
  8034d0:	e8 75 af 00 00       	call   80e44a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8034d5:	8b 46 14             	mov    0x14(%esi),%eax
  8034d8:	85 c0                	test   %eax,%eax
  8034da:	0f 84 ba 02 00 00    	je     80379a <dhcp_recv+0x3ed>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034e0:	68 f0 00 00 00       	push   $0xf0
  8034e5:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  8034e9:	52                   	push   %edx
  8034ea:	50                   	push   %eax
  8034eb:	ff 76 0c             	pushl  0xc(%esi)
  8034ee:	e8 87 1a 00 00       	call   804f7a <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8034f3:	83 c4 10             	add    $0x10,%esp
  8034f6:	66 3b 46 18          	cmp    0x18(%esi),%ax
  8034fa:	0f 84 9a 02 00 00    	je     80379a <dhcp_recv+0x3ed>
  803500:	83 ec 04             	sub    $0x4,%esp
  803503:	68 38 15 81 00       	push   $0x811538
  803508:	68 a7 04 00 00       	push   $0x4a7
  80350d:	68 e2 14 81 00       	push   $0x8114e2
  803512:	e8 33 af 00 00       	call   80e44a <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  803517:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80351b:	3c 05                	cmp    $0x5,%al
  80351d:	0f 85 a3 01 00 00    	jne    8036c6 <dhcp_recv+0x319>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  803523:	0f b6 06             	movzbl (%esi),%eax
  803526:	3c 01                	cmp    $0x1,%al
  803528:	0f 85 7b 01 00 00    	jne    8036a9 <dhcp_recv+0x2fc>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80352e:	8b 7b 20             	mov    0x20(%ebx),%edi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  803531:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  803538:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  80353f:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803546:	ba 33 00 00 00       	mov    $0x33,%edx
  80354b:	89 f8                	mov    %edi,%eax
  80354d:	e8 aa f2 ff ff       	call   8027fc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803552:	85 c0                	test   %eax,%eax
  803554:	74 0b                	je     803561 <dhcp_recv+0x1b4>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803556:	83 c0 02             	add    $0x2,%eax
  803559:	e8 aa f3 ff ff       	call   802908 <dhcp_get_option_long>
  80355e:	89 47 4c             	mov    %eax,0x4c(%edi)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803561:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803566:	89 f8                	mov    %edi,%eax
  803568:	e8 8f f2 ff ff       	call   8027fc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80356d:	85 c0                	test   %eax,%eax
  80356f:	74 0d                	je     80357e <dhcp_recv+0x1d1>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  803571:	83 c0 02             	add    $0x2,%eax
  803574:	e8 8f f3 ff ff       	call   802908 <dhcp_get_option_long>
  803579:	89 47 50             	mov    %eax,0x50(%edi)
  80357c:	eb 08                	jmp    803586 <dhcp_recv+0x1d9>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  80357e:	8b 47 4c             	mov    0x4c(%edi),%eax
  803581:	d1 e8                	shr    %eax
  803583:	89 47 50             	mov    %eax,0x50(%edi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803586:	ba 3b 00 00 00       	mov    $0x3b,%edx
  80358b:	89 f8                	mov    %edi,%eax
  80358d:	e8 6a f2 ff ff       	call   8027fc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803592:	85 c0                	test   %eax,%eax
  803594:	74 0d                	je     8035a3 <dhcp_recv+0x1f6>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803596:	83 c0 02             	add    $0x2,%eax
  803599:	e8 6a f3 ff ff       	call   802908 <dhcp_get_option_long>
  80359e:	89 47 54             	mov    %eax,0x54(%edi)
  8035a1:	eb 06                	jmp    8035a9 <dhcp_recv+0x1fc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8035a3:	8b 47 4c             	mov    0x4c(%edi),%eax
  8035a6:	89 47 54             	mov    %eax,0x54(%edi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8035a9:	8b 47 10             	mov    0x10(%edi),%eax
  8035ac:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8035af:	74 05                	je     8035b6 <dhcp_recv+0x209>
  8035b1:	8b 40 10             	mov    0x10(%eax),%eax
  8035b4:	eb 05                	jmp    8035bb <dhcp_recv+0x20e>
  8035b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8035bb:	89 47 30             	mov    %eax,0x30(%edi)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8035be:	ba 01 00 00 00       	mov    $0x1,%edx
  8035c3:	89 f8                	mov    %edi,%eax
  8035c5:	e8 32 f2 ff ff       	call   8027fc <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8035ca:	85 c0                	test   %eax,%eax
  8035cc:	74 17                	je     8035e5 <dhcp_recv+0x238>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035ce:	83 c0 02             	add    $0x2,%eax
  8035d1:	e8 32 f3 ff ff       	call   802908 <dhcp_get_option_long>
  8035d6:	83 ec 0c             	sub    $0xc,%esp
  8035d9:	50                   	push   %eax
  8035da:	e8 16 41 00 00       	call   8076f5 <htonl>
  8035df:	89 47 34             	mov    %eax,0x34(%edi)
  8035e2:	83 c4 10             	add    $0x10,%esp
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8035e5:	ba 03 00 00 00       	mov    $0x3,%edx
  8035ea:	89 f8                	mov    %edi,%eax
  8035ec:	e8 0b f2 ff ff       	call   8027fc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035f1:	85 c0                	test   %eax,%eax
  8035f3:	74 17                	je     80360c <dhcp_recv+0x25f>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035f5:	83 c0 02             	add    $0x2,%eax
  8035f8:	e8 0b f3 ff ff       	call   802908 <dhcp_get_option_long>
  8035fd:	83 ec 0c             	sub    $0xc,%esp
  803600:	50                   	push   %eax
  803601:	e8 ef 40 00 00       	call   8076f5 <htonl>
  803606:	89 47 38             	mov    %eax,0x38(%edi)
  803609:	83 c4 10             	add    $0x10,%esp
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80360c:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803611:	89 f8                	mov    %edi,%eax
  803613:	e8 e4 f1 ff ff       	call   8027fc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803618:	85 c0                	test   %eax,%eax
  80361a:	74 17                	je     803633 <dhcp_recv+0x286>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80361c:	83 c0 02             	add    $0x2,%eax
  80361f:	e8 e4 f2 ff ff       	call   802908 <dhcp_get_option_long>
  803624:	83 ec 0c             	sub    $0xc,%esp
  803627:	50                   	push   %eax
  803628:	e8 c8 40 00 00       	call   8076f5 <htonl>
  80362d:	89 47 3c             	mov    %eax,0x3c(%edi)
  803630:	83 c4 10             	add    $0x10,%esp
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803633:	ba 06 00 00 00       	mov    $0x6,%edx
  803638:	89 f8                	mov    %edi,%eax
  80363a:	e8 bd f1 ff ff       	call   8027fc <dhcp_get_option_ptr>
  80363f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (option_ptr != NULL) {
  803642:	85 c0                	test   %eax,%eax
  803644:	74 51                	je     803697 <dhcp_recv+0x2ea>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803646:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  80364a:	c0 e8 02             	shr    $0x2,%al
  80364d:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803650:	83 f8 03             	cmp    $0x3,%eax
  803653:	ba 02 00 00 00       	mov    $0x2,%edx
  803658:	0f 43 c2             	cmovae %edx,%eax
  80365b:	89 47 40             	mov    %eax,0x40(%edi)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  80365e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  803662:	89 5d 08             	mov    %ebx,0x8(%ebp)
  803665:	eb 24                	jmp    80368b <dhcp_recv+0x2de>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803667:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80366b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80366e:	8d 44 99 02          	lea    0x2(%ecx,%ebx,4),%eax
  803672:	e8 91 f2 ff ff       	call   802908 <dhcp_get_option_long>
  803677:	83 ec 0c             	sub    $0xc,%esp
  80367a:	50                   	push   %eax
  80367b:	e8 75 40 00 00       	call   8076f5 <htonl>
  803680:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803684:	80 45 e7 01          	addb   $0x1,-0x19(%ebp)
  803688:	83 c4 10             	add    $0x10,%esp
  80368b:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80368f:	3b 47 40             	cmp    0x40(%edi),%eax
  803692:	72 d3                	jb     803667 <dhcp_recv+0x2ba>
  803694:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803697:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80369d:	89 d8                	mov    %ebx,%eax
  80369f:	e8 02 fb ff ff       	call   8031a6 <dhcp_check>
  8036a4:	e9 dd 00 00 00       	jmp    803786 <dhcp_recv+0x3d9>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8036a9:	83 e8 03             	sub    $0x3,%eax
  8036ac:	3c 02                	cmp    $0x2,%al
  8036ae:	0f 87 d2 00 00 00    	ja     803786 <dhcp_recv+0x3d9>
      dhcp->request_timeout = 0;
  8036b4:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  8036ba:	89 d8                	mov    %ebx,%eax
  8036bc:	e8 19 fb ff ff       	call   8031da <dhcp_bind>
  8036c1:	e9 c0 00 00 00       	jmp    803786 <dhcp_recv+0x3d9>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8036c6:	3c 06                	cmp    $0x6,%al
  8036c8:	75 67                	jne    803731 <dhcp_recv+0x384>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8036ca:	0f b6 06             	movzbl (%esi),%eax
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8036cd:	8d 50 fd             	lea    -0x3(%eax),%edx
  8036d0:	80 fa 02             	cmp    $0x2,%dl
  8036d3:	76 08                	jbe    8036dd <dhcp_recv+0x330>
  8036d5:	3c 01                	cmp    $0x1,%al
  8036d7:	0f 85 a9 00 00 00    	jne    803786 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  8036dd:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8036e3:	8b 7b 20             	mov    0x20(%ebx),%edi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  8036e6:	83 ec 0c             	sub    $0xc,%esp
  8036e9:	53                   	push   %ebx
  8036ea:	e8 44 10 00 00       	call   804733 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8036ef:	83 c4 08             	add    $0x8,%esp
  8036f2:	68 a4 1d 81 00       	push   $0x811da4
  8036f7:	53                   	push   %ebx
  8036f8:	e8 7a 0e 00 00       	call   804577 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8036fd:	83 c4 08             	add    $0x8,%esp
  803700:	68 a4 1d 81 00       	push   $0x811da4
  803705:	53                   	push   %ebx
  803706:	e8 b4 0f 00 00       	call   8046bf <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80370b:	83 c4 08             	add    $0x8,%esp
  80370e:	68 a4 1d 81 00       	push   $0x811da4
  803713:	53                   	push   %ebx
  803714:	e8 c1 0f 00 00       	call   8046da <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803719:	ba 0c 00 00 00       	mov    $0xc,%edx
  80371e:	89 f8                	mov    %edi,%eax
  803720:	e8 c8 f0 ff ff       	call   8027ed <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803725:	89 d8                	mov    %ebx,%eax
  803727:	e8 c7 f7 ff ff       	call   802ef3 <dhcp_discover>
  80372c:	83 c4 10             	add    $0x10,%esp
  80372f:	eb 55                	jmp    803786 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803731:	3c 02                	cmp    $0x2,%al
  803733:	75 51                	jne    803786 <dhcp_recv+0x3d9>
  803735:	80 3e 06             	cmpb   $0x6,(%esi)
  803738:	75 4c                	jne    803786 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80373a:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803740:	8b 7b 20             	mov    0x20(%ebx),%edi
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803743:	ba 36 00 00 00       	mov    $0x36,%edx
  803748:	89 f8                	mov    %edi,%eax
  80374a:	e8 ad f0 ff ff       	call   8027fc <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  80374f:	85 c0                	test   %eax,%eax
  803751:	74 33                	je     803786 <dhcp_recv+0x3d9>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803753:	83 c0 02             	add    $0x2,%eax
  803756:	e8 ad f1 ff ff       	call   802908 <dhcp_get_option_long>
  80375b:	83 ec 0c             	sub    $0xc,%esp
  80375e:	50                   	push   %eax
  80375f:	e8 91 3f 00 00       	call   8076f5 <htonl>
  803764:	89 47 2c             	mov    %eax,0x2c(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803767:	8b 47 10             	mov    0x10(%edi),%eax
  80376a:	83 c4 10             	add    $0x10,%esp
  80376d:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803770:	74 05                	je     803777 <dhcp_recv+0x3ca>
  803772:	8b 40 10             	mov    0x10(%eax),%eax
  803775:	eb 05                	jmp    80377c <dhcp_recv+0x3cf>
  803777:	b8 00 00 00 00       	mov    $0x0,%eax
  80377c:	89 47 30             	mov    %eax,0x30(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  80377f:	89 d8                	mov    %ebx,%eax
  803781:	e8 a8 f8 ff ff       	call   80302e <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803786:	83 ec 0c             	sub    $0xc,%esp
  803789:	ff 75 10             	pushl  0x10(%ebp)
  80378c:	e8 99 10 00 00       	call   80482a <pbuf_free>
  dhcp->p = NULL;
  803791:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  803798:	eb 16                	jmp    8037b0 <dhcp_recv+0x403>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80379a:	ba 35 00 00 00       	mov    $0x35,%edx
  80379f:	89 f0                	mov    %esi,%eax
  8037a1:	e8 56 f0 ff ff       	call   8027fc <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8037a6:	85 c0                	test   %eax,%eax
  8037a8:	0f 85 69 fd ff ff    	jne    803517 <dhcp_recv+0x16a>
  8037ae:	eb d6                	jmp    803786 <dhcp_recv+0x3d9>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  8037b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8037b3:	5b                   	pop    %ebx
  8037b4:	5e                   	pop    %esi
  8037b5:	5f                   	pop    %edi
  8037b6:	5d                   	pop    %ebp
  8037b7:	c3                   	ret    

008037b8 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  8037b8:	55                   	push   %ebp
  8037b9:	89 e5                	mov    %esp,%ebp
  8037bb:	57                   	push   %edi
  8037bc:	56                   	push   %esi
  8037bd:	53                   	push   %ebx
  8037be:	83 ec 18             	sub    $0x18,%esp
  8037c1:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  8037c4:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  8037c7:	6a 58                	push   $0x58
  8037c9:	e8 6c 0a 00 00       	call   80423a <mem_malloc>
  if (dhcp == NULL) {
  8037ce:	83 c4 10             	add    $0x10,%esp
  8037d1:	85 c0                	test   %eax,%eax
  8037d3:	0f 84 1d 01 00 00    	je     8038f6 <dhcp_inform+0x13e>
  8037d9:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  8037db:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  8037de:	83 ec 04             	sub    $0x4,%esp
  8037e1:	6a 58                	push   $0x58
  8037e3:	6a 00                	push   $0x0
  8037e5:	50                   	push   %eax
  8037e6:	e8 02 b4 00 00       	call   80ebed <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  8037eb:	e8 83 57 00 00       	call   808f73 <udp_new>
  8037f0:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8037f3:	83 c4 10             	add    $0x10,%esp
  8037f6:	85 c0                	test   %eax,%eax
  8037f8:	75 11                	jne    80380b <dhcp_inform+0x53>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  8037fa:	83 ec 0c             	sub    $0xc,%esp
  8037fd:	53                   	push   %ebx
  8037fe:	e8 85 07 00 00       	call   803f88 <mem_free>
    return;
  803803:	83 c4 10             	add    $0x10,%esp
  803806:	e9 eb 00 00 00       	jmp    8038f6 <dhcp_inform+0x13e>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80380b:	89 f0                	mov    %esi,%eax
  80380d:	e8 77 f3 ff ff       	call   802b89 <dhcp_create_request>
  if (result == ERR_OK) {
  803812:	84 c0                	test   %al,%al
  803814:	0f 85 d3 00 00 00    	jne    8038ed <dhcp_inform+0x135>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80381a:	b9 01 00 00 00       	mov    $0x1,%ecx
  80381f:	ba 35 00 00 00       	mov    $0x35,%edx
  803824:	89 d8                	mov    %ebx,%eax
  803826:	e8 43 f1 ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  80382b:	ba 08 00 00 00       	mov    $0x8,%edx
  803830:	89 d8                	mov    %ebx,%eax
  803832:	e8 f6 f0 ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803837:	b9 02 00 00 00       	mov    $0x2,%ecx
  80383c:	ba 39 00 00 00       	mov    $0x39,%edx
  803841:	89 d8                	mov    %ebx,%eax
  803843:	e8 26 f1 ff ff       	call   80296e <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803848:	ba 40 02 00 00       	mov    $0x240,%edx
  80384d:	89 d8                	mov    %ebx,%eax
  80384f:	e8 81 f1 ff ff       	call   8029d5 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803854:	89 d8                	mov    %ebx,%eax
  803856:	e8 de f1 ff ff       	call   802a39 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80385b:	83 ec 08             	sub    $0x8,%esp
  80385e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803862:	66 05 f0 00          	add    $0xf0,%ax
  803866:	0f b7 c0             	movzwl %ax,%eax
  803869:	50                   	push   %eax
  80386a:	ff 73 1c             	pushl  0x1c(%ebx)
  80386d:	e8 01 13 00 00       	call   804b73 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803872:	83 c4 0c             	add    $0xc,%esp
  803875:	6a 44                	push   $0x44
  803877:	68 a4 1d 81 00       	push   $0x811da4
  80387c:	ff 73 08             	pushl  0x8(%ebx)
  80387f:	e8 69 53 00 00       	call   808bed <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803884:	83 c4 0c             	add    $0xc,%esp
  803887:	6a 43                	push   $0x43
  803889:	68 a0 1d 81 00       	push   $0x811da0
  80388e:	ff 73 08             	pushl  0x8(%ebx)
  803891:	e8 f9 55 00 00       	call   808e8f <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803896:	89 34 24             	mov    %esi,(%esp)
  803899:	6a 43                	push   $0x43
  80389b:	68 a0 1d 81 00       	push   $0x811da0
  8038a0:	ff 73 1c             	pushl  0x1c(%ebx)
  8038a3:	ff 73 08             	pushl  0x8(%ebx)
  8038a6:	e8 fe 53 00 00       	call   808ca9 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8038ab:	83 c4 1c             	add    $0x1c,%esp
  8038ae:	6a 43                	push   $0x43
  8038b0:	68 a4 1d 81 00       	push   $0x811da4
  8038b5:	ff 73 08             	pushl  0x8(%ebx)
  8038b8:	e8 d2 55 00 00       	call   808e8f <udp_connect>
    dhcp_delete_request(netif);
  8038bd:	89 f0                	mov    %esi,%eax
  8038bf:	e8 a6 f4 ff ff       	call   802d6a <dhcp_delete_request>
  8038c4:	83 c4 10             	add    $0x10,%esp
  8038c7:	eb 24                	jmp    8038ed <dhcp_inform+0x135>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  8038c9:	83 ec 0c             	sub    $0xc,%esp
  8038cc:	50                   	push   %eax
  8038cd:	e8 5d 56 00 00       	call   808f2f <udp_remove>
  8038d2:	83 c4 10             	add    $0x10,%esp
    }
    dhcp->pcb = NULL;
  8038d5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8038dc:	83 ec 0c             	sub    $0xc,%esp
  8038df:	53                   	push   %ebx
  8038e0:	e8 a3 06 00 00       	call   803f88 <mem_free>
    netif->dhcp = old_dhcp;
  8038e5:	89 7e 20             	mov    %edi,0x20(%esi)
  8038e8:	83 c4 10             	add    $0x10,%esp
  8038eb:	eb 09                	jmp    8038f6 <dhcp_inform+0x13e>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  8038ed:	8b 43 08             	mov    0x8(%ebx),%eax
  8038f0:	85 c0                	test   %eax,%eax
  8038f2:	75 d5                	jne    8038c9 <dhcp_inform+0x111>
  8038f4:	eb df                	jmp    8038d5 <dhcp_inform+0x11d>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  8038f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8038f9:	5b                   	pop    %ebx
  8038fa:	5e                   	pop    %esi
  8038fb:	5f                   	pop    %edi
  8038fc:	5d                   	pop    %ebp
  8038fd:	c3                   	ret    

008038fe <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  8038fe:	55                   	push   %ebp
  8038ff:	89 e5                	mov    %esp,%ebp
  803901:	56                   	push   %esi
  803902:	53                   	push   %ebx
  803903:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803906:	85 f6                	test   %esi,%esi
  803908:	75 17                	jne    803921 <dhcp_arp_reply+0x23>
  80390a:	83 ec 04             	sub    $0x4,%esp
  80390d:	68 02 15 81 00       	push   $0x811502
  803912:	68 b5 02 00 00       	push   $0x2b5
  803917:	68 e2 14 81 00       	push   $0x8114e2
  80391c:	e8 29 ab 00 00       	call   80e44a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803921:	8b 5e 20             	mov    0x20(%esi),%ebx
  803924:	85 db                	test   %ebx,%ebx
  803926:	0f 84 ea 00 00 00    	je     803a16 <dhcp_arp_reply+0x118>
  80392c:	80 3b 08             	cmpb   $0x8,(%ebx)
  80392f:	0f 85 e1 00 00 00    	jne    803a16 <dhcp_arp_reply+0x118>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803935:	8b 45 0c             	mov    0xc(%ebp),%eax
  803938:	8b 4b 30             	mov    0x30(%ebx),%ecx
  80393b:	39 08                	cmp    %ecx,(%eax)
  80393d:	0f 85 d3 00 00 00    	jne    803a16 <dhcp_arp_reply+0x118>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803943:	ba 0c 00 00 00       	mov    $0xc,%edx
  803948:	89 d8                	mov    %ebx,%eax
  80394a:	e8 9e ee ff ff       	call   8027ed <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80394f:	89 f0                	mov    %esi,%eax
  803951:	e8 33 f2 ff ff       	call   802b89 <dhcp_create_request>
  if (result == ERR_OK) {
  803956:	84 c0                	test   %al,%al
  803958:	0f 85 ae 00 00 00    	jne    803a0c <dhcp_arp_reply+0x10e>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80395e:	b9 01 00 00 00       	mov    $0x1,%ecx
  803963:	ba 35 00 00 00       	mov    $0x35,%edx
  803968:	89 d8                	mov    %ebx,%eax
  80396a:	e8 ff ef ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80396f:	ba 04 00 00 00       	mov    $0x4,%edx
  803974:	89 d8                	mov    %ebx,%eax
  803976:	e8 b2 ef ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80397b:	b9 02 00 00 00       	mov    $0x2,%ecx
  803980:	ba 39 00 00 00       	mov    $0x39,%edx
  803985:	89 d8                	mov    %ebx,%eax
  803987:	e8 e2 ef ff ff       	call   80296e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80398c:	ba 40 02 00 00       	mov    $0x240,%edx
  803991:	89 d8                	mov    %ebx,%eax
  803993:	e8 3d f0 ff ff       	call   8029d5 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803998:	b9 04 00 00 00       	mov    $0x4,%ecx
  80399d:	ba 32 00 00 00       	mov    $0x32,%edx
  8039a2:	89 d8                	mov    %ebx,%eax
  8039a4:	e8 c5 ef ff ff       	call   80296e <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8039a9:	83 ec 0c             	sub    $0xc,%esp
  8039ac:	ff 73 30             	pushl  0x30(%ebx)
  8039af:	e8 62 3f 00 00       	call   807916 <ntohl>
  8039b4:	89 c2                	mov    %eax,%edx
  8039b6:	89 d8                	mov    %ebx,%eax
  8039b8:	e8 31 f1 ff ff       	call   802aee <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  8039bd:	89 d8                	mov    %ebx,%eax
  8039bf:	e8 75 f0 ff ff       	call   802a39 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8039c4:	83 c4 08             	add    $0x8,%esp
  8039c7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039cb:	66 05 f0 00          	add    $0xf0,%ax
  8039cf:	0f b7 c0             	movzwl %ax,%eax
  8039d2:	50                   	push   %eax
  8039d3:	ff 73 1c             	pushl  0x1c(%ebx)
  8039d6:	e8 98 11 00 00       	call   804b73 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8039db:	83 c4 0c             	add    $0xc,%esp
  8039de:	6a 43                	push   $0x43
  8039e0:	68 a4 1d 81 00       	push   $0x811da4
  8039e5:	ff 73 08             	pushl  0x8(%ebx)
  8039e8:	e8 a2 54 00 00       	call   808e8f <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8039ed:	89 34 24             	mov    %esi,(%esp)
  8039f0:	6a 43                	push   $0x43
  8039f2:	68 a0 1d 81 00       	push   $0x811da0
  8039f7:	ff 73 1c             	pushl  0x1c(%ebx)
  8039fa:	ff 73 08             	pushl  0x8(%ebx)
  8039fd:	e8 a7 52 00 00       	call   808ca9 <udp_sendto_if>
    dhcp_delete_request(netif);
  803a02:	83 c4 20             	add    $0x20,%esp
  803a05:	89 f0                	mov    %esi,%eax
  803a07:	e8 5e f3 ff ff       	call   802d6a <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803a0c:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803a10:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803a16:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803a19:	5b                   	pop    %ebx
  803a1a:	5e                   	pop    %esi
  803a1b:	5d                   	pop    %ebp
  803a1c:	c3                   	ret    

00803a1d <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803a1d:	55                   	push   %ebp
  803a1e:	89 e5                	mov    %esp,%ebp
  803a20:	57                   	push   %edi
  803a21:	56                   	push   %esi
  803a22:	53                   	push   %ebx
  803a23:	83 ec 1c             	sub    $0x1c,%esp
  803a26:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803a29:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803a2c:	ba 05 00 00 00       	mov    $0x5,%edx
  803a31:	89 d8                	mov    %ebx,%eax
  803a33:	e8 b5 ed ff ff       	call   8027ed <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803a38:	89 f8                	mov    %edi,%eax
  803a3a:	e8 4a f1 ff ff       	call   802b89 <dhcp_create_request>
  803a3f:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803a41:	84 c0                	test   %al,%al
  803a43:	0f 85 89 00 00 00    	jne    803ad2 <dhcp_renew+0xb5>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a49:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a4e:	ba 35 00 00 00       	mov    $0x35,%edx
  803a53:	89 d8                	mov    %ebx,%eax
  803a55:	e8 14 ef ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a5a:	ba 03 00 00 00       	mov    $0x3,%edx
  803a5f:	89 d8                	mov    %ebx,%eax
  803a61:	e8 c7 ee ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a66:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a6b:	ba 39 00 00 00       	mov    $0x39,%edx
  803a70:	89 d8                	mov    %ebx,%eax
  803a72:	e8 f7 ee ff ff       	call   80296e <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803a77:	ba 40 02 00 00       	mov    $0x240,%edx
  803a7c:	89 d8                	mov    %ebx,%eax
  803a7e:	e8 52 ef ff ff       	call   8029d5 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803a83:	89 d8                	mov    %ebx,%eax
  803a85:	e8 af ef ff ff       	call   802a39 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a8a:	83 ec 08             	sub    $0x8,%esp
  803a8d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a91:	66 05 f0 00          	add    $0xf0,%ax
  803a95:	0f b7 c0             	movzwl %ax,%eax
  803a98:	50                   	push   %eax
  803a99:	ff 73 1c             	pushl  0x1c(%ebx)
  803a9c:	e8 d2 10 00 00       	call   804b73 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803aa1:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803aa4:	83 c4 0c             	add    $0xc,%esp
  803aa7:	6a 43                	push   $0x43
  803aa9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803aac:	50                   	push   %eax
  803aad:	ff 73 08             	pushl  0x8(%ebx)
  803ab0:	e8 da 53 00 00       	call   808e8f <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803ab5:	89 3c 24             	mov    %edi,(%esp)
  803ab8:	6a 43                	push   $0x43
  803aba:	ff 75 e4             	pushl  -0x1c(%ebp)
  803abd:	ff 73 1c             	pushl  0x1c(%ebx)
  803ac0:	ff 73 08             	pushl  0x8(%ebx)
  803ac3:	e8 e1 51 00 00       	call   808ca9 <udp_sendto_if>
    dhcp_delete_request(netif);
  803ac8:	83 c4 20             	add    $0x20,%esp
  803acb:	89 f8                	mov    %edi,%eax
  803acd:	e8 98 f2 ff ff       	call   802d6a <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803ad2:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ad6:	83 c0 01             	add    $0x1,%eax
  803ad9:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803adc:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803ae1:	3c 09                	cmp    $0x9,%al
  803ae3:	77 08                	ja     803aed <dhcp_renew+0xd0>
  803ae5:	0f b6 c0             	movzbl %al,%eax
  803ae8:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803aed:	0f b7 c2             	movzwl %dx,%eax
  803af0:	05 f3 01 00 00       	add    $0x1f3,%eax
  803af5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803afa:	f7 ea                	imul   %edx
  803afc:	c1 fa 05             	sar    $0x5,%edx
  803aff:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803b03:	89 f0                	mov    %esi,%eax
  803b05:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803b08:	5b                   	pop    %ebx
  803b09:	5e                   	pop    %esi
  803b0a:	5f                   	pop    %edi
  803b0b:	5d                   	pop    %ebp
  803b0c:	c3                   	ret    

00803b0d <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803b0d:	55                   	push   %ebp
  803b0e:	89 e5                	mov    %esp,%ebp
  803b10:	53                   	push   %ebx
  803b11:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803b14:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803b1a:	eb 6b                	jmp    803b87 <dhcp_coarse_tmr+0x7a>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803b1c:	8b 43 20             	mov    0x20(%ebx),%eax
  803b1f:	85 c0                	test   %eax,%eax
  803b21:	74 62                	je     803b85 <dhcp_coarse_tmr+0x78>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803b23:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803b27:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803b2a:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803b2e:	66 83 fa 01          	cmp    $0x1,%dx
  803b32:	75 1d                	jne    803b51 <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b34:	8b 43 20             	mov    0x20(%ebx),%eax
  803b37:	0f b6 00             	movzbl (%eax),%eax
  803b3a:	89 c2                	mov    %eax,%edx
  803b3c:	83 e2 fb             	and    $0xfffffffb,%edx
  803b3f:	80 fa 01             	cmp    $0x1,%dl
  803b42:	74 04                	je     803b48 <dhcp_coarse_tmr+0x3b>
  803b44:	3c 0a                	cmp    $0xa,%al
  803b46:	75 3d                	jne    803b85 <dhcp_coarse_tmr+0x78>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803b48:	89 d8                	mov    %ebx,%eax
  803b4a:	e8 b5 f2 ff ff       	call   802e04 <dhcp_rebind>
  803b4f:	eb 34                	jmp    803b85 <dhcp_coarse_tmr+0x78>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803b51:	8b 53 20             	mov    0x20(%ebx),%edx
  803b54:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803b58:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803b5b:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803b5f:	66 83 f8 01          	cmp    $0x1,%ax
  803b63:	75 20                	jne    803b85 <dhcp_coarse_tmr+0x78>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b65:	8b 43 20             	mov    0x20(%ebx),%eax
  803b68:	0f b6 00             	movzbl (%eax),%eax
  803b6b:	89 c2                	mov    %eax,%edx
  803b6d:	83 e2 fb             	and    $0xfffffffb,%edx
  803b70:	80 fa 01             	cmp    $0x1,%dl
  803b73:	74 04                	je     803b79 <dhcp_coarse_tmr+0x6c>
  803b75:	3c 0a                	cmp    $0xa,%al
  803b77:	75 0c                	jne    803b85 <dhcp_coarse_tmr+0x78>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  803b79:	83 ec 0c             	sub    $0xc,%esp
  803b7c:	53                   	push   %ebx
  803b7d:	e8 9b fe ff ff       	call   803a1d <dhcp_renew>
  803b82:	83 c4 10             	add    $0x10,%esp
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  803b85:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803b87:	85 db                	test   %ebx,%ebx
  803b89:	75 91                	jne    803b1c <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  803b8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b8e:	c9                   	leave  
  803b8f:	c3                   	ret    

00803b90 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  803b90:	55                   	push   %ebp
  803b91:	89 e5                	mov    %esp,%ebp
  803b93:	57                   	push   %edi
  803b94:	56                   	push   %esi
  803b95:	53                   	push   %ebx
  803b96:	83 ec 1c             	sub    $0x1c,%esp
  803b99:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b9c:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  803b9f:	ba 0d 00 00 00       	mov    $0xd,%edx
  803ba4:	89 d8                	mov    %ebx,%eax
  803ba6:	e8 42 ec ff ff       	call   8027ed <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  803bab:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803bb2:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803bb9:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803bc0:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803bc7:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803bce:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803bd5:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803bdc:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803be3:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803bea:	89 f0                	mov    %esi,%eax
  803bec:	e8 98 ef ff ff       	call   802b89 <dhcp_create_request>
  803bf1:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803bf3:	84 c0                	test   %al,%al
  803bf5:	75 6c                	jne    803c63 <dhcp_release+0xd3>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bf7:	b9 01 00 00 00       	mov    $0x1,%ecx
  803bfc:	ba 35 00 00 00       	mov    $0x35,%edx
  803c01:	89 d8                	mov    %ebx,%eax
  803c03:	e8 66 ed ff ff       	call   80296e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803c08:	ba 07 00 00 00       	mov    $0x7,%edx
  803c0d:	89 d8                	mov    %ebx,%eax
  803c0f:	e8 19 ed ff ff       	call   80292d <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803c14:	89 d8                	mov    %ebx,%eax
  803c16:	e8 1e ee ff ff       	call   802a39 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c1b:	83 ec 08             	sub    $0x8,%esp
  803c1e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c22:	66 05 f0 00          	add    $0xf0,%ax
  803c26:	0f b7 c0             	movzwl %ax,%eax
  803c29:	50                   	push   %eax
  803c2a:	ff 73 1c             	pushl  0x1c(%ebx)
  803c2d:	e8 41 0f 00 00       	call   804b73 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c32:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c35:	83 c4 0c             	add    $0xc,%esp
  803c38:	6a 43                	push   $0x43
  803c3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c3d:	50                   	push   %eax
  803c3e:	ff 73 08             	pushl  0x8(%ebx)
  803c41:	e8 49 52 00 00       	call   808e8f <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c46:	89 34 24             	mov    %esi,(%esp)
  803c49:	6a 43                	push   $0x43
  803c4b:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c4e:	ff 73 1c             	pushl  0x1c(%ebx)
  803c51:	ff 73 08             	pushl  0x8(%ebx)
  803c54:	e8 50 50 00 00       	call   808ca9 <udp_sendto_if>
    dhcp_delete_request(netif);
  803c59:	83 c4 20             	add    $0x20,%esp
  803c5c:	89 f0                	mov    %esi,%eax
  803c5e:	e8 07 f1 ff ff       	call   802d6a <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803c63:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803c67:	83 c0 01             	add    $0x1,%eax
  803c6a:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803c6d:	ba 10 27 00 00       	mov    $0x2710,%edx
  803c72:	3c 09                	cmp    $0x9,%al
  803c74:	77 08                	ja     803c7e <dhcp_release+0xee>
  803c76:	0f b6 c0             	movzbl %al,%eax
  803c79:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803c7e:	0f b7 c2             	movzwl %dx,%eax
  803c81:	05 f3 01 00 00       	add    $0x1f3,%eax
  803c86:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803c8b:	f7 ea                	imul   %edx
  803c8d:	c1 fa 05             	sar    $0x5,%edx
  803c90:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  803c94:	83 ec 0c             	sub    $0xc,%esp
  803c97:	56                   	push   %esi
  803c98:	e8 96 0a 00 00       	call   804733 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803c9d:	83 c4 08             	add    $0x8,%esp
  803ca0:	68 a4 1d 81 00       	push   $0x811da4
  803ca5:	56                   	push   %esi
  803ca6:	e8 cc 08 00 00       	call   804577 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803cab:	83 c4 08             	add    $0x8,%esp
  803cae:	68 a4 1d 81 00       	push   $0x811da4
  803cb3:	56                   	push   %esi
  803cb4:	e8 06 0a 00 00       	call   8046bf <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803cb9:	83 c4 08             	add    $0x8,%esp
  803cbc:	68 a4 1d 81 00       	push   $0x811da4
  803cc1:	56                   	push   %esi
  803cc2:	e8 13 0a 00 00       	call   8046da <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  803cc7:	89 f8                	mov    %edi,%eax
  803cc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803ccc:	5b                   	pop    %ebx
  803ccd:	5e                   	pop    %esi
  803cce:	5f                   	pop    %edi
  803ccf:	5d                   	pop    %ebp
  803cd0:	c3                   	ret    

00803cd1 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  803cd1:	55                   	push   %ebp
  803cd2:	89 e5                	mov    %esp,%ebp
  803cd4:	53                   	push   %ebx
  803cd5:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803cd8:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  803cde:	e9 c6 00 00 00       	jmp    803da9 <dhcp_fine_tmr+0xd8>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803ce3:	8b 53 20             	mov    0x20(%ebx),%edx
  803ce6:	85 d2                	test   %edx,%edx
  803ce8:	0f 84 b9 00 00 00    	je     803da7 <dhcp_fine_tmr+0xd6>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  803cee:	0f b7 42 26          	movzwl 0x26(%edx),%eax
  803cf2:	66 83 f8 01          	cmp    $0x1,%ax
  803cf6:	76 0c                	jbe    803d04 <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  803cf8:	83 e8 01             	sub    $0x1,%eax
  803cfb:	66 89 42 26          	mov    %ax,0x26(%edx)
  803cff:	e9 a3 00 00 00       	jmp    803da7 <dhcp_fine_tmr+0xd6>
      }
      else if (netif->dhcp->request_timeout == 1) {
  803d04:	66 83 f8 01          	cmp    $0x1,%ax
  803d08:	0f 85 99 00 00 00    	jne    803da7 <dhcp_fine_tmr+0xd6>
        netif->dhcp->request_timeout--;
  803d0e:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803d14:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803d17:	0f b6 02             	movzbl (%edx),%eax
  803d1a:	3c 0c                	cmp    $0xc,%al
  803d1c:	74 04                	je     803d22 <dhcp_fine_tmr+0x51>
  803d1e:	3c 06                	cmp    $0x6,%al
  803d20:	75 09                	jne    803d2b <dhcp_fine_tmr+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  803d22:	89 d8                	mov    %ebx,%eax
  803d24:	e8 ca f1 ff ff       	call   802ef3 <dhcp_discover>
  803d29:	eb 7c                	jmp    803da7 <dhcp_fine_tmr+0xd6>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  803d2b:	3c 01                	cmp    $0x1,%al
  803d2d:	75 24                	jne    803d53 <dhcp_fine_tmr+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  803d2f:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803d33:	77 09                	ja     803d3e <dhcp_fine_tmr+0x6d>
      dhcp_select(netif);
  803d35:	89 d8                	mov    %ebx,%eax
  803d37:	e8 f2 f2 ff ff       	call   80302e <dhcp_select>
  803d3c:	eb 69                	jmp    803da7 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  803d3e:	83 ec 0c             	sub    $0xc,%esp
  803d41:	53                   	push   %ebx
  803d42:	e8 49 fe ff ff       	call   803b90 <dhcp_release>
      dhcp_discover(netif);
  803d47:	89 d8                	mov    %ebx,%eax
  803d49:	e8 a5 f1 ff ff       	call   802ef3 <dhcp_discover>
  803d4e:	83 c4 10             	add    $0x10,%esp
  803d51:	eb 54                	jmp    803da7 <dhcp_fine_tmr+0xd6>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  803d53:	3c 08                	cmp    $0x8,%al
  803d55:	75 18                	jne    803d6f <dhcp_fine_tmr+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  803d57:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803d5b:	77 09                	ja     803d66 <dhcp_fine_tmr+0x95>
      dhcp_check(netif);
  803d5d:	89 d8                	mov    %ebx,%eax
  803d5f:	e8 42 f4 ff ff       	call   8031a6 <dhcp_check>
  803d64:	eb 41                	jmp    803da7 <dhcp_fine_tmr+0xd6>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  803d66:	89 d8                	mov    %ebx,%eax
  803d68:	e8 6d f4 ff ff       	call   8031da <dhcp_bind>
  803d6d:	eb 38                	jmp    803da7 <dhcp_fine_tmr+0xd6>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  803d6f:	3c 05                	cmp    $0x5,%al
  803d71:	75 0e                	jne    803d81 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  803d73:	83 ec 0c             	sub    $0xc,%esp
  803d76:	53                   	push   %ebx
  803d77:	e8 a1 fc ff ff       	call   803a1d <dhcp_renew>
  803d7c:	83 c4 10             	add    $0x10,%esp
  803d7f:	eb 26                	jmp    803da7 <dhcp_fine_tmr+0xd6>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  803d81:	3c 04                	cmp    $0x4,%al
  803d83:	75 22                	jne    803da7 <dhcp_fine_tmr+0xd6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  803d85:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803d89:	77 09                	ja     803d94 <dhcp_fine_tmr+0xc3>
      dhcp_rebind(netif);
  803d8b:	89 d8                	mov    %ebx,%eax
  803d8d:	e8 72 f0 ff ff       	call   802e04 <dhcp_rebind>
  803d92:	eb 13                	jmp    803da7 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  803d94:	83 ec 0c             	sub    $0xc,%esp
  803d97:	53                   	push   %ebx
  803d98:	e8 f3 fd ff ff       	call   803b90 <dhcp_release>
      dhcp_discover(netif);
  803d9d:	89 d8                	mov    %ebx,%eax
  803d9f:	e8 4f f1 ff ff       	call   802ef3 <dhcp_discover>
  803da4:	83 c4 10             	add    $0x10,%esp
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  803da7:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  803da9:	85 db                	test   %ebx,%ebx
  803dab:	0f 85 32 ff ff ff    	jne    803ce3 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  803db1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803db4:	c9                   	leave  
  803db5:	c3                   	ret    

00803db6 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  803db6:	55                   	push   %ebp
  803db7:	89 e5                	mov    %esp,%ebp
  803db9:	56                   	push   %esi
  803dba:	53                   	push   %ebx
  803dbb:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803dbe:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803dc1:	85 f6                	test   %esi,%esi
  803dc3:	75 17                	jne    803ddc <dhcp_stop+0x26>
  803dc5:	83 ec 04             	sub    $0x4,%esp
  803dc8:	68 54 15 81 00       	push   $0x811554
  803dcd:	68 2c 04 00 00       	push   $0x42c
  803dd2:	68 e2 14 81 00       	push   $0x8114e2
  803dd7:	e8 6e a6 00 00       	call   80e44a <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803ddc:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  803de0:	85 db                	test   %ebx,%ebx
  803de2:	74 4e                	je     803e32 <dhcp_stop+0x7c>
    if (dhcp->pcb != NULL) {
  803de4:	8b 43 08             	mov    0x8(%ebx),%eax
  803de7:	85 c0                	test   %eax,%eax
  803de9:	74 13                	je     803dfe <dhcp_stop+0x48>
      udp_remove(dhcp->pcb);
  803deb:	83 ec 0c             	sub    $0xc,%esp
  803dee:	50                   	push   %eax
  803def:	e8 3b 51 00 00       	call   808f2f <udp_remove>
      dhcp->pcb = NULL;
  803df4:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803dfb:	83 c4 10             	add    $0x10,%esp
    }
    if (dhcp->p != NULL) {
  803dfe:	8b 43 0c             	mov    0xc(%ebx),%eax
  803e01:	85 c0                	test   %eax,%eax
  803e03:	74 13                	je     803e18 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  803e05:	83 ec 0c             	sub    $0xc,%esp
  803e08:	50                   	push   %eax
  803e09:	e8 1c 0a 00 00       	call   80482a <pbuf_free>
      dhcp->p = NULL;
  803e0e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803e15:	83 c4 10             	add    $0x10,%esp
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  803e18:	89 d8                	mov    %ebx,%eax
  803e1a:	e8 46 f5 ff ff       	call   803365 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803e1f:	83 ec 0c             	sub    $0xc,%esp
  803e22:	53                   	push   %ebx
  803e23:	e8 60 01 00 00       	call   803f88 <mem_free>
    netif->dhcp = NULL;
  803e28:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803e2f:	83 c4 10             	add    $0x10,%esp
  }
}
  803e32:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e35:	5b                   	pop    %ebx
  803e36:	5e                   	pop    %esi
  803e37:	5d                   	pop    %ebp
  803e38:	c3                   	ret    

00803e39 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  803e39:	55                   	push   %ebp
  803e3a:	89 e5                	mov    %esp,%ebp
  803e3c:	56                   	push   %esi
  803e3d:	53                   	push   %ebx
  803e3e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e41:	85 db                	test   %ebx,%ebx
  803e43:	75 17                	jne    803e5c <dhcp_start+0x23>
  803e45:	83 ec 04             	sub    $0x4,%esp
  803e48:	68 02 15 81 00       	push   $0x811502
  803e4d:	68 38 02 00 00       	push   $0x238
  803e52:	68 e2 14 81 00       	push   $0x8114e2
  803e57:	e8 ee a5 00 00       	call   80e44a <_panic>
  dhcp = netif->dhcp;
  803e5c:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e5f:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  803e63:	85 f6                	test   %esi,%esi
  803e65:	75 1a                	jne    803e81 <dhcp_start+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  803e67:	83 ec 0c             	sub    $0xc,%esp
  803e6a:	6a 58                	push   $0x58
  803e6c:	e8 c9 03 00 00       	call   80423a <mem_malloc>
  803e71:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803e73:	83 c4 10             	add    $0x10,%esp
  803e76:	85 c0                	test   %eax,%eax
  803e78:	0f 84 98 00 00 00    	je     803f16 <dhcp_start+0xdd>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  803e7e:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  803e81:	83 ec 04             	sub    $0x4,%esp
  803e84:	6a 58                	push   $0x58
  803e86:	6a 00                	push   $0x0
  803e88:	56                   	push   %esi
  803e89:	e8 5f ad 00 00       	call   80ebed <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  803e8e:	e8 e0 50 00 00       	call   808f73 <udp_new>
  803e93:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803e96:	83 c4 10             	add    $0x10,%esp
  803e99:	85 c0                	test   %eax,%eax
  803e9b:	75 1a                	jne    803eb7 <dhcp_start+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  803e9d:	83 ec 0c             	sub    $0xc,%esp
  803ea0:	56                   	push   %esi
  803ea1:	e8 e2 00 00 00       	call   803f88 <mem_free>
    netif->dhcp = dhcp = NULL;
  803ea6:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803ead:	83 c4 10             	add    $0x10,%esp
  803eb0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803eb5:	eb 64                	jmp    803f1b <dhcp_start+0xe2>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803eb7:	83 ec 04             	sub    $0x4,%esp
  803eba:	6a 44                	push   $0x44
  803ebc:	68 a4 1d 81 00       	push   $0x811da4
  803ec1:	50                   	push   %eax
  803ec2:	e8 26 4d 00 00       	call   808bed <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ec7:	83 c4 0c             	add    $0xc,%esp
  803eca:	6a 43                	push   $0x43
  803ecc:	68 a4 1d 81 00       	push   $0x811da4
  803ed1:	ff 76 08             	pushl  0x8(%esi)
  803ed4:	e8 b6 4f 00 00       	call   808e8f <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803ed9:	83 c4 0c             	add    $0xc,%esp
  803edc:	53                   	push   %ebx
  803edd:	68 ad 33 80 00       	push   $0x8033ad
  803ee2:	ff 76 08             	pushl  0x8(%esi)
  803ee5:	e8 31 50 00 00       	call   808f1b <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  803eea:	89 d8                	mov    %ebx,%eax
  803eec:	e8 02 f0 ff ff       	call   802ef3 <dhcp_discover>
  if (result != ERR_OK) {
  803ef1:	83 c4 10             	add    $0x10,%esp
  803ef4:	84 c0                	test   %al,%al
  803ef6:	74 13                	je     803f0b <dhcp_start+0xd2>
    /* free resources allocated above */
    dhcp_stop(netif);
  803ef8:	83 ec 0c             	sub    $0xc,%esp
  803efb:	53                   	push   %ebx
  803efc:	e8 b5 fe ff ff       	call   803db6 <dhcp_stop>
    return ERR_MEM;
  803f01:	83 c4 10             	add    $0x10,%esp
  803f04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f09:	eb 10                	jmp    803f1b <dhcp_start+0xe2>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  803f0b:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  803f0f:	b8 00 00 00 00       	mov    $0x0,%eax
  803f14:	eb 05                	jmp    803f1b <dhcp_start+0xe2>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  803f16:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  803f1b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803f1e:	5b                   	pop    %ebx
  803f1f:	5e                   	pop    %esi
  803f20:	5d                   	pop    %ebp
  803f21:	c3                   	ret    

00803f22 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803f22:	55                   	push   %ebp
  803f23:	89 e5                	mov    %esp,%ebp
  803f25:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803f28:	b8 23 53 81 00       	mov    $0x815323,%eax
  803f2d:	83 e0 fc             	and    $0xfffffffc,%eax
  803f30:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803f35:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803f3b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803f42:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803f46:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803f4c:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803f52:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803f59:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803f60:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803f63:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803f6a:	00 22 00 

  mem_sem = sys_sem_new(1);
  803f6d:	6a 01                	push   $0x1
  803f6f:	e8 bd 5d 00 00       	call   809d31 <sys_sem_new>
  803f74:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803f79:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803f7e:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803f83:	83 c4 10             	add    $0x10,%esp
  803f86:	c9                   	leave  
  803f87:	c3                   	ret    

00803f88 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803f88:	55                   	push   %ebp
  803f89:	89 e5                	mov    %esp,%ebp
  803f8b:	56                   	push   %esi
  803f8c:	53                   	push   %ebx
  803f8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f90:	85 db                	test   %ebx,%ebx
  803f92:	0f 84 52 01 00 00    	je     8040ea <mem_free+0x162>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f98:	f6 c3 03             	test   $0x3,%bl
  803f9b:	74 17                	je     803fb4 <mem_free+0x2c>
  803f9d:	83 ec 04             	sub    $0x4,%esp
  803fa0:	68 70 15 81 00       	push   $0x811570
  803fa5:	68 30 01 00 00       	push   $0x130
  803faa:	68 67 16 81 00       	push   $0x811667
  803faf:	e8 96 a4 00 00       	call   80e44a <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803fb4:	3b 1d 0c 53 81 00    	cmp    0x81530c,%ebx
  803fba:	72 08                	jb     803fc4 <mem_free+0x3c>
  803fbc:	3b 1d 08 53 81 00    	cmp    0x815308,%ebx
  803fc2:	72 17                	jb     803fdb <mem_free+0x53>
  803fc4:	83 ec 04             	sub    $0x4,%esp
  803fc7:	68 7b 16 81 00       	push   $0x81167b
  803fcc:	68 33 01 00 00       	push   $0x133
  803fd1:	68 67 16 81 00       	push   $0x811667
  803fd6:	e8 6f a4 00 00       	call   80e44a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803fdb:	83 ec 08             	sub    $0x8,%esp
  803fde:	6a 00                	push   $0x0
  803fe0:	ff 35 00 53 81 00    	pushl  0x815300
  803fe6:	e8 60 60 00 00       	call   80a04b <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803feb:	83 c4 10             	add    $0x10,%esp
  803fee:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803ff2:	75 17                	jne    80400b <mem_free+0x83>
  803ff4:	83 ec 04             	sub    $0x4,%esp
  803ff7:	68 92 16 81 00       	push   $0x811692
  803ffc:	68 43 01 00 00       	push   $0x143
  804001:	68 67 16 81 00       	push   $0x811667
  804006:	e8 3f a4 00 00       	call   80e44a <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80400b:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  80400e:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804012:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  804018:	73 06                	jae    804020 <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80401a:	89 15 04 53 81 00    	mov    %edx,0x815304
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804020:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  804026:	39 ca                	cmp    %ecx,%edx
  804028:	73 17                	jae    804041 <mem_free+0xb9>
  80402a:	83 ec 04             	sub    $0x4,%esp
  80402d:	68 a6 16 81 00       	push   $0x8116a6
  804032:	68 e3 00 00 00       	push   $0xe3
  804037:	68 67 16 81 00       	push   $0x811667
  80403c:	e8 09 a4 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804041:	8b 35 08 53 81 00    	mov    0x815308,%esi
  804047:	39 f2                	cmp    %esi,%edx
  804049:	72 17                	jb     804062 <mem_free+0xda>
  80404b:	83 ec 04             	sub    $0x4,%esp
  80404e:	68 bd 16 81 00       	push   $0x8116bd
  804053:	68 e4 00 00 00       	push   $0xe4
  804058:	68 67 16 81 00       	push   $0x811667
  80405d:	e8 e8 a3 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804062:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804065:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80406a:	76 17                	jbe    804083 <mem_free+0xfb>
  80406c:	83 ec 04             	sub    $0x4,%esp
  80406f:	68 94 15 81 00       	push   $0x811594
  804074:	68 e8 00 00 00       	push   $0xe8
  804079:	68 67 16 81 00       	push   $0x811667
  80407e:	e8 c7 a3 00 00       	call   80e44a <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804083:	01 c8                	add    %ecx,%eax
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804085:	39 c2                	cmp    %eax,%edx
  804087:	74 27                	je     8040b0 <mem_free+0x128>
  804089:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  80408d:	75 21                	jne    8040b0 <mem_free+0x128>
  80408f:	39 c6                	cmp    %eax,%esi
  804091:	74 1d                	je     8040b0 <mem_free+0x128>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  804093:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  804099:	75 06                	jne    8040a1 <mem_free+0x119>
      lfree = mem;
  80409b:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem->next = nmem->next;
  8040a1:	8b 30                	mov    (%eax),%esi
  8040a3:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8040a6:	8b 00                	mov    (%eax),%eax
  8040a8:	89 d6                	mov    %edx,%esi
  8040aa:	29 ce                	sub    %ecx,%esi
  8040ac:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8040b0:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8040b3:	8d 04 31             	lea    (%ecx,%esi,1),%eax
  if (pmem != mem && pmem->used == 0) {
  8040b6:	39 c2                	cmp    %eax,%edx
  8040b8:	74 1f                	je     8040d9 <mem_free+0x151>
  8040ba:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  8040be:	75 19                	jne    8040d9 <mem_free+0x151>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8040c0:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8040c6:	75 05                	jne    8040cd <mem_free+0x145>
      lfree = pmem;
  8040c8:	a3 04 53 81 00       	mov    %eax,0x815304
    }
    pmem->next = mem->next;
  8040cd:	8b 53 f4             	mov    -0xc(%ebx),%edx
  8040d0:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8040d2:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040d5:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8040d9:	83 ec 0c             	sub    $0xc,%esp
  8040dc:	ff 35 00 53 81 00    	pushl  0x815300
  8040e2:	e8 f6 5e 00 00       	call   809fdd <sys_sem_signal>
  8040e7:	83 c4 10             	add    $0x10,%esp
}
  8040ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8040ed:	5b                   	pop    %ebx
  8040ee:	5e                   	pop    %esi
  8040ef:	5d                   	pop    %ebp
  8040f0:	c3                   	ret    

008040f1 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8040f1:	55                   	push   %ebp
  8040f2:	89 e5                	mov    %esp,%ebp
  8040f4:	57                   	push   %edi
  8040f5:	56                   	push   %esi
  8040f6:	53                   	push   %ebx
  8040f7:	83 ec 1c             	sub    $0x1c,%esp
  8040fa:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8040fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  804100:	8d 58 03             	lea    0x3(%eax),%ebx
  804103:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  804106:	83 fb 0b             	cmp    $0xb,%ebx
  804109:	76 0d                	jbe    804118 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80410b:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  804111:	76 0a                	jbe    80411d <mem_realloc+0x2c>
  804113:	e9 15 01 00 00       	jmp    80422d <mem_realloc+0x13c>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  804118:	bb 0c 00 00 00       	mov    $0xc,%ebx

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80411d:	a1 0c 53 81 00       	mov    0x81530c,%eax
  804122:	39 f0                	cmp    %esi,%eax
  804124:	77 08                	ja     80412e <mem_realloc+0x3d>
  804126:	3b 35 08 53 81 00    	cmp    0x815308,%esi
  80412c:	72 17                	jb     804145 <mem_realloc+0x54>
  80412e:	83 ec 04             	sub    $0x4,%esp
  804131:	68 d7 16 81 00       	push   $0x8116d7
  804136:	68 79 01 00 00       	push   $0x179
  80413b:	68 67 16 81 00       	push   $0x811667
  804140:	e8 05 a3 00 00       	call   80e44a <_panic>
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804145:	8d 56 f4             	lea    -0xc(%esi),%edx
  804148:	29 c2                	sub    %eax,%edx
  80414a:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80414d:	8b 46 f4             	mov    -0xc(%esi),%eax
  804150:	8d 78 f4             	lea    -0xc(%eax),%edi
  804153:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804155:	39 df                	cmp    %ebx,%edi
  804157:	73 17                	jae    804170 <mem_realloc+0x7f>
  804159:	83 ec 04             	sub    $0x4,%esp
  80415c:	68 c0 15 81 00       	push   $0x8115c0
  804161:	68 8a 01 00 00       	push   $0x18a
  804166:	68 67 16 81 00       	push   $0x811667
  80416b:	e8 da a2 00 00       	call   80e44a <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  804170:	89 f0                	mov    %esi,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804172:	39 df                	cmp    %ebx,%edi
  804174:	0f 84 b8 00 00 00    	je     804232 <mem_realloc+0x141>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80417a:	83 ec 08             	sub    $0x8,%esp
  80417d:	6a 00                	push   $0x0
  80417f:	ff 35 00 53 81 00    	pushl  0x815300
  804185:	e8 c1 5e 00 00       	call   80a04b <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80418a:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80418f:	89 c2                	mov    %eax,%edx
  804191:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804194:	83 c4 10             	add    $0x10,%esp
  804197:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80419b:	75 3c                	jne    8041d9 <mem_realloc+0xe8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80419d:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80419f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041a2:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  8041a6:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8041ac:	75 09                	jne    8041b7 <mem_realloc+0xc6>
      lfree = (struct mem *)&ram[ptr2];
  8041ae:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8041b1:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2 = (struct mem *)&ram[ptr2];
  8041b7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8041ba:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8041be:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8041c0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041c3:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8041c6:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041c9:	8b 12                	mov    (%edx),%edx
  8041cb:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041d1:	74 45                	je     804218 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041d3:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  8041d7:	eb 3f                	jmp    804218 <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8041d9:	8d 53 18             	lea    0x18(%ebx),%edx
  8041dc:	39 d7                	cmp    %edx,%edi
  8041de:	72 38                	jb     804218 <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041e0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041e3:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8041e7:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8041ea:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8041f0:	73 06                	jae    8041f8 <mem_realloc+0x107>
      lfree = mem2;
  8041f2:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2->used = 0;
  8041f8:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8041fc:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8041ff:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  804201:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804204:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804207:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80420a:	8b 12                	mov    (%edx),%edx
  80420c:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804212:	74 04                	je     804218 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804214:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804218:	83 ec 0c             	sub    $0xc,%esp
  80421b:	ff 35 00 53 81 00    	pushl  0x815300
  804221:	e8 b7 5d 00 00       	call   809fdd <sys_sem_signal>
  return rmem;
  804226:	83 c4 10             	add    $0x10,%esp
  804229:	89 f0                	mov    %esi,%eax
  80422b:	eb 05                	jmp    804232 <mem_realloc+0x141>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  80422d:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  804232:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804235:	5b                   	pop    %ebx
  804236:	5e                   	pop    %esi
  804237:	5f                   	pop    %edi
  804238:	5d                   	pop    %ebp
  804239:	c3                   	ret    

0080423a <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80423a:	55                   	push   %ebp
  80423b:	89 e5                	mov    %esp,%ebp
  80423d:	57                   	push   %edi
  80423e:	56                   	push   %esi
  80423f:	53                   	push   %ebx
  804240:	83 ec 1c             	sub    $0x1c,%esp
  804243:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804246:	85 f6                	test   %esi,%esi
  804248:	0f 84 72 01 00 00    	je     8043c0 <mem_malloc+0x186>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80424e:	83 c6 03             	add    $0x3,%esi
  804251:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  804254:	83 fe 0b             	cmp    $0xb,%esi
  804257:	76 0d                	jbe    804266 <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804259:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  80425f:	76 0a                	jbe    80426b <mem_malloc+0x31>
  804261:	e9 61 01 00 00       	jmp    8043c7 <mem_malloc+0x18d>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  804266:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80426b:	83 ec 08             	sub    $0x8,%esp
  80426e:	6a 00                	push   $0x0
  804270:	ff 35 00 53 81 00    	pushl  0x815300
  804276:	e8 d0 5d 00 00       	call   80a04b <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80427b:	8b 15 0c 53 81 00    	mov    0x81530c,%edx
  804281:	a1 04 53 81 00       	mov    0x815304,%eax
  804286:	29 d0                	sub    %edx,%eax
  804288:	83 c4 10             	add    $0x10,%esp
  80428b:	bf 00 00 22 00       	mov    $0x220000,%edi
  804290:	29 f7                	sub    %esi,%edi
  804292:	e9 09 01 00 00       	jmp    8043a0 <mem_malloc+0x166>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  804297:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80429a:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  80429e:	0f 85 fa 00 00 00    	jne    80439e <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  8042a4:	8b 0b                	mov    (%ebx),%ecx
  8042a6:	83 e9 0c             	sub    $0xc,%ecx
  8042a9:	29 c1                	sub    %eax,%ecx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8042ab:	39 f1                	cmp    %esi,%ecx
  8042ad:	0f 82 eb 00 00 00    	jb     80439e <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8042b3:	8d 7e 18             	lea    0x18(%esi),%edi
  8042b6:	39 f9                	cmp    %edi,%ecx
  8042b8:	72 2d                	jb     8042e7 <mem_malloc+0xad>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8042ba:	8d 7c 30 0c          	lea    0xc(%eax,%esi,1),%edi
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8042be:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8042c1:	8d 0c 3a             	lea    (%edx,%edi,1),%ecx
          mem2->used = 0;
  8042c4:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  8042c8:	8b 3b                	mov    (%ebx),%edi
  8042ca:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  8042cc:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8042cf:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042d2:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  8042d4:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8042d8:	8b 01                	mov    (%ecx),%eax
  8042da:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8042df:	74 0a                	je     8042eb <mem_malloc+0xb1>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8042e1:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  8042e5:	eb 04                	jmp    8042eb <mem_malloc+0xb1>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8042e7:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8042eb:	a1 04 53 81 00       	mov    0x815304,%eax
  8042f0:	39 c3                	cmp    %eax,%ebx
  8042f2:	75 3c                	jne    804330 <mem_malloc+0xf6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8042f4:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8042fa:	8b 3d 0c 53 81 00    	mov    0x81530c,%edi
  804300:	ba 00 00 00 00       	mov    $0x0,%edx
  804305:	eb 0b                	jmp    804312 <mem_malloc+0xd8>
  804307:	89 fa                	mov    %edi,%edx
  804309:	03 10                	add    (%eax),%edx
  80430b:	89 d0                	mov    %edx,%eax
  80430d:	ba 01 00 00 00       	mov    $0x1,%edx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  804312:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804316:	75 0b                	jne    804323 <mem_malloc+0xe9>
  804318:	84 d2                	test   %dl,%dl
  80431a:	74 14                	je     804330 <mem_malloc+0xf6>
  80431c:	a3 04 53 81 00       	mov    %eax,0x815304
  804321:	eb 0d                	jmp    804330 <mem_malloc+0xf6>
  804323:	39 c1                	cmp    %eax,%ecx
  804325:	75 e0                	jne    804307 <mem_malloc+0xcd>
  804327:	84 d2                	test   %dl,%dl
  804329:	74 05                	je     804330 <mem_malloc+0xf6>
  80432b:	a3 04 53 81 00       	mov    %eax,0x815304
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804330:	83 ec 0c             	sub    $0xc,%esp
  804333:	ff 35 00 53 81 00    	pushl  0x815300
  804339:	e8 9f 5c 00 00       	call   809fdd <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80433e:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  804342:	83 c4 10             	add    $0x10,%esp
  804345:	39 05 08 53 81 00    	cmp    %eax,0x815308
  80434b:	73 17                	jae    804364 <mem_malloc+0x12a>
  80434d:	83 ec 04             	sub    $0x4,%esp
  804350:	68 e4 15 81 00       	push   $0x8115e4
  804355:	68 4b 02 00 00       	push   $0x24b
  80435a:	68 67 16 81 00       	push   $0x811667
  80435f:	e8 e6 a0 00 00       	call   80e44a <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804364:	8d 43 0c             	lea    0xc(%ebx),%eax
  804367:	a8 03                	test   $0x3,%al
  804369:	74 17                	je     804382 <mem_malloc+0x148>
  80436b:	83 ec 04             	sub    $0x4,%esp
  80436e:	68 14 16 81 00       	push   $0x811614
  804373:	68 4d 02 00 00       	push   $0x24d
  804378:	68 67 16 81 00       	push   $0x811667
  80437d:	e8 c8 a0 00 00       	call   80e44a <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804382:	f6 c3 03             	test   $0x3,%bl
  804385:	74 45                	je     8043cc <mem_malloc+0x192>
  804387:	83 ec 04             	sub    $0x4,%esp
  80438a:	68 44 16 81 00       	push   $0x811644
  80438f:	68 4f 02 00 00       	push   $0x24f
  804394:	68 67 16 81 00       	push   $0x811667
  804399:	e8 ac a0 00 00       	call   80e44a <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80439e:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8043a0:	39 f8                	cmp    %edi,%eax
  8043a2:	0f 82 ef fe ff ff    	jb     804297 <mem_malloc+0x5d>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8043a8:	83 ec 0c             	sub    $0xc,%esp
  8043ab:	ff 35 00 53 81 00    	pushl  0x815300
  8043b1:	e8 27 5c 00 00       	call   809fdd <sys_sem_signal>
  return NULL;
  8043b6:	83 c4 10             	add    $0x10,%esp
  8043b9:	b8 00 00 00 00       	mov    $0x0,%eax
  8043be:	eb 0c                	jmp    8043cc <mem_malloc+0x192>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  8043c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8043c5:	eb 05                	jmp    8043cc <mem_malloc+0x192>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  8043c7:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  8043cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8043cf:	5b                   	pop    %ebx
  8043d0:	5e                   	pop    %esi
  8043d1:	5f                   	pop    %edi
  8043d2:	5d                   	pop    %ebp
  8043d3:	c3                   	ret    

008043d4 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8043d4:	55                   	push   %ebp
  8043d5:	89 e5                	mov    %esp,%ebp
  8043d7:	56                   	push   %esi
  8043d8:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8043d9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8043dc:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8043e0:	83 ec 0c             	sub    $0xc,%esp
  8043e3:	53                   	push   %ebx
  8043e4:	e8 51 fe ff ff       	call   80423a <mem_malloc>
  8043e9:	89 c6                	mov    %eax,%esi
  if (p) {
  8043eb:	83 c4 10             	add    $0x10,%esp
  8043ee:	85 c0                	test   %eax,%eax
  8043f0:	74 0f                	je     804401 <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8043f2:	83 ec 04             	sub    $0x4,%esp
  8043f5:	53                   	push   %ebx
  8043f6:	6a 00                	push   $0x0
  8043f8:	50                   	push   %eax
  8043f9:	e8 ef a7 00 00       	call   80ebed <memset>
  8043fe:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  804401:	89 f0                	mov    %esi,%eax
  804403:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804406:	5b                   	pop    %ebx
  804407:	5e                   	pop    %esi
  804408:	5d                   	pop    %ebp
  804409:	c3                   	ret    

0080440a <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80440a:	55                   	push   %ebp
  80440b:	89 e5                	mov    %esp,%ebp
  80440d:	57                   	push   %edi
  80440e:	56                   	push   %esi
  80440f:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  804410:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  804415:	83 e0 fc             	and    $0xfffffffc,%eax
  804418:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  80441d:	c7 84 12 c0 43 b3 00 	movl   $0x0,0xb343c0(%edx,%edx,1)
  804424:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804428:	0f b7 b2 68 17 81 00 	movzwl 0x811768(%edx),%esi
  80442f:	b9 00 00 00 00       	mov    $0x0,%ecx
  804434:	eb 19                	jmp    80444f <memp_init+0x45>
      memp->next = memp_tab[i];
  804436:	bb c0 43 b3 00       	mov    $0xb343c0,%ebx
  80443b:	8b 3c 53             	mov    (%ebx,%edx,2),%edi
  80443e:	89 38                	mov    %edi,(%eax)
      memp_tab[i] = memp;
  804440:	89 04 53             	mov    %eax,(%ebx,%edx,2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804443:	0f b7 9a 84 17 81 00 	movzwl 0x811784(%edx),%ebx
  80444a:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80444c:	83 c1 01             	add    $0x1,%ecx
  80444f:	66 39 f1             	cmp    %si,%cx
  804452:	75 e2                	jne    804436 <memp_init+0x2c>
  804454:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804457:	83 fa 1c             	cmp    $0x1c,%edx
  80445a:	75 c1                	jne    80441d <memp_init+0x13>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80445c:	5b                   	pop    %ebx
  80445d:	5e                   	pop    %esi
  80445e:	5f                   	pop    %edi
  80445f:	5d                   	pop    %ebp
  804460:	c3                   	ret    

00804461 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804461:	55                   	push   %ebp
  804462:	89 e5                	mov    %esp,%ebp
  804464:	83 ec 08             	sub    $0x8,%esp
  804467:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80446a:	83 fa 0d             	cmp    $0xd,%edx
  80446d:	76 17                	jbe    804486 <memp_malloc+0x25>
  80446f:	83 ec 04             	sub    $0x4,%esp
  804472:	68 f1 16 81 00       	push   $0x8116f1
  804477:	68 2d 01 00 00       	push   $0x12d
  80447c:	68 0e 17 81 00       	push   $0x81170e
  804481:	e8 c4 9f 00 00       	call   80e44a <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804486:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  80448d:	85 c0                	test   %eax,%eax
  80448f:	74 24                	je     8044b5 <memp_malloc+0x54>
    memp_tab[type] = memp->next;    
  804491:	8b 08                	mov    (%eax),%ecx
  804493:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80449a:	a8 03                	test   $0x3,%al
  80449c:	74 17                	je     8044b5 <memp_malloc+0x54>
  80449e:	83 ec 04             	sub    $0x4,%esp
  8044a1:	68 24 17 81 00       	push   $0x811724
  8044a6:	68 3f 01 00 00       	push   $0x13f
  8044ab:	68 0e 17 81 00       	push   $0x81170e
  8044b0:	e8 95 9f 00 00       	call   80e44a <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8044b5:	c9                   	leave  
  8044b6:	c3                   	ret    

008044b7 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8044b7:	55                   	push   %ebp
  8044b8:	89 e5                	mov    %esp,%ebp
  8044ba:	83 ec 08             	sub    $0x8,%esp
  8044bd:	8b 55 08             	mov    0x8(%ebp),%edx
  8044c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8044c3:	85 c0                	test   %eax,%eax
  8044c5:	74 2b                	je     8044f2 <memp_free+0x3b>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044c7:	a8 03                	test   $0x3,%al
  8044c9:	74 17                	je     8044e2 <memp_free+0x2b>
  8044cb:	83 ec 04             	sub    $0x4,%esp
  8044ce:	68 48 17 81 00       	push   $0x811748
  8044d3:	68 5b 01 00 00       	push   $0x15b
  8044d8:	68 0e 17 81 00       	push   $0x81170e
  8044dd:	e8 68 9f 00 00       	call   80e44a <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8044e2:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8044e9:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8044eb:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8044f2:	c9                   	leave  
  8044f3:	c3                   	ret    

008044f4 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8044f4:	55                   	push   %ebp
  8044f5:	89 e5                	mov    %esp,%ebp
  8044f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8044fa:	85 c9                	test   %ecx,%ecx
  8044fc:	74 38                	je     804536 <netif_remove+0x42>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8044fe:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804503:	39 c1                	cmp    %eax,%ecx
  804505:	75 17                	jne    80451e <netif_remove+0x2a>
    netif_list = netif->next;
  804507:	8b 01                	mov    (%ecx),%eax
  804509:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  80450e:	eb 14                	jmp    804524 <netif_remove+0x30>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804510:	8b 10                	mov    (%eax),%edx
  804512:	39 d1                	cmp    %edx,%ecx
  804514:	75 06                	jne    80451c <netif_remove+0x28>
        tmpNetif->next = netif->next;
  804516:	8b 11                	mov    (%ecx),%edx
  804518:	89 10                	mov    %edx,(%eax)
  80451a:	eb 08                	jmp    804524 <netif_remove+0x30>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80451c:	89 d0                	mov    %edx,%eax
  80451e:	85 c0                	test   %eax,%eax
  804520:	75 ee                	jne    804510 <netif_remove+0x1c>
  804522:	eb 12                	jmp    804536 <netif_remove+0x42>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804524:	3b 0d 38 b2 b3 00    	cmp    0xb3b238,%ecx
  80452a:	75 0a                	jne    804536 <netif_remove+0x42>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80452c:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  804533:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804536:	5d                   	pop    %ebp
  804537:	c3                   	ret    

00804538 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804538:	55                   	push   %ebp
  804539:	89 e5                	mov    %esp,%ebp
  80453b:	53                   	push   %ebx
  80453c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80453f:	85 c9                	test   %ecx,%ecx
  804541:	74 2c                	je     80456f <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  804543:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804547:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80454a:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80454f:	eb 18                	jmp    804569 <netif_find+0x31>
    if (num == netif->num &&
  804551:	3a 50 31             	cmp    0x31(%eax),%dl
  804554:	75 11                	jne    804567 <netif_find+0x2f>
  804556:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  80455a:	38 19                	cmp    %bl,(%ecx)
  80455c:	75 09                	jne    804567 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  80455e:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804562:	38 59 01             	cmp    %bl,0x1(%ecx)
  804565:	74 0d                	je     804574 <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804567:	8b 00                	mov    (%eax),%eax
  804569:	85 c0                	test   %eax,%eax
  80456b:	75 e4                	jne    804551 <netif_find+0x19>
  80456d:	eb 05                	jmp    804574 <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  80456f:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804574:	5b                   	pop    %ebx
  804575:	5d                   	pop    %ebp
  804576:	c3                   	ret    

00804577 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804577:	55                   	push   %ebp
  804578:	89 e5                	mov    %esp,%ebp
  80457a:	57                   	push   %edi
  80457b:	56                   	push   %esi
  80457c:	53                   	push   %ebx
  80457d:	83 ec 0c             	sub    $0xc,%esp
  804580:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804583:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804586:	8b 43 04             	mov    0x4(%ebx),%eax
  804589:	39 06                	cmp    %eax,(%esi)
  80458b:	74 54                	je     8045e1 <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80458d:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  804592:	eb 1d                	jmp    8045b1 <netif_set_ipaddr+0x3a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804594:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804597:	39 08                	cmp    %ecx,(%eax)
  804599:	75 13                	jne    8045ae <netif_set_ipaddr+0x37>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80459b:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80459e:	83 ec 0c             	sub    $0xc,%esp
  8045a1:	50                   	push   %eax
  8045a2:	e8 42 16 00 00       	call   805be9 <tcp_abort>
  8045a7:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8045aa:	89 f8                	mov    %edi,%eax
  8045ac:	eb 03                	jmp    8045b1 <netif_set_ipaddr+0x3a>
      } else {
        pcb = pcb->next;
  8045ae:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  8045b1:	85 c0                	test   %eax,%eax
  8045b3:	75 df                	jne    804594 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045b5:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8045ba:	eb 21                	jmp    8045dd <netif_set_ipaddr+0x66>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8045bc:	85 c0                	test   %eax,%eax
  8045be:	74 1a                	je     8045da <netif_set_ipaddr+0x63>
  8045c0:	8b 10                	mov    (%eax),%edx
  8045c2:	85 d2                	test   %edx,%edx
  8045c4:	74 14                	je     8045da <netif_set_ipaddr+0x63>
  8045c6:	3b 53 04             	cmp    0x4(%ebx),%edx
  8045c9:	75 0f                	jne    8045da <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8045cb:	85 f6                	test   %esi,%esi
  8045cd:	74 04                	je     8045d3 <netif_set_ipaddr+0x5c>
  8045cf:	8b 16                	mov    (%esi),%edx
  8045d1:	eb 05                	jmp    8045d8 <netif_set_ipaddr+0x61>
  8045d3:	ba 00 00 00 00       	mov    $0x0,%edx
  8045d8:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045da:	8b 40 0c             	mov    0xc(%eax),%eax
  8045dd:	85 c0                	test   %eax,%eax
  8045df:	75 db                	jne    8045bc <netif_set_ipaddr+0x45>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8045e1:	85 f6                	test   %esi,%esi
  8045e3:	74 04                	je     8045e9 <netif_set_ipaddr+0x72>
  8045e5:	8b 06                	mov    (%esi),%eax
  8045e7:	eb 05                	jmp    8045ee <netif_set_ipaddr+0x77>
  8045e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8045ee:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  8045f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045f4:	5b                   	pop    %ebx
  8045f5:	5e                   	pop    %esi
  8045f6:	5f                   	pop    %edi
  8045f7:	5d                   	pop    %ebp
  8045f8:	c3                   	ret    

008045f9 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  8045f9:	55                   	push   %ebp
  8045fa:	89 e5                	mov    %esp,%ebp
  8045fc:	57                   	push   %edi
  8045fd:	56                   	push   %esi
  8045fe:	53                   	push   %ebx
  8045ff:	83 ec 14             	sub    $0x14,%esp
  804602:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804605:	8b 7d 10             	mov    0x10(%ebp),%edi
  804608:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  80460b:	ff 75 0c             	pushl  0xc(%ebp)
  80460e:	53                   	push   %ebx
  80460f:	e8 63 ff ff ff       	call   804577 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804614:	83 c4 10             	add    $0x10,%esp
  804617:	85 ff                	test   %edi,%edi
  804619:	74 04                	je     80461f <netif_set_addr+0x26>
  80461b:	8b 07                	mov    (%edi),%eax
  80461d:	eb 05                	jmp    804624 <netif_set_addr+0x2b>
  80461f:	b8 00 00 00 00       	mov    $0x0,%eax
  804624:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804627:	85 f6                	test   %esi,%esi
  804629:	74 04                	je     80462f <netif_set_addr+0x36>
  80462b:	8b 06                	mov    (%esi),%eax
  80462d:	eb 05                	jmp    804634 <netif_set_addr+0x3b>
  80462f:	b8 00 00 00 00       	mov    $0x0,%eax
  804634:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804637:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80463a:	5b                   	pop    %ebx
  80463b:	5e                   	pop    %esi
  80463c:	5f                   	pop    %edi
  80463d:	5d                   	pop    %ebp
  80463e:	c3                   	ret    

0080463f <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80463f:	55                   	push   %ebp
  804640:	89 e5                	mov    %esp,%ebp
  804642:	53                   	push   %ebx
  804643:	83 ec 04             	sub    $0x4,%esp
  804646:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804649:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804650:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804657:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80465e:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804662:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804669:	8b 45 18             	mov    0x18(%ebp),%eax
  80466c:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  80466f:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804676:	8d 50 01             	lea    0x1(%eax),%edx
  804679:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  80467f:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804682:	8b 45 20             	mov    0x20(%ebp),%eax
  804685:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804688:	ff 75 14             	pushl  0x14(%ebp)
  80468b:	ff 75 10             	pushl  0x10(%ebp)
  80468e:	ff 75 0c             	pushl  0xc(%ebp)
  804691:	53                   	push   %ebx
  804692:	e8 62 ff ff ff       	call   8045f9 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804697:	89 1c 24             	mov    %ebx,(%esp)
  80469a:	ff 55 1c             	call   *0x1c(%ebp)
  80469d:	83 c4 10             	add    $0x10,%esp
  8046a0:	84 c0                	test   %al,%al
  8046a2:	75 11                	jne    8046b5 <netif_add+0x76>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  8046a4:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8046a9:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8046ab:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  8046b1:	89 d8                	mov    %ebx,%eax
  8046b3:	eb 05                	jmp    8046ba <netif_add+0x7b>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  8046b5:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  8046ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8046bd:	c9                   	leave  
  8046be:	c3                   	ret    

008046bf <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8046bf:	55                   	push   %ebp
  8046c0:	89 e5                	mov    %esp,%ebp
  8046c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  8046c5:	85 c0                	test   %eax,%eax
  8046c7:	74 04                	je     8046cd <netif_set_gw+0xe>
  8046c9:	8b 10                	mov    (%eax),%edx
  8046cb:	eb 05                	jmp    8046d2 <netif_set_gw+0x13>
  8046cd:	ba 00 00 00 00       	mov    $0x0,%edx
  8046d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8046d5:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  8046d8:	5d                   	pop    %ebp
  8046d9:	c3                   	ret    

008046da <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  8046da:	55                   	push   %ebp
  8046db:	89 e5                	mov    %esp,%ebp
  8046dd:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8046e0:	85 c0                	test   %eax,%eax
  8046e2:	74 04                	je     8046e8 <netif_set_netmask+0xe>
  8046e4:	8b 10                	mov    (%eax),%edx
  8046e6:	eb 05                	jmp    8046ed <netif_set_netmask+0x13>
  8046e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8046ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8046f0:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  8046f3:	5d                   	pop    %ebp
  8046f4:	c3                   	ret    

008046f5 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  8046f5:	55                   	push   %ebp
  8046f6:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8046f8:	8b 45 08             	mov    0x8(%ebp),%eax
  8046fb:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804700:	5d                   	pop    %ebp
  804701:	c3                   	ret    

00804702 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804702:	55                   	push   %ebp
  804703:	89 e5                	mov    %esp,%ebp
  804705:	83 ec 08             	sub    $0x8,%esp
  804708:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80470b:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80470f:	a8 01                	test   $0x1,%al
  804711:	75 1e                	jne    804731 <netif_set_up+0x2f>
    netif->flags |= NETIF_FLAG_UP;
  804713:	89 c1                	mov    %eax,%ecx
  804715:	83 c9 01             	or     $0x1,%ecx
  804718:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80471b:	a8 20                	test   $0x20,%al
  80471d:	74 12                	je     804731 <netif_set_up+0x2f>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80471f:	83 ec 04             	sub    $0x4,%esp
  804722:	6a 00                	push   $0x0
  804724:	8d 42 04             	lea    0x4(%edx),%eax
  804727:	50                   	push   %eax
  804728:	52                   	push   %edx
  804729:	e8 2c 51 00 00       	call   80985a <etharp_query>
  80472e:	83 c4 10             	add    $0x10,%esp
    }
#endif /* LWIP_ARP */
    
  }
}
  804731:	c9                   	leave  
  804732:	c3                   	ret    

00804733 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804733:	55                   	push   %ebp
  804734:	89 e5                	mov    %esp,%ebp
  804736:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804739:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80473d:	a8 01                	test   $0x1,%al
  80473f:	74 06                	je     804747 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804741:	83 e0 fe             	and    $0xfffffffe,%eax
  804744:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804747:	5d                   	pop    %ebp
  804748:	c3                   	ret    

00804749 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804749:	55                   	push   %ebp
  80474a:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80474c:	8b 45 08             	mov    0x8(%ebp),%eax
  80474f:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804753:	83 e0 01             	and    $0x1,%eax
}
  804756:	5d                   	pop    %ebp
  804757:	c3                   	ret    

00804758 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804758:	55                   	push   %ebp
  804759:	89 e5                	mov    %esp,%ebp
  80475b:	56                   	push   %esi
  80475c:	53                   	push   %ebx
  80475d:	8b 55 08             	mov    0x8(%ebp),%edx
  804760:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804763:	85 d2                	test   %edx,%edx
  804765:	75 17                	jne    80477e <pbuf_header+0x26>
  804767:	83 ec 04             	sub    $0x4,%esp
  80476a:	68 64 18 81 00       	push   $0x811864
  80476f:	68 64 01 00 00       	push   $0x164
  804774:	68 a0 17 81 00       	push   $0x8117a0
  804779:	e8 cc 9c 00 00       	call   80e44a <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  80477e:	66 85 c9             	test   %cx,%cx
  804781:	0f 84 97 00 00 00    	je     80481e <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804787:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804789:	66 85 c9             	test   %cx,%cx
  80478c:	79 1f                	jns    8047ad <pbuf_header+0x55>
    increment_magnitude = -header_size_increment;
  80478e:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804790:	66 3b 72 0a          	cmp    0xa(%edx),%si
  804794:	76 17                	jbe    8047ad <pbuf_header+0x55>
  804796:	83 ec 04             	sub    $0x4,%esp
  804799:	68 b5 17 81 00       	push   $0x8117b5
  80479e:	68 6b 01 00 00       	push   $0x16b
  8047a3:	68 a0 17 81 00       	push   $0x8117a0
  8047a8:	e8 9d 9c 00 00       	call   80e44a <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  8047ad:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  8047b1:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8047b4:	66 85 c0             	test   %ax,%ax
  8047b7:	74 06                	je     8047bf <pbuf_header+0x67>
  8047b9:	66 83 f8 03          	cmp    $0x3,%ax
  8047bd:	75 13                	jne    8047d2 <pbuf_header+0x7a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8047bf:	0f bf c1             	movswl %cx,%eax
  8047c2:	29 c3                	sub    %eax,%ebx
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047c4:	8d 72 10             	lea    0x10(%edx),%esi
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  8047c7:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047cc:	39 f3                	cmp    %esi,%ebx
  8047ce:	73 3c                	jae    80480c <pbuf_header+0xb4>
  8047d0:	eb 51                	jmp    804823 <pbuf_header+0xcb>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8047d2:	83 e8 01             	sub    $0x1,%eax
  8047d5:	66 83 f8 01          	cmp    $0x1,%ax
  8047d9:	77 1a                	ja     8047f5 <pbuf_header+0x9d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8047db:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8047e0:	66 85 c9             	test   %cx,%cx
  8047e3:	79 3e                	jns    804823 <pbuf_header+0xcb>
  8047e5:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8047e9:	77 38                	ja     804823 <pbuf_header+0xcb>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8047eb:	0f bf c1             	movswl %cx,%eax
  8047ee:	29 c3                	sub    %eax,%ebx
  8047f0:	89 5a 04             	mov    %ebx,0x4(%edx)
  8047f3:	eb 1a                	jmp    80480f <pbuf_header+0xb7>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8047f5:	83 ec 04             	sub    $0x4,%esp
  8047f8:	68 d3 17 81 00       	push   $0x8117d3
  8047fd:	68 9a 01 00 00       	push   $0x19a
  804802:	68 a0 17 81 00       	push   $0x8117a0
  804807:	e8 3e 9c 00 00       	call   80e44a <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80480c:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80480f:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  804813:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804817:	b8 00 00 00 00       	mov    $0x0,%eax
  80481c:	eb 05                	jmp    804823 <pbuf_header+0xcb>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  80481e:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804823:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804826:	5b                   	pop    %ebx
  804827:	5e                   	pop    %esi
  804828:	5d                   	pop    %ebp
  804829:	c3                   	ret    

0080482a <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80482a:	55                   	push   %ebp
  80482b:	89 e5                	mov    %esp,%ebp
  80482d:	56                   	push   %esi
  80482e:	53                   	push   %ebx
  80482f:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804832:	85 d2                	test   %edx,%edx
  804834:	75 17                	jne    80484d <pbuf_free+0x23>
    LWIP_ASSERT("p != NULL", p != NULL);
  804836:	83 ec 04             	sub    $0x4,%esp
  804839:	68 64 18 81 00       	push   $0x811864
  80483e:	68 d0 01 00 00       	push   $0x1d0
  804843:	68 a0 17 81 00       	push   $0x8117a0
  804848:	e8 fd 9b 00 00       	call   80e44a <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80484d:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  804851:	76 17                	jbe    80486a <pbuf_free+0x40>
  804853:	83 ec 04             	sub    $0x4,%esp
  804856:	68 e1 17 81 00       	push   $0x8117e1
  80485b:	68 db 01 00 00       	push   $0x1db
  804860:	68 a0 17 81 00       	push   $0x8117a0
  804865:	e8 e0 9b 00 00       	call   80e44a <_panic>
  80486a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80486f:	eb 02                	jmp    804873 <pbuf_free+0x49>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804871:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804873:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  804877:	66 85 c0             	test   %ax,%ax
  80487a:	75 17                	jne    804893 <pbuf_free+0x69>
  80487c:	83 ec 04             	sub    $0x4,%esp
  80487f:	68 f6 17 81 00       	push   $0x8117f6
  804884:	68 e8 01 00 00       	push   $0x1e8
  804889:	68 a0 17 81 00       	push   $0x8117a0
  80488e:	e8 b7 9b 00 00       	call   80e44a <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804893:	83 e8 01             	sub    $0x1,%eax
  804896:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80489a:	66 85 c0             	test   %ax,%ax
  80489d:	75 48                	jne    8048e7 <pbuf_free+0xbd>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80489f:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  8048a1:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  8048a5:	66 83 f8 03          	cmp    $0x3,%ax
  8048a9:	75 10                	jne    8048bb <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  8048ab:	83 ec 08             	sub    $0x8,%esp
  8048ae:	52                   	push   %edx
  8048af:	6a 0d                	push   $0xd
  8048b1:	e8 01 fc ff ff       	call   8044b7 <memp_free>
  8048b6:	83 c4 10             	add    $0x10,%esp
  8048b9:	eb 25                	jmp    8048e0 <pbuf_free+0xb6>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8048bb:	83 e8 01             	sub    $0x1,%eax
  8048be:	66 83 f8 01          	cmp    $0x1,%ax
  8048c2:	77 10                	ja     8048d4 <pbuf_free+0xaa>
        memp_free(MEMP_PBUF, p);
  8048c4:	83 ec 08             	sub    $0x8,%esp
  8048c7:	52                   	push   %edx
  8048c8:	6a 0c                	push   $0xc
  8048ca:	e8 e8 fb ff ff       	call   8044b7 <memp_free>
  8048cf:	83 c4 10             	add    $0x10,%esp
  8048d2:	eb 0c                	jmp    8048e0 <pbuf_free+0xb6>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  8048d4:	83 ec 0c             	sub    $0xc,%esp
  8048d7:	52                   	push   %edx
  8048d8:	e8 ab f6 ff ff       	call   803f88 <mem_free>
  8048dd:	83 c4 10             	add    $0x10,%esp
      }
      count++;
  8048e0:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  8048e3:	85 f6                	test   %esi,%esi
  8048e5:	75 8a                	jne    804871 <pbuf_free+0x47>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8048e7:	89 d8                	mov    %ebx,%eax
  8048e9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8048ec:	5b                   	pop    %ebx
  8048ed:	5e                   	pop    %esi
  8048ee:	5d                   	pop    %ebp
  8048ef:	c3                   	ret    

008048f0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  8048f0:	55                   	push   %ebp
  8048f1:	89 e5                	mov    %esp,%ebp
  8048f3:	57                   	push   %edi
  8048f4:	56                   	push   %esi
  8048f5:	53                   	push   %ebx
  8048f6:	83 ec 1c             	sub    $0x1c,%esp
  8048f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8048fc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  8048ff:	83 f8 01             	cmp    $0x1,%eax
  804902:	74 18                	je     80491c <pbuf_alloc+0x2c>
  804904:	83 f8 01             	cmp    $0x1,%eax
  804907:	72 0c                	jb     804915 <pbuf_alloc+0x25>
  804909:	83 f8 02             	cmp    $0x2,%eax
  80490c:	74 18                	je     804926 <pbuf_alloc+0x36>
  80490e:	83 f8 03             	cmp    $0x3,%eax
  804911:	74 34                	je     804947 <pbuf_alloc+0x57>
  804913:	eb 1b                	jmp    804930 <pbuf_alloc+0x40>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804915:	bf 14 00 00 00       	mov    $0x14,%edi
  80491a:	eb 05                	jmp    804921 <pbuf_alloc+0x31>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80491c:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  804921:	83 c7 14             	add    $0x14,%edi
  804924:	eb 05                	jmp    80492b <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804926:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80492b:	83 c7 0e             	add    $0xe,%edi
    break;
  80492e:	eb 1c                	jmp    80494c <pbuf_alloc+0x5c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804930:	83 ec 04             	sub    $0x4,%esp
  804933:	68 0c 18 81 00       	push   $0x81180c
  804938:	68 8a 00 00 00       	push   $0x8a
  80493d:	68 a0 17 81 00       	push   $0x8117a0
  804942:	e8 03 9b 00 00       	call   80e44a <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804947:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80494c:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804950:	77 0f                	ja     804961 <pbuf_alloc+0x71>
  804952:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804956:	0f 82 60 01 00 00    	jb     804abc <pbuf_alloc+0x1cc>
  80495c:	e9 a1 01 00 00       	jmp    804b02 <pbuf_alloc+0x212>
  804961:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804965:	0f 85 c8 01 00 00    	jne    804b33 <pbuf_alloc+0x243>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80496b:	83 ec 0c             	sub    $0xc,%esp
  80496e:	6a 0d                	push   $0xd
  804970:	e8 ec fa ff ff       	call   804461 <memp_malloc>
  804975:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804977:	83 c4 10             	add    $0x10,%esp
  80497a:	85 c0                	test   %eax,%eax
  80497c:	0f 84 d6 01 00 00    	je     804b58 <pbuf_alloc+0x268>
      return NULL;
    }
    p->type = type;
  804982:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804986:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80498c:	0f b7 ff             	movzwl %di,%edi
  80498f:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  804993:	83 e2 fc             	and    $0xfffffffc,%edx
  804996:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804999:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80499d:	0f b7 db             	movzwl %bx,%ebx
  8049a0:	83 c7 03             	add    $0x3,%edi
  8049a3:	83 e7 fc             	and    $0xfffffffc,%edi
  8049a6:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8049ab:	29 f8                	sub    %edi,%eax
  8049ad:	39 d8                	cmp    %ebx,%eax
  8049af:	0f 4f c3             	cmovg  %ebx,%eax
  8049b2:	66 89 46 0a          	mov    %ax,0xa(%esi)
  8049b6:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8049b9:	8d 8e e0 07 00 00    	lea    0x7e0(%esi),%ecx
  8049bf:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8049c2:	01 c2                	add    %eax,%edx
  8049c4:	39 d1                	cmp    %edx,%ecx
  8049c6:	73 17                	jae    8049df <pbuf_alloc+0xef>
  8049c8:	83 ec 04             	sub    $0x4,%esp
  8049cb:	68 24 19 81 00       	push   $0x811924
  8049d0:	68 a3 00 00 00       	push   $0xa3
  8049d5:	68 a0 17 81 00       	push   $0x8117a0
  8049da:	e8 6b 9a 00 00       	call   80e44a <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  8049df:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  8049e5:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  8049e7:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8049e9:	e9 c1 00 00 00       	jmp    804aaf <pbuf_alloc+0x1bf>
      q = memp_malloc(MEMP_PBUF_POOL);
  8049ee:	83 ec 0c             	sub    $0xc,%esp
  8049f1:	6a 0d                	push   $0xd
  8049f3:	e8 69 fa ff ff       	call   804461 <memp_malloc>
      if (q == NULL) {
  8049f8:	83 c4 10             	add    $0x10,%esp
  8049fb:	85 c0                	test   %eax,%eax
  8049fd:	75 16                	jne    804a15 <pbuf_alloc+0x125>
        /* free chain so far allocated */
        pbuf_free(p);
  8049ff:	83 ec 0c             	sub    $0xc,%esp
  804a02:	56                   	push   %esi
  804a03:	e8 22 fe ff ff       	call   80482a <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  804a08:	83 c4 10             	add    $0x10,%esp
  804a0b:	b8 00 00 00 00       	mov    $0x0,%eax
  804a10:	e9 56 01 00 00       	jmp    804b6b <pbuf_alloc+0x27b>
      }
      q->type = type;
  804a15:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804a19:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804a1d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  804a23:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a25:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  804a2b:	7e 17                	jle    804a44 <pbuf_alloc+0x154>
  804a2d:	83 ec 04             	sub    $0x4,%esp
  804a30:	68 27 18 81 00       	push   $0x811827
  804a35:	68 bc 00 00 00       	push   $0xbc
  804a3a:	68 a0 17 81 00       	push   $0x8117a0
  804a3f:	e8 06 9a 00 00       	call   80e44a <_panic>
      q->tot_len = (u16_t)rem_len;
  804a44:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804a48:	0f b7 d3             	movzwl %bx,%edx
  804a4b:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  804a51:	bf d0 07 00 00       	mov    $0x7d0,%edi
  804a56:	0f 4f d7             	cmovg  %edi,%edx
  804a59:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804a5d:	8d 48 10             	lea    0x10(%eax),%ecx
  804a60:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a63:	f6 c1 03             	test   $0x3,%cl
  804a66:	74 17                	je     804a7f <pbuf_alloc+0x18f>
  804a68:	83 ec 04             	sub    $0x4,%esp
  804a6b:	68 58 19 81 00       	push   $0x811958
  804a70:	68 c2 00 00 00       	push   $0xc2
  804a75:	68 a0 17 81 00       	push   $0x8117a0
  804a7a:	e8 cb 99 00 00       	call   80e44a <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a7f:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804a83:	03 4e 04             	add    0x4(%esi),%ecx
  804a86:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804a89:	73 17                	jae    804aa2 <pbuf_alloc+0x1b2>
  804a8b:	83 ec 04             	sub    $0x4,%esp
  804a8e:	68 24 19 81 00       	push   $0x811924
  804a93:	68 c5 00 00 00       	push   $0xc5
  804a98:	68 a0 17 81 00       	push   $0x8117a0
  804a9d:	e8 a8 99 00 00       	call   80e44a <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  804aa2:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  804aa8:	0f b7 d2             	movzwl %dx,%edx
  804aab:	29 d3                	sub    %edx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  804aad:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  804aaf:	85 db                	test   %ebx,%ebx
  804ab1:	0f 8f 37 ff ff ff    	jg     8049ee <pbuf_alloc+0xfe>
  804ab7:	e9 8e 00 00 00       	jmp    804b4a <pbuf_alloc+0x25a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804abc:	0f b7 ff             	movzwl %di,%edi
  804abf:	83 ec 0c             	sub    $0xc,%esp
  804ac2:	8d 47 13             	lea    0x13(%edi),%eax
  804ac5:	83 e0 fc             	and    $0xfffffffc,%eax
  804ac8:	89 c2                	mov    %eax,%edx
  804aca:	0f b7 c3             	movzwl %bx,%eax
  804acd:	83 c0 03             	add    $0x3,%eax
  804ad0:	83 e0 fc             	and    $0xfffffffc,%eax
  804ad3:	01 d0                	add    %edx,%eax
  804ad5:	50                   	push   %eax
  804ad6:	e8 5f f7 ff ff       	call   80423a <mem_malloc>
  804adb:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804add:	83 c4 10             	add    $0x10,%esp
  804ae0:	85 c0                	test   %eax,%eax
  804ae2:	74 7b                	je     804b5f <pbuf_alloc+0x26f>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804ae4:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  804ae8:	83 e0 fc             	and    $0xfffffffc,%eax
  804aeb:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  804aee:	66 89 5e 08          	mov    %bx,0x8(%esi)
  804af2:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  804af6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  804afc:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  804b00:	eb 48                	jmp    804b4a <pbuf_alloc+0x25a>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  804b02:	83 ec 0c             	sub    $0xc,%esp
  804b05:	6a 0c                	push   $0xc
  804b07:	e8 55 f9 ff ff       	call   804461 <memp_malloc>
  804b0c:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804b0e:	83 c4 10             	add    $0x10,%esp
  804b11:	85 c0                	test   %eax,%eax
  804b13:	74 51                	je     804b66 <pbuf_alloc+0x276>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  804b15:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804b1c:	66 89 58 08          	mov    %bx,0x8(%eax)
  804b20:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  804b24:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804b2a:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  804b2e:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  804b31:	eb 17                	jmp    804b4a <pbuf_alloc+0x25a>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804b33:	83 ec 04             	sub    $0x4,%esp
  804b36:	68 3b 18 81 00       	push   $0x81183b
  804b3b:	68 f1 00 00 00       	push   $0xf1
  804b40:	68 a0 17 81 00       	push   $0x8117a0
  804b45:	e8 00 99 00 00       	call   80e44a <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  804b4a:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  804b50:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  804b54:	89 f0                	mov    %esi,%eax
  804b56:	eb 13                	jmp    804b6b <pbuf_alloc+0x27b>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  804b58:	b8 00 00 00 00       	mov    $0x0,%eax
  804b5d:	eb 0c                	jmp    804b6b <pbuf_alloc+0x27b>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  804b5f:	b8 00 00 00 00       	mov    $0x0,%eax
  804b64:	eb 05                	jmp    804b6b <pbuf_alloc+0x27b>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  804b66:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  804b6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b6e:	5b                   	pop    %ebx
  804b6f:	5e                   	pop    %esi
  804b70:	5f                   	pop    %edi
  804b71:	5d                   	pop    %ebp
  804b72:	c3                   	ret    

00804b73 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804b73:	55                   	push   %ebp
  804b74:	89 e5                	mov    %esp,%ebp
  804b76:	57                   	push   %edi
  804b77:	56                   	push   %esi
  804b78:	53                   	push   %ebx
  804b79:	83 ec 0c             	sub    $0xc,%esp
  804b7c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b7f:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b82:	85 db                	test   %ebx,%ebx
  804b84:	75 17                	jne    804b9d <pbuf_realloc+0x2a>
  804b86:	83 ec 04             	sub    $0x4,%esp
  804b89:	68 56 18 81 00       	push   $0x811856
  804b8e:	68 13 01 00 00       	push   $0x113
  804b93:	68 a0 17 81 00       	push   $0x8117a0
  804b98:	e8 ad 98 00 00       	call   80e44a <_panic>
  804b9d:	89 f7                	mov    %esi,%edi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b9f:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804ba3:	76 17                	jbe    804bbc <pbuf_realloc+0x49>
  804ba5:	83 ec 04             	sub    $0x4,%esp
  804ba8:	68 6e 18 81 00       	push   $0x81186e
  804bad:	68 17 01 00 00       	push   $0x117
  804bb2:	68 a0 17 81 00       	push   $0x8117a0
  804bb7:	e8 8e 98 00 00       	call   80e44a <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804bbc:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804bc0:	66 39 f2             	cmp    %si,%dx
  804bc3:	0f 86 b8 00 00 00    	jbe    804c81 <pbuf_realloc+0x10e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804bc9:	0f b7 ce             	movzwl %si,%ecx
  804bcc:	0f b7 c2             	movzwl %dx,%eax
  804bcf:	29 c1                	sub    %eax,%ecx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804bd1:	eb 46                	jmp    804c19 <pbuf_realloc+0xa6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804bd3:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804bd5:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804bdb:	7e 17                	jle    804bf4 <pbuf_realloc+0x81>
  804bdd:	83 ec 04             	sub    $0x4,%esp
  804be0:	68 89 18 81 00       	push   $0x811889
  804be5:	68 2b 01 00 00       	push   $0x12b
  804bea:	68 a0 17 81 00       	push   $0x8117a0
  804bef:	e8 56 98 00 00       	call   80e44a <_panic>
    q->tot_len += (u16_t)grow;
  804bf4:	89 f8                	mov    %edi,%eax
  804bf6:	29 d0                	sub    %edx,%eax
  804bf8:	66 01 43 08          	add    %ax,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804bfc:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804bfe:	85 db                	test   %ebx,%ebx
  804c00:	75 17                	jne    804c19 <pbuf_realloc+0xa6>
  804c02:	83 ec 04             	sub    $0x4,%esp
  804c05:	68 9a 18 81 00       	push   $0x81189a
  804c0a:	68 2f 01 00 00       	push   $0x12f
  804c0f:	68 a0 17 81 00       	push   $0x8117a0
  804c14:	e8 31 98 00 00       	call   80e44a <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804c19:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804c1d:	66 39 c6             	cmp    %ax,%si
  804c20:	77 b1                	ja     804bd3 <pbuf_realloc+0x60>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804c22:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804c26:	75 39                	jne    804c61 <pbuf_realloc+0xee>
  804c28:	66 39 c6             	cmp    %ax,%si
  804c2b:	74 34                	je     804c61 <pbuf_realloc+0xee>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804c2d:	8b 53 04             	mov    0x4(%ebx),%edx
  804c30:	29 da                	sub    %ebx,%edx
  804c32:	0f b7 c6             	movzwl %si,%eax
  804c35:	01 d0                	add    %edx,%eax
  804c37:	83 ec 08             	sub    $0x8,%esp
  804c3a:	50                   	push   %eax
  804c3b:	53                   	push   %ebx
  804c3c:	e8 b0 f4 ff ff       	call   8040f1 <mem_realloc>
  804c41:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804c43:	83 c4 10             	add    $0x10,%esp
  804c46:	85 c0                	test   %eax,%eax
  804c48:	75 17                	jne    804c61 <pbuf_realloc+0xee>
  804c4a:	83 ec 04             	sub    $0x4,%esp
  804c4d:	68 b2 18 81 00       	push   $0x8118b2
  804c52:	68 39 01 00 00       	push   $0x139
  804c57:	68 a0 17 81 00       	push   $0x8117a0
  804c5c:	e8 e9 97 00 00       	call   80e44a <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804c61:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804c65:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804c69:	8b 03                	mov    (%ebx),%eax
  804c6b:	85 c0                	test   %eax,%eax
  804c6d:	74 0c                	je     804c7b <pbuf_realloc+0x108>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804c6f:	83 ec 0c             	sub    $0xc,%esp
  804c72:	50                   	push   %eax
  804c73:	e8 b2 fb ff ff       	call   80482a <pbuf_free>
  804c78:	83 c4 10             	add    $0x10,%esp
  }
  /* q is last packet in chain */
  q->next = NULL;
  804c7b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804c81:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804c84:	5b                   	pop    %ebx
  804c85:	5e                   	pop    %esi
  804c86:	5f                   	pop    %edi
  804c87:	5d                   	pop    %ebp
  804c88:	c3                   	ret    

00804c89 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c89:	55                   	push   %ebp
  804c8a:	89 e5                	mov    %esp,%ebp
  804c8c:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804c8f:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804c94:	eb 05                	jmp    804c9b <pbuf_clen+0x12>
    ++len;
  804c96:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804c99:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  804c9b:	85 d2                	test   %edx,%edx
  804c9d:	75 f7                	jne    804c96 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  804c9f:	5d                   	pop    %ebp
  804ca0:	c3                   	ret    

00804ca1 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804ca1:	55                   	push   %ebp
  804ca2:	89 e5                	mov    %esp,%ebp
  804ca4:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804ca7:	85 c0                	test   %eax,%eax
  804ca9:	74 05                	je     804cb0 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804cab:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804cb0:	5d                   	pop    %ebp
  804cb1:	c3                   	ret    

00804cb2 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804cb2:	55                   	push   %ebp
  804cb3:	89 e5                	mov    %esp,%ebp
  804cb5:	53                   	push   %ebx
  804cb6:	83 ec 04             	sub    $0x4,%esp
  804cb9:	8b 45 08             	mov    0x8(%ebp),%eax
  804cbc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804cbf:	85 c0                	test   %eax,%eax
  804cc1:	74 04                	je     804cc7 <pbuf_cat+0x15>
  804cc3:	85 db                	test   %ebx,%ebx
  804cc5:	75 21                	jne    804ce8 <pbuf_cat+0x36>
  804cc7:	83 ec 04             	sub    $0x4,%esp
  804cca:	68 88 19 81 00       	push   $0x811988
  804ccf:	68 42 02 00 00       	push   $0x242
  804cd4:	68 a0 17 81 00       	push   $0x8117a0
  804cd9:	e8 6c 97 00 00       	call   80e44a <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804cde:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804ce2:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804ce6:	89 d0                	mov    %edx,%eax
  804ce8:	8b 10                	mov    (%eax),%edx
  804cea:	85 d2                	test   %edx,%edx
  804cec:	75 f0                	jne    804cde <pbuf_cat+0x2c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804cee:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804cf2:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804cf6:	74 17                	je     804d0f <pbuf_cat+0x5d>
  804cf8:	83 ec 04             	sub    $0x4,%esp
  804cfb:	68 c0 19 81 00       	push   $0x8119c0
  804d00:	68 4a 02 00 00       	push   $0x24a
  804d05:	68 a0 17 81 00       	push   $0x8117a0
  804d0a:	e8 3b 97 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804d0f:	66 03 53 08          	add    0x8(%ebx),%dx
  804d13:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804d17:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804d19:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d1c:	c9                   	leave  
  804d1d:	c3                   	ret    

00804d1e <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804d1e:	55                   	push   %ebp
  804d1f:	89 e5                	mov    %esp,%ebp
  804d21:	53                   	push   %ebx
  804d22:	83 ec 0c             	sub    $0xc,%esp
  804d25:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804d28:	53                   	push   %ebx
  804d29:	ff 75 08             	pushl  0x8(%ebp)
  804d2c:	e8 81 ff ff ff       	call   804cb2 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804d31:	89 1c 24             	mov    %ebx,(%esp)
  804d34:	e8 68 ff ff ff       	call   804ca1 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804d39:	83 c4 10             	add    $0x10,%esp
  804d3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d3f:	c9                   	leave  
  804d40:	c3                   	ret    

00804d41 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804d41:	55                   	push   %ebp
  804d42:	89 e5                	mov    %esp,%ebp
  804d44:	57                   	push   %edi
  804d45:	56                   	push   %esi
  804d46:	53                   	push   %ebx
  804d47:	83 ec 1c             	sub    $0x1c,%esp
  804d4a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804d4d:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804d4f:	85 f6                	test   %esi,%esi
  804d51:	0f 84 80 00 00 00    	je     804dd7 <pbuf_dechain+0x96>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d57:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d5b:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d5f:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804d63:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804d66:	0f b7 d0             	movzwl %ax,%edx
  804d69:	0f b7 f9             	movzwl %cx,%edi
  804d6c:	29 fa                	sub    %edi,%edx
  804d6e:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804d71:	74 17                	je     804d8a <pbuf_dechain+0x49>
  804d73:	83 ec 04             	sub    $0x4,%esp
  804d76:	68 f0 19 81 00       	push   $0x8119f0
  804d7b:	68 80 02 00 00       	push   $0x280
  804d80:	68 a0 17 81 00       	push   $0x8117a0
  804d85:	e8 c0 96 00 00       	call   80e44a <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d8a:	29 c8                	sub    %ecx,%eax
  804d8c:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d90:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d96:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d9a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d9e:	83 ec 0c             	sub    $0xc,%esp
  804da1:	56                   	push   %esi
  804da2:	e8 83 fa ff ff       	call   80482a <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804da7:	83 c4 10             	add    $0x10,%esp
  804daa:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804dae:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804db2:	74 17                	je     804dcb <pbuf_dechain+0x8a>
  804db4:	83 ec 04             	sub    $0x4,%esp
  804db7:	68 cd 18 81 00       	push   $0x8118cd
  804dbc:	68 91 02 00 00       	push   $0x291
  804dc1:	68 a0 17 81 00       	push   $0x8117a0
  804dc6:	e8 7f 96 00 00       	call   80e44a <_panic>
  return ((tail_gone > 0) ? NULL : q);
  804dcb:	84 c0                	test   %al,%al
  804dcd:	b8 00 00 00 00       	mov    $0x0,%eax
  804dd2:	0f 44 c6             	cmove  %esi,%eax
  804dd5:	eb 0f                	jmp    804de6 <pbuf_dechain+0xa5>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804dd7:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ddb:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804ddf:	75 d3                	jne    804db4 <pbuf_dechain+0x73>
  return ((tail_gone > 0) ? NULL : q);
  804de1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804de6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804de9:	5b                   	pop    %ebx
  804dea:	5e                   	pop    %esi
  804deb:	5f                   	pop    %edi
  804dec:	5d                   	pop    %ebp
  804ded:	c3                   	ret    

00804dee <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804dee:	55                   	push   %ebp
  804def:	89 e5                	mov    %esp,%ebp
  804df1:	57                   	push   %edi
  804df2:	56                   	push   %esi
  804df3:	53                   	push   %ebx
  804df4:	83 ec 1c             	sub    $0x1c,%esp
  804df7:	8b 75 08             	mov    0x8(%ebp),%esi
  804dfa:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804dfd:	85 f6                	test   %esi,%esi
  804dff:	74 0e                	je     804e0f <pbuf_copy+0x21>
  804e01:	85 db                	test   %ebx,%ebx
  804e03:	74 0a                	je     804e0f <pbuf_copy+0x21>
  804e05:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e09:	66 39 46 08          	cmp    %ax,0x8(%esi)
  804e0d:	73 17                	jae    804e26 <pbuf_copy+0x38>
  804e0f:	83 ec 04             	sub    $0x4,%esp
  804e12:	68 14 1a 81 00       	push   $0x811a14
  804e17:	68 b1 02 00 00       	push   $0x2b1
  804e1c:	68 a0 17 81 00       	push   $0x8117a0
  804e21:	e8 24 96 00 00       	call   80e44a <_panic>
  804e26:	bf 00 00 00 00       	mov    $0x0,%edi
  804e2b:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804e31:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804e35:	85 f6                	test   %esi,%esi
  804e37:	75 17                	jne    804e50 <pbuf_copy+0x62>
  804e39:	83 ec 04             	sub    $0x4,%esp
  804e3c:	68 e2 18 81 00       	push   $0x8118e2
  804e41:	68 b6 02 00 00       	push   $0x2b6
  804e46:	68 a0 17 81 00       	push   $0x8117a0
  804e4b:	e8 fa 95 00 00       	call   80e44a <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804e50:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804e54:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804e58:	29 c1                	sub    %eax,%ecx
  804e5a:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804e5e:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  804e62:	0f b7 c7             	movzwl %di,%eax
  804e65:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  804e67:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e6b:	29 f8                	sub    %edi,%eax
  804e6d:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  804e71:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  804e75:	39 d1                	cmp    %edx,%ecx
  804e77:	89 c1                	mov    %eax,%ecx
  804e79:	0f 4c cf             	cmovl  %edi,%ecx
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804e7c:	83 ec 04             	sub    $0x4,%esp
  804e7f:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  804e83:	0f b7 c1             	movzwl %cx,%eax
  804e86:	50                   	push   %eax
  804e87:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e8b:	03 43 04             	add    0x4(%ebx),%eax
  804e8e:	50                   	push   %eax
  804e8f:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804e93:	0f b7 c7             	movzwl %di,%eax
  804e96:	03 46 04             	add    0x4(%esi),%eax
  804e99:	50                   	push   %eax
  804e9a:	e8 03 9e 00 00       	call   80eca2 <memcpy>
    offset_to += len;
  804e9f:	89 f8                	mov    %edi,%eax
  804ea1:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  804ea5:	01 c8                	add    %ecx,%eax
  804ea7:	89 c2                	mov    %eax,%edx
  804ea9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    offset_from += len;
  804ead:	66 01 4d e6          	add    %cx,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804eb1:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  804eb5:	83 c4 10             	add    $0x10,%esp
  804eb8:	66 39 c2             	cmp    %ax,%dx
  804ebb:	76 17                	jbe    804ed4 <pbuf_copy+0xe6>
  804ebd:	83 ec 04             	sub    $0x4,%esp
  804ec0:	68 ef 18 81 00       	push   $0x8118ef
  804ec5:	68 c2 02 00 00       	push   $0x2c2
  804eca:	68 a0 17 81 00       	push   $0x8117a0
  804ecf:	e8 76 95 00 00       	call   80e44a <_panic>
    if (offset_to == p_to->len) {
  804ed4:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  804ed8:	75 08                	jne    804ee2 <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804eda:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  804edc:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804ee2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ee6:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804eea:	76 17                	jbe    804f03 <pbuf_copy+0x115>
  804eec:	83 ec 04             	sub    $0x4,%esp
  804eef:	68 06 19 81 00       	push   $0x811906
  804ef4:	68 c8 02 00 00       	push   $0x2c8
  804ef9:	68 a0 17 81 00       	push   $0x8117a0
  804efe:	e8 47 95 00 00       	call   80e44a <_panic>
    if (offset_from >= p_from->len) {
  804f03:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804f07:	72 08                	jb     804f11 <pbuf_copy+0x123>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  804f09:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804f0b:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f11:	85 db                	test   %ebx,%ebx
  804f13:	74 26                	je     804f3b <pbuf_copy+0x14d>
  804f15:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f19:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804f1d:	75 1c                	jne    804f3b <pbuf_copy+0x14d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f1f:	83 3b 00             	cmpl   $0x0,(%ebx)
  804f22:	74 17                	je     804f3b <pbuf_copy+0x14d>
  804f24:	83 ec 04             	sub    $0x4,%esp
  804f27:	68 44 1a 81 00       	push   $0x811a44
  804f2c:	68 d2 02 00 00       	push   $0x2d2
  804f31:	68 a0 17 81 00       	push   $0x8117a0
  804f36:	e8 0f 95 00 00       	call   80e44a <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f3b:	85 f6                	test   %esi,%esi
  804f3d:	74 26                	je     804f65 <pbuf_copy+0x177>
  804f3f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  804f43:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  804f47:	75 1c                	jne    804f65 <pbuf_copy+0x177>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f49:	83 3e 00             	cmpl   $0x0,(%esi)
  804f4c:	74 17                	je     804f65 <pbuf_copy+0x177>
  804f4e:	83 ec 04             	sub    $0x4,%esp
  804f51:	68 44 1a 81 00       	push   $0x811a44
  804f56:	68 d7 02 00 00       	push   $0x2d7
  804f5b:	68 a0 17 81 00       	push   $0x8117a0
  804f60:	e8 e5 94 00 00       	call   80e44a <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804f65:	85 db                	test   %ebx,%ebx
  804f67:	0f 85 c8 fe ff ff    	jne    804e35 <pbuf_copy+0x47>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804f6d:	b8 00 00 00 00       	mov    $0x0,%eax
  804f72:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f75:	5b                   	pop    %ebx
  804f76:	5e                   	pop    %esi
  804f77:	5f                   	pop    %edi
  804f78:	5d                   	pop    %ebp
  804f79:	c3                   	ret    

00804f7a <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804f7a:	55                   	push   %ebp
  804f7b:	89 e5                	mov    %esp,%ebp
  804f7d:	57                   	push   %edi
  804f7e:	56                   	push   %esi
  804f7f:	53                   	push   %ebx
  804f80:	83 ec 1c             	sub    $0x1c,%esp
  804f83:	8b 75 08             	mov    0x8(%ebp),%esi
  804f86:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804f8a:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f8e:	85 f6                	test   %esi,%esi
  804f90:	75 17                	jne    804fa9 <pbuf_copy_partial+0x2f>
  804f92:	83 ec 04             	sub    $0x4,%esp
  804f95:	68 70 1a 81 00       	push   $0x811a70
  804f9a:	68 ef 02 00 00       	push   $0x2ef
  804f9f:	68 a0 17 81 00       	push   $0x8117a0
  804fa4:	e8 a1 94 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804fa9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804fad:	75 66                	jne    805015 <pbuf_copy_partial+0x9b>
  804faf:	83 ec 04             	sub    $0x4,%esp
  804fb2:	68 94 1a 81 00       	push   $0x811a94
  804fb7:	68 f0 02 00 00       	push   $0x2f0
  804fbc:	68 a0 17 81 00       	push   $0x8117a0
  804fc1:	e8 84 94 00 00       	call   80e44a <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  804fc6:	66 85 c0             	test   %ax,%ax
  804fc9:	74 0d                	je     804fd8 <pbuf_copy_partial+0x5e>
  804fcb:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804fcf:	66 39 d0             	cmp    %dx,%ax
  804fd2:	72 04                	jb     804fd8 <pbuf_copy_partial+0x5e>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  804fd4:	29 d0                	sub    %edx,%eax
  804fd6:	eb 39                	jmp    805011 <pbuf_copy_partial+0x97>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804fd8:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804fdc:	29 c3                	sub    %eax,%ebx
  804fde:	66 39 df             	cmp    %bx,%di
  804fe1:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804fe4:	83 ec 04             	sub    $0x4,%esp
  804fe7:	0f b7 d3             	movzwl %bx,%edx
  804fea:	52                   	push   %edx
  804feb:	0f b7 c0             	movzwl %ax,%eax
  804fee:	03 46 04             	add    0x4(%esi),%eax
  804ff1:	50                   	push   %eax
  804ff2:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804ff6:	03 45 0c             	add    0xc(%ebp),%eax
  804ff9:	50                   	push   %eax
  804ffa:	e8 a3 9c 00 00       	call   80eca2 <memcpy>
      copied_total += buf_copy_len;
  804fff:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  805003:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  805007:	29 df                	sub    %ebx,%edi
  805009:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  80500c:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805011:	8b 36                	mov    (%esi),%esi
  805013:	eb 0c                	jmp    805021 <pbuf_copy_partial+0xa7>
  805015:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  80501b:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805021:	66 85 ff             	test   %di,%di
  805024:	74 04                	je     80502a <pbuf_copy_partial+0xb0>
  805026:	85 f6                	test   %esi,%esi
  805028:	75 9c                	jne    804fc6 <pbuf_copy_partial+0x4c>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  80502a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80502e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805031:	5b                   	pop    %ebx
  805032:	5e                   	pop    %esi
  805033:	5f                   	pop    %edi
  805034:	5d                   	pop    %ebp
  805035:	c3                   	ret    

00805036 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805036:	55                   	push   %ebp
  805037:	89 e5                	mov    %esp,%ebp
  805039:	83 ec 14             	sub    $0x14,%esp
  80503c:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80503f:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805044:	8b 40 04             	mov    0x4(%eax),%eax
  805047:	ff 30                	pushl  (%eax)
  805049:	e8 8f 4f 00 00       	call   809fdd <sys_sem_signal>
}
  80504e:	83 c4 10             	add    $0x10,%esp
  805051:	c9                   	leave  
  805052:	c3                   	ret    

00805053 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  805053:	55                   	push   %ebp
  805054:	89 e5                	mov    %esp,%ebp
  805056:	57                   	push   %edi
  805057:	56                   	push   %esi
  805058:	53                   	push   %ebx
  805059:	83 ec 0c             	sub    $0xc,%esp
  80505c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80505f:	e8 7b 53 00 00       	call   80a3df <sys_arch_timeouts>
  805064:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805066:	85 c0                	test   %eax,%eax
  805068:	74 06                	je     805070 <sys_mbox_fetch+0x1d>
  80506a:	8b 00                	mov    (%eax),%eax
  80506c:	85 c0                	test   %eax,%eax
  80506e:	75 13                	jne    805083 <sys_mbox_fetch+0x30>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  805070:	83 ec 04             	sub    $0x4,%esp
  805073:	6a 00                	push   $0x0
  805075:	57                   	push   %edi
  805076:	ff 75 08             	pushl  0x8(%ebp)
  805079:	e8 ce 51 00 00       	call   80a24c <sys_arch_mbox_fetch>
  80507e:	83 c4 10             	add    $0x10,%esp
  805081:	eb 5c                	jmp    8050df <sys_mbox_fetch+0x8c>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  805083:	8b 40 04             	mov    0x4(%eax),%eax
  805086:	85 c0                	test   %eax,%eax
  805088:	74 15                	je     80509f <sys_mbox_fetch+0x4c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80508a:	83 ec 04             	sub    $0x4,%esp
  80508d:	50                   	push   %eax
  80508e:	57                   	push   %edi
  80508f:	ff 75 08             	pushl  0x8(%ebp)
  805092:	e8 b5 51 00 00       	call   80a24c <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805097:	83 c4 10             	add    $0x10,%esp
  80509a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80509d:	75 29                	jne    8050c8 <sys_mbox_fetch+0x75>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80509f:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8050a1:	8b 10                	mov    (%eax),%edx
  8050a3:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8050a5:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8050a8:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8050ab:	83 ec 08             	sub    $0x8,%esp
  8050ae:	50                   	push   %eax
  8050af:	6a 0b                	push   $0xb
  8050b1:	e8 01 f4 ff ff       	call   8044b7 <memp_free>
      if (h != NULL) {
  8050b6:	83 c4 10             	add    $0x10,%esp
  8050b9:	85 db                	test   %ebx,%ebx
  8050bb:	74 a2                	je     80505f <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8050bd:	83 ec 0c             	sub    $0xc,%esp
  8050c0:	56                   	push   %esi
  8050c1:	ff d3                	call   *%ebx
  8050c3:	83 c4 10             	add    $0x10,%esp
  8050c6:	eb 97                	jmp    80505f <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8050c8:	8b 0b                	mov    (%ebx),%ecx
  8050ca:	8b 51 04             	mov    0x4(%ecx),%edx
  8050cd:	39 d0                	cmp    %edx,%eax
  8050cf:	73 07                	jae    8050d8 <sys_mbox_fetch+0x85>
        timeouts->next->time -= time_needed;
  8050d1:	29 c2                	sub    %eax,%edx
  8050d3:	89 51 04             	mov    %edx,0x4(%ecx)
  8050d6:	eb 07                	jmp    8050df <sys_mbox_fetch+0x8c>
      } else {
        timeouts->next->time = 0;
  8050d8:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  8050df:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050e2:	5b                   	pop    %ebx
  8050e3:	5e                   	pop    %esi
  8050e4:	5f                   	pop    %edi
  8050e5:	5d                   	pop    %ebp
  8050e6:	c3                   	ret    

008050e7 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  8050e7:	55                   	push   %ebp
  8050e8:	89 e5                	mov    %esp,%ebp
  8050ea:	57                   	push   %edi
  8050eb:	56                   	push   %esi
  8050ec:	53                   	push   %ebx
  8050ed:	83 ec 0c             	sub    $0xc,%esp
  8050f0:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  8050f3:	e8 e7 52 00 00       	call   80a3df <sys_arch_timeouts>
  8050f8:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8050fa:	85 c0                	test   %eax,%eax
  8050fc:	74 06                	je     805104 <sys_sem_wait+0x1d>
  8050fe:	8b 00                	mov    (%eax),%eax
  805100:	85 c0                	test   %eax,%eax
  805102:	75 10                	jne    805114 <sys_sem_wait+0x2d>
    sys_arch_sem_wait(sem, 0);
  805104:	83 ec 08             	sub    $0x8,%esp
  805107:	6a 00                	push   $0x0
  805109:	56                   	push   %esi
  80510a:	e8 3c 4f 00 00       	call   80a04b <sys_arch_sem_wait>
  80510f:	83 c4 10             	add    $0x10,%esp
  805112:	eb 59                	jmp    80516d <sys_sem_wait+0x86>
  } else {
    if (timeouts->next->time > 0) {
  805114:	8b 40 04             	mov    0x4(%eax),%eax
  805117:	85 c0                	test   %eax,%eax
  805119:	74 12                	je     80512d <sys_sem_wait+0x46>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80511b:	83 ec 08             	sub    $0x8,%esp
  80511e:	50                   	push   %eax
  80511f:	56                   	push   %esi
  805120:	e8 26 4f 00 00       	call   80a04b <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805125:	83 c4 10             	add    $0x10,%esp
  805128:	83 f8 ff             	cmp    $0xffffffff,%eax
  80512b:	75 29                	jne    805156 <sys_sem_wait+0x6f>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80512d:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80512f:	8b 10                	mov    (%eax),%edx
  805131:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805133:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805136:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805139:	83 ec 08             	sub    $0x8,%esp
  80513c:	50                   	push   %eax
  80513d:	6a 0b                	push   $0xb
  80513f:	e8 73 f3 ff ff       	call   8044b7 <memp_free>
      if (h != NULL) {
  805144:	83 c4 10             	add    $0x10,%esp
  805147:	85 db                	test   %ebx,%ebx
  805149:	74 a8                	je     8050f3 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80514b:	83 ec 0c             	sub    $0xc,%esp
  80514e:	57                   	push   %edi
  80514f:	ff d3                	call   *%ebx
  805151:	83 c4 10             	add    $0x10,%esp
  805154:	eb 9d                	jmp    8050f3 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805156:	8b 0b                	mov    (%ebx),%ecx
  805158:	8b 51 04             	mov    0x4(%ecx),%edx
  80515b:	39 d0                	cmp    %edx,%eax
  80515d:	73 07                	jae    805166 <sys_sem_wait+0x7f>
        timeouts->next->time -= time_needed;
  80515f:	29 c2                	sub    %eax,%edx
  805161:	89 51 04             	mov    %edx,0x4(%ecx)
  805164:	eb 07                	jmp    80516d <sys_sem_wait+0x86>
      } else {
        timeouts->next->time = 0;
  805166:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  80516d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805170:	5b                   	pop    %ebx
  805171:	5e                   	pop    %esi
  805172:	5f                   	pop    %edi
  805173:	5d                   	pop    %ebp
  805174:	c3                   	ret    

00805175 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  805175:	55                   	push   %ebp
  805176:	89 e5                	mov    %esp,%ebp
  805178:	56                   	push   %esi
  805179:	53                   	push   %ebx
  80517a:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80517d:	83 ec 0c             	sub    $0xc,%esp
  805180:	6a 0b                	push   $0xb
  805182:	e8 da f2 ff ff       	call   804461 <memp_malloc>
  if (timeout == NULL) {
  805187:	83 c4 10             	add    $0x10,%esp
  80518a:	85 c0                	test   %eax,%eax
  80518c:	75 17                	jne    8051a5 <sys_timeout+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80518e:	83 ec 04             	sub    $0x4,%esp
  805191:	68 b9 1a 81 00       	push   $0x811ab9
  805196:	68 c3 00 00 00       	push   $0xc3
  80519b:	68 d6 1a 81 00       	push   $0x811ad6
  8051a0:	e8 a5 92 00 00       	call   80e44a <_panic>
  8051a5:	89 c3                	mov    %eax,%ebx
    return;
  }
  timeout->next = NULL;
  8051a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8051ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  8051b0:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8051b3:	8b 45 10             	mov    0x10(%ebp),%eax
  8051b6:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8051b9:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8051bc:	e8 1e 52 00 00       	call   80a3df <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8051c1:	85 c0                	test   %eax,%eax
  8051c3:	75 17                	jne    8051dc <sys_timeout+0x67>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8051c5:	83 ec 04             	sub    $0x4,%esp
  8051c8:	68 ea 1a 81 00       	push   $0x811aea
  8051cd:	68 d1 00 00 00       	push   $0xd1
  8051d2:	68 d6 1a 81 00       	push   $0x811ad6
  8051d7:	e8 6e 92 00 00       	call   80e44a <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  8051dc:	8b 08                	mov    (%eax),%ecx
  8051de:	85 c9                	test   %ecx,%ecx
  8051e0:	75 04                	jne    8051e6 <sys_timeout+0x71>
    timeouts->next = timeout;
  8051e2:	89 18                	mov    %ebx,(%eax)
    return;
  8051e4:	eb 37                	jmp    80521d <sys_timeout+0xa8>
  }

  if (timeouts->next->time > msecs) {
  8051e6:	8b 51 04             	mov    0x4(%ecx),%edx
  8051e9:	39 d6                	cmp    %edx,%esi
  8051eb:	73 0f                	jae    8051fc <sys_timeout+0x87>
    timeouts->next->time -= msecs;
  8051ed:	29 f2                	sub    %esi,%edx
  8051ef:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  8051f2:	8b 10                	mov    (%eax),%edx
  8051f4:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8051f6:	89 18                	mov    %ebx,(%eax)
  8051f8:	eb 23                	jmp    80521d <sys_timeout+0xa8>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
  8051fa:	89 d1                	mov    %edx,%ecx
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8051fc:	8b 43 04             	mov    0x4(%ebx),%eax
  8051ff:	2b 41 04             	sub    0x4(%ecx),%eax
  805202:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  805205:	8b 11                	mov    (%ecx),%edx
  805207:	85 d2                	test   %edx,%edx
  805209:	74 0c                	je     805217 <sys_timeout+0xa2>
  80520b:	8b 72 04             	mov    0x4(%edx),%esi
  80520e:	39 f0                	cmp    %esi,%eax
  805210:	73 e8                	jae    8051fa <sys_timeout+0x85>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  805212:	29 c6                	sub    %eax,%esi
  805214:	89 72 04             	mov    %esi,0x4(%edx)
        }
        timeout->next = t->next;
  805217:	8b 01                	mov    (%ecx),%eax
  805219:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80521b:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  80521d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805220:	5b                   	pop    %ebx
  805221:	5e                   	pop    %esi
  805222:	5d                   	pop    %ebp
  805223:	c3                   	ret    

00805224 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  805224:	55                   	push   %ebp
  805225:	89 e5                	mov    %esp,%ebp
  805227:	57                   	push   %edi
  805228:	56                   	push   %esi
  805229:	53                   	push   %ebx
  80522a:	83 ec 0c             	sub    $0xc,%esp
  80522d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805230:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  805233:	e8 a7 51 00 00       	call   80a3df <sys_arch_timeouts>

  if (timeouts == NULL) {
  805238:	85 c0                	test   %eax,%eax
  80523a:	75 17                	jne    805253 <sys_untimeout+0x2f>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80523c:	83 ec 04             	sub    $0x4,%esp
  80523f:	68 08 1b 81 00       	push   $0x811b08
  805244:	68 00 01 00 00       	push   $0x100
  805249:	68 d6 1a 81 00       	push   $0x811ad6
  80524e:	e8 f7 91 00 00       	call   80e44a <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  805253:	8b 10                	mov    (%eax),%edx
  805255:	85 d2                	test   %edx,%edx
  805257:	74 45                	je     80529e <sys_untimeout+0x7a>
  805259:	bf 00 00 00 00       	mov    $0x0,%edi
  80525e:	eb 02                	jmp    805262 <sys_untimeout+0x3e>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805260:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  805262:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805265:	75 2f                	jne    805296 <sys_untimeout+0x72>
  805267:	39 72 0c             	cmp    %esi,0xc(%edx)
  80526a:	75 2a                	jne    805296 <sys_untimeout+0x72>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80526c:	85 ff                	test   %edi,%edi
  80526e:	75 06                	jne    805276 <sys_untimeout+0x52>
        timeouts->next = t->next;
  805270:	8b 0a                	mov    (%edx),%ecx
  805272:	89 08                	mov    %ecx,(%eax)
  805274:	eb 04                	jmp    80527a <sys_untimeout+0x56>
      else
        prev_t->next = t->next;
  805276:	8b 02                	mov    (%edx),%eax
  805278:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80527a:	8b 02                	mov    (%edx),%eax
  80527c:	85 c0                	test   %eax,%eax
  80527e:	74 06                	je     805286 <sys_untimeout+0x62>
        t->next->time += t->time;
  805280:	8b 4a 04             	mov    0x4(%edx),%ecx
  805283:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805286:	83 ec 08             	sub    $0x8,%esp
  805289:	52                   	push   %edx
  80528a:	6a 0b                	push   $0xb
  80528c:	e8 26 f2 ff ff       	call   8044b7 <memp_free>
      return;
  805291:	83 c4 10             	add    $0x10,%esp
  805294:	eb 08                	jmp    80529e <sys_untimeout+0x7a>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805296:	8b 0a                	mov    (%edx),%ecx
  805298:	89 d7                	mov    %edx,%edi
  80529a:	85 c9                	test   %ecx,%ecx
  80529c:	75 c2                	jne    805260 <sys_untimeout+0x3c>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80529e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8052a1:	5b                   	pop    %ebx
  8052a2:	5e                   	pop    %esi
  8052a3:	5f                   	pop    %edi
  8052a4:	5d                   	pop    %ebp
  8052a5:	c3                   	ret    

008052a6 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8052a6:	55                   	push   %ebp
  8052a7:	89 e5                	mov    %esp,%ebp
  8052a9:	83 ec 18             	sub    $0x18,%esp
  8052ac:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8052af:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8052b2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8052b5:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8052bb:	85 c0                	test   %eax,%eax
  8052bd:	74 15                	je     8052d4 <sys_sem_wait_timeout+0x2e>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8052bf:	83 ec 04             	sub    $0x4,%esp
  8052c2:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8052c5:	52                   	push   %edx
  8052c6:	68 36 50 80 00       	push   $0x805036
  8052cb:	50                   	push   %eax
  8052cc:	e8 a4 fe ff ff       	call   805175 <sys_timeout>
  8052d1:	83 c4 10             	add    $0x10,%esp
  }
  sys_sem_wait(sem);
  8052d4:	83 ec 0c             	sub    $0xc,%esp
  8052d7:	ff 75 08             	pushl  0x8(%ebp)
  8052da:	e8 08 fe ff ff       	call   8050e7 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052df:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8052e2:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052e7:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8052ec:	75 19                	jne    805307 <sys_sem_wait_timeout+0x61>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  8052ee:	83 ec 08             	sub    $0x8,%esp
  8052f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8052f4:	50                   	push   %eax
  8052f5:	68 36 50 80 00       	push   $0x805036
  8052fa:	e8 25 ff ff ff       	call   805224 <sys_untimeout>
    return 1;
  8052ff:	83 c4 10             	add    $0x10,%esp
  805302:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805307:	c9                   	leave  
  805308:	c3                   	ret    

00805309 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805309:	55                   	push   %ebp
  80530a:	89 e5                	mov    %esp,%ebp
  80530c:	53                   	push   %ebx
  80530d:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805310:	6a 00                	push   $0x0
  805312:	e8 1a 4a 00 00       	call   809d31 <sys_sem_new>
  805317:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805319:	83 c4 08             	add    $0x8,%esp
  80531c:	ff 75 08             	pushl  0x8(%ebp)
  80531f:	50                   	push   %eax
  805320:	e8 81 ff ff ff       	call   8052a6 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805325:	89 1c 24             	mov    %ebx,(%esp)
  805328:	e8 85 4a 00 00       	call   809db2 <sys_sem_free>
}
  80532d:	83 c4 10             	add    $0x10,%esp
  805330:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805333:	c9                   	leave  
  805334:	c3                   	ret    

00805335 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805335:	55                   	push   %ebp
  805336:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805338:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80533d:	5d                   	pop    %ebp
  80533e:	c3                   	ret    

0080533f <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80533f:	55                   	push   %ebp
  805340:	89 e5                	mov    %esp,%ebp
  805342:	57                   	push   %edi
  805343:	56                   	push   %esi
  805344:	53                   	push   %ebx
  805345:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805348:	8b 35 3c b2 b3 00    	mov    0xb3b23c,%esi
  80534e:	0f b7 0d 0c 40 81 00 	movzwl 0x81400c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805355:	8b 3d 50 b2 b3 00    	mov    0xb3b250,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80535b:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805360:	89 45 f0             	mov    %eax,-0x10(%ebp)
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  805363:	bb 00 10 00 00       	mov    $0x1000,%ebx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  805368:	89 c8                	mov    %ecx,%eax
  80536a:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  80536e:	0f 48 c3             	cmovs  %ebx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805371:	89 f2                	mov    %esi,%edx
  805373:	eb 0c                	jmp    805381 <tcp_new_port+0x42>
    if (pcb->local_port == port) {
  805375:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  805379:	66 39 c8             	cmp    %cx,%ax
  80537c:	74 ea                	je     805368 <tcp_new_port+0x29>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80537e:	8b 52 0c             	mov    0xc(%edx),%edx
  805381:	85 d2                	test   %edx,%edx
  805383:	75 f0                	jne    805375 <tcp_new_port+0x36>
  805385:	89 fa                	mov    %edi,%edx
  805387:	eb 0c                	jmp    805395 <tcp_new_port+0x56>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805389:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80538d:	66 39 c8             	cmp    %cx,%ax
  805390:	74 d6                	je     805368 <tcp_new_port+0x29>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805392:	8b 52 0c             	mov    0xc(%edx),%edx
  805395:	85 d2                	test   %edx,%edx
  805397:	75 f0                	jne    805389 <tcp_new_port+0x4a>
  805399:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80539c:	eb 0c                	jmp    8053aa <tcp_new_port+0x6b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  80539e:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  8053a2:	66 39 c8             	cmp    %cx,%ax
  8053a5:	74 c1                	je     805368 <tcp_new_port+0x29>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053a7:	8b 52 0c             	mov    0xc(%edx),%edx
  8053aa:	85 d2                	test   %edx,%edx
  8053ac:	75 f0                	jne    80539e <tcp_new_port+0x5f>
  8053ae:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8053b4:	83 c4 04             	add    $0x4,%esp
  8053b7:	5b                   	pop    %ebx
  8053b8:	5e                   	pop    %esi
  8053b9:	5f                   	pop    %edi
  8053ba:	5d                   	pop    %ebp
  8053bb:	c3                   	ret    

008053bc <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8053bc:	55                   	push   %ebp
  8053bd:	89 e5                	mov    %esp,%ebp
  8053bf:	57                   	push   %edi
  8053c0:	56                   	push   %esi
  8053c1:	53                   	push   %ebx
  8053c2:	83 ec 0c             	sub    $0xc,%esp
  8053c5:	8b 75 08             	mov    0x8(%ebp),%esi
  8053c8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8053cb:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053ce:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8053d2:	74 17                	je     8053eb <tcp_bind+0x2f>
  8053d4:	83 ec 04             	sub    $0x4,%esp
  8053d7:	68 28 1b 81 00       	push   $0x811b28
  8053dc:	68 05 01 00 00       	push   $0x105
  8053e1:	68 0a 1d 81 00       	push   $0x811d0a
  8053e6:	e8 5f 90 00 00       	call   80e44a <_panic>
  8053eb:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  8053ed:	66 85 d2             	test   %dx,%dx
  8053f0:	75 05                	jne    8053f7 <tcp_bind+0x3b>
    port = tcp_new_port();
  8053f2:	e8 48 ff ff ff       	call   80533f <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053f7:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  8053fd:	eb 35                	jmp    805434 <tcp_bind+0x78>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8053ff:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805403:	75 2c                	jne    805431 <tcp_bind+0x75>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805405:	85 d2                	test   %edx,%edx
  805407:	0f 84 f3 00 00 00    	je     805500 <tcp_bind+0x144>
  80540d:	8b 0a                	mov    (%edx),%ecx
  80540f:	85 db                	test   %ebx,%ebx
  805411:	0f 84 f0 00 00 00    	je     805507 <tcp_bind+0x14b>
  805417:	85 c9                	test   %ecx,%ecx
  805419:	0f 84 e8 00 00 00    	je     805507 <tcp_bind+0x14b>
          ip_addr_isany(ipaddr) ||
  80541f:	8b 3b                	mov    (%ebx),%edi
  805421:	39 f9                	cmp    %edi,%ecx
  805423:	0f 84 e5 00 00 00    	je     80550e <tcp_bind+0x152>
  805429:	85 ff                	test   %edi,%edi
  80542b:	0f 84 dd 00 00 00    	je     80550e <tcp_bind+0x152>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805431:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805434:	85 d2                	test   %edx,%edx
  805436:	75 c7                	jne    8053ff <tcp_bind+0x43>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805438:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  80543e:	eb 35                	jmp    805475 <tcp_bind+0xb9>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805440:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805444:	75 2c                	jne    805472 <tcp_bind+0xb6>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805446:	85 d2                	test   %edx,%edx
  805448:	0f 84 c7 00 00 00    	je     805515 <tcp_bind+0x159>
  80544e:	8b 0a                	mov    (%edx),%ecx
  805450:	85 db                	test   %ebx,%ebx
  805452:	0f 84 c4 00 00 00    	je     80551c <tcp_bind+0x160>
  805458:	85 c9                	test   %ecx,%ecx
  80545a:	0f 84 bc 00 00 00    	je     80551c <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  805460:	8b 3b                	mov    (%ebx),%edi
  805462:	39 f9                	cmp    %edi,%ecx
  805464:	0f 84 b9 00 00 00    	je     805523 <tcp_bind+0x167>
  80546a:	85 ff                	test   %edi,%edi
  80546c:	0f 84 b1 00 00 00    	je     805523 <tcp_bind+0x167>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805472:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805475:	85 d2                	test   %edx,%edx
  805477:	75 c7                	jne    805440 <tcp_bind+0x84>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805479:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80547f:	eb 35                	jmp    8054b6 <tcp_bind+0xfa>
    if (cpcb->local_port == port) {
  805481:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805485:	75 2c                	jne    8054b3 <tcp_bind+0xf7>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805487:	85 d2                	test   %edx,%edx
  805489:	0f 84 9b 00 00 00    	je     80552a <tcp_bind+0x16e>
  80548f:	8b 0a                	mov    (%edx),%ecx
  805491:	85 db                	test   %ebx,%ebx
  805493:	0f 84 98 00 00 00    	je     805531 <tcp_bind+0x175>
  805499:	85 c9                	test   %ecx,%ecx
  80549b:	0f 84 90 00 00 00    	je     805531 <tcp_bind+0x175>
          ip_addr_isany(ipaddr) ||
  8054a1:	8b 3b                	mov    (%ebx),%edi
  8054a3:	39 f9                	cmp    %edi,%ecx
  8054a5:	0f 84 8d 00 00 00    	je     805538 <tcp_bind+0x17c>
  8054ab:	85 ff                	test   %edi,%edi
  8054ad:	0f 84 85 00 00 00    	je     805538 <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054b3:	8b 52 0c             	mov    0xc(%edx),%edx
  8054b6:	85 d2                	test   %edx,%edx
  8054b8:	75 c7                	jne    805481 <tcp_bind+0xc5>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054ba:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8054c0:	eb 0f                	jmp    8054d1 <tcp_bind+0x115>
    if (cpcb->local_port == port) {
  8054c2:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8054c6:	75 06                	jne    8054ce <tcp_bind+0x112>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8054c8:	8b 3b                	mov    (%ebx),%edi
  8054ca:	39 3a                	cmp    %edi,(%edx)
  8054cc:	74 71                	je     80553f <tcp_bind+0x183>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054ce:	8b 52 0c             	mov    0xc(%edx),%edx
  8054d1:	85 d2                	test   %edx,%edx
  8054d3:	75 ed                	jne    8054c2 <tcp_bind+0x106>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  8054d5:	85 db                	test   %ebx,%ebx
  8054d7:	74 09                	je     8054e2 <tcp_bind+0x126>
  8054d9:	83 3b 00             	cmpl   $0x0,(%ebx)
  8054dc:	74 04                	je     8054e2 <tcp_bind+0x126>
    pcb->local_ip = *ipaddr;
  8054de:	8b 13                	mov    (%ebx),%edx
  8054e0:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  8054e2:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8054e6:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8054eb:	89 46 0c             	mov    %eax,0xc(%esi)
  8054ee:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  8054f4:	e8 70 cd ff ff       	call   802269 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  8054f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8054fe:	eb 44                	jmp    805544 <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805500:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805505:	eb 3d                	jmp    805544 <tcp_bind+0x188>
  805507:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80550c:	eb 36                	jmp    805544 <tcp_bind+0x188>
  80550e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805513:	eb 2f                	jmp    805544 <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805515:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80551a:	eb 28                	jmp    805544 <tcp_bind+0x188>
  80551c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805521:	eb 21                	jmp    805544 <tcp_bind+0x188>
  805523:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805528:	eb 1a                	jmp    805544 <tcp_bind+0x188>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80552a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80552f:	eb 13                	jmp    805544 <tcp_bind+0x188>
  805531:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805536:	eb 0c                	jmp    805544 <tcp_bind+0x188>
  805538:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80553d:	eb 05                	jmp    805544 <tcp_bind+0x188>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80553f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805544:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805547:	5b                   	pop    %ebx
  805548:	5e                   	pop    %esi
  805549:	5f                   	pop    %edi
  80554a:	5d                   	pop    %ebp
  80554b:	c3                   	ret    

0080554c <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80554c:	55                   	push   %ebp
  80554d:	89 e5                	mov    %esp,%ebp
  80554f:	57                   	push   %edi
  805550:	56                   	push   %esi
  805551:	53                   	push   %ebx
  805552:	83 ec 1c             	sub    $0x1c,%esp
  805555:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805558:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80555c:	74 17                	je     805575 <tcp_listen_with_backlog+0x29>
  80555e:	83 ec 04             	sub    $0x4,%esp
  805561:	68 54 1b 81 00       	push   $0x811b54
  805566:	68 60 01 00 00       	push   $0x160
  80556b:	68 0a 1d 81 00       	push   $0x811d0a
  805570:	e8 d5 8e 00 00       	call   80e44a <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805575:	83 ec 0c             	sub    $0xc,%esp
  805578:	6a 03                	push   $0x3
  80557a:	e8 e2 ee ff ff       	call   804461 <memp_malloc>
  80557f:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805581:	83 c4 10             	add    $0x10,%esp
  805584:	85 c0                	test   %eax,%eax
  805586:	0f 84 d2 00 00 00    	je     80565e <tcp_listen_with_backlog+0x112>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  80558c:	8b 43 18             	mov    0x18(%ebx),%eax
  80558f:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805592:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805596:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80559a:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  8055a1:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8055a5:	83 c8 02             	or     $0x2,%eax
  8055a8:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8055ac:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8055b0:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8055b3:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8055b7:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8055ba:	85 db                	test   %ebx,%ebx
  8055bc:	74 04                	je     8055c2 <tcp_listen_with_backlog+0x76>
  8055be:	8b 03                	mov    (%ebx),%eax
  8055c0:	eb 05                	jmp    8055c7 <tcp_listen_with_backlog+0x7b>
  8055c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8055c7:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055c9:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8055ce:	39 c3                	cmp    %eax,%ebx
  8055d0:	75 0a                	jne    8055dc <tcp_listen_with_backlog+0x90>
  8055d2:	8b 43 0c             	mov    0xc(%ebx),%eax
  8055d5:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8055da:	eb 4f                	jmp    80562b <tcp_listen_with_backlog+0xdf>
  8055dc:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  8055e1:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8055e5:	89 df                	mov    %ebx,%edi
  8055e7:	eb 2c                	jmp    805615 <tcp_listen_with_backlog+0xc9>
  8055e9:	8b 50 0c             	mov    0xc(%eax),%edx
  8055ec:	39 d7                	cmp    %edx,%edi
  8055ee:	0f 94 c3             	sete   %bl
  8055f1:	85 d2                	test   %edx,%edx
  8055f3:	0f 95 c1             	setne  %cl
  8055f6:	84 cb                	test   %cl,%bl
  8055f8:	74 15                	je     80560f <tcp_listen_with_backlog+0xc3>
  8055fa:	89 fb                	mov    %edi,%ebx
  8055fc:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805600:	74 05                	je     805607 <tcp_listen_with_backlog+0xbb>
  805602:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805607:	8b 53 0c             	mov    0xc(%ebx),%edx
  80560a:	89 50 0c             	mov    %edx,0xc(%eax)
  80560d:	eb 1c                	jmp    80562b <tcp_listen_with_backlog+0xdf>
  80560f:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805613:	89 d0                	mov    %edx,%eax
  805615:	85 c0                	test   %eax,%eax
  805617:	75 d0                	jne    8055e9 <tcp_listen_with_backlog+0x9d>
  805619:	89 fb                	mov    %edi,%ebx
  80561b:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80561f:	74 0a                	je     80562b <tcp_listen_with_backlog+0xdf>
  805621:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805628:	00 00 00 
  80562b:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805632:	83 ec 08             	sub    $0x8,%esp
  805635:	53                   	push   %ebx
  805636:	6a 02                	push   $0x2
  805638:	e8 7a ee ff ff       	call   8044b7 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80563d:	c7 46 20 35 53 80 00 	movl   $0x805335,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805644:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805649:	89 46 0c             	mov    %eax,0xc(%esi)
  80564c:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  805652:	e8 12 cc ff ff       	call   802269 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805657:	83 c4 10             	add    $0x10,%esp
  80565a:	89 f0                	mov    %esi,%eax
  80565c:	eb 05                	jmp    805663 <tcp_listen_with_backlog+0x117>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  80565e:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  805663:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805666:	5b                   	pop    %ebx
  805667:	5e                   	pop    %esi
  805668:	5f                   	pop    %edi
  805669:	5d                   	pop    %ebp
  80566a:	c3                   	ret    

0080566b <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80566b:	55                   	push   %ebp
  80566c:	89 e5                	mov    %esp,%ebp
  80566e:	56                   	push   %esi
  80566f:	53                   	push   %ebx
  805670:	8b 45 08             	mov    0x8(%ebp),%eax
  805673:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805676:	0f b7 58 28          	movzwl 0x28(%eax),%ebx
  80567a:	0f b7 f3             	movzwl %bx,%esi
  80567d:	0f b7 ca             	movzwl %dx,%ecx
  805680:	01 f1                	add    %esi,%ecx
  805682:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805688:	76 0e                	jbe    805698 <tcp_recved+0x2d>
    pcb->rcv_wnd = TCP_WND;
  80568a:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805690:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805696:	eb 10                	jmp    8056a8 <tcp_recved+0x3d>
  } else {
    pcb->rcv_wnd += len;
  805698:	01 da                	add    %ebx,%edx
  80569a:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80569e:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8056a2:	72 04                	jb     8056a8 <tcp_recved+0x3d>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8056a4:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8056a8:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8056ac:	f6 c2 03             	test   $0x3,%dl
  8056af:	75 24                	jne    8056d5 <tcp_recved+0x6a>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8056b1:	f6 c2 01             	test   $0x1,%dl
  8056b4:	74 17                	je     8056cd <tcp_recved+0x62>
  8056b6:	83 e2 fe             	and    $0xfffffffe,%edx
  8056b9:	83 ca 02             	or     $0x2,%edx
  8056bc:	88 50 20             	mov    %dl,0x20(%eax)
  8056bf:	83 ec 0c             	sub    $0xc,%esp
  8056c2:	50                   	push   %eax
  8056c3:	e8 37 29 00 00       	call   807fff <tcp_output>
  8056c8:	83 c4 10             	add    $0x10,%esp
  8056cb:	eb 27                	jmp    8056f4 <tcp_recved+0x89>
  8056cd:	83 ca 01             	or     $0x1,%edx
  8056d0:	88 50 20             	mov    %dl,0x20(%eax)
  8056d3:	eb 1f                	jmp    8056f4 <tcp_recved+0x89>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8056d5:	f6 c2 01             	test   $0x1,%dl
  8056d8:	74 1a                	je     8056f4 <tcp_recved+0x89>
  8056da:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8056e0:	76 12                	jbe    8056f4 <tcp_recved+0x89>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  8056e2:	83 ca 02             	or     $0x2,%edx
  8056e5:	88 50 20             	mov    %dl,0x20(%eax)
  8056e8:	83 ec 0c             	sub    $0xc,%esp
  8056eb:	50                   	push   %eax
  8056ec:	e8 0e 29 00 00       	call   807fff <tcp_output>
  8056f1:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  8056f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056f7:	5b                   	pop    %ebx
  8056f8:	5e                   	pop    %esi
  8056f9:	5d                   	pop    %ebp
  8056fa:	c3                   	ret    

008056fb <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8056fb:	55                   	push   %ebp
  8056fc:	89 e5                	mov    %esp,%ebp
  8056fe:	53                   	push   %ebx
  8056ff:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805702:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805708:	eb 5d                	jmp    805767 <tcp_fasttmr+0x6c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80570a:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805710:	85 c0                	test   %eax,%eax
  805712:	74 32                	je     805746 <tcp_fasttmr+0x4b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805714:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80571a:	85 d2                	test   %edx,%edx
  80571c:	74 12                	je     805730 <tcp_fasttmr+0x35>
  80571e:	6a 00                	push   $0x0
  805720:	50                   	push   %eax
  805721:	53                   	push   %ebx
  805722:	ff 73 18             	pushl  0x18(%ebx)
  805725:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805727:	83 c4 10             	add    $0x10,%esp
  80572a:	84 c0                	test   %al,%al
  80572c:	75 18                	jne    805746 <tcp_fasttmr+0x4b>
  80572e:	eb 0c                	jmp    80573c <tcp_fasttmr+0x41>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805730:	83 ec 0c             	sub    $0xc,%esp
  805733:	50                   	push   %eax
  805734:	e8 f1 f0 ff ff       	call   80482a <pbuf_free>
  805739:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80573c:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805743:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805746:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80574a:	a8 01                	test   $0x1,%al
  80574c:	74 16                	je     805764 <tcp_fasttmr+0x69>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80574e:	83 c8 02             	or     $0x2,%eax
  805751:	88 43 20             	mov    %al,0x20(%ebx)
  805754:	83 ec 0c             	sub    $0xc,%esp
  805757:	53                   	push   %ebx
  805758:	e8 a2 28 00 00       	call   807fff <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80575d:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805761:	83 c4 10             	add    $0x10,%esp
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805764:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805767:	85 db                	test   %ebx,%ebx
  805769:	75 9f                	jne    80570a <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  80576b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80576e:	c9                   	leave  
  80576f:	c3                   	ret    

00805770 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805770:	55                   	push   %ebp
  805771:	89 e5                	mov    %esp,%ebp
  805773:	56                   	push   %esi
  805774:	53                   	push   %ebx
  805775:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805778:	85 db                	test   %ebx,%ebx
  80577a:	74 2a                	je     8057a6 <tcp_seg_free+0x36>
    if (seg->p != NULL) {
  80577c:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  80577f:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  805784:	85 c0                	test   %eax,%eax
  805786:	74 0e                	je     805796 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805788:	83 ec 0c             	sub    $0xc,%esp
  80578b:	50                   	push   %eax
  80578c:	e8 99 f0 ff ff       	call   80482a <pbuf_free>
  805791:	89 c6                	mov    %eax,%esi
  805793:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805796:	83 ec 08             	sub    $0x8,%esp
  805799:	53                   	push   %ebx
  80579a:	6a 04                	push   $0x4
  80579c:	e8 16 ed ff ff       	call   8044b7 <memp_free>
  8057a1:	83 c4 10             	add    $0x10,%esp
  8057a4:	eb 05                	jmp    8057ab <tcp_seg_free+0x3b>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  8057a6:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  8057ab:	89 f0                	mov    %esi,%eax
  8057ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057b0:	5b                   	pop    %ebx
  8057b1:	5e                   	pop    %esi
  8057b2:	5d                   	pop    %ebp
  8057b3:	c3                   	ret    

008057b4 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  8057b4:	55                   	push   %ebp
  8057b5:	89 e5                	mov    %esp,%ebp
  8057b7:	56                   	push   %esi
  8057b8:	53                   	push   %ebx
  8057b9:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8057bc:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  8057c1:	eb 12                	jmp    8057d5 <tcp_segs_free+0x21>
    next = seg->next;
  8057c3:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8057c5:	83 ec 0c             	sub    $0xc,%esp
  8057c8:	50                   	push   %eax
  8057c9:	e8 a2 ff ff ff       	call   805770 <tcp_seg_free>
  8057ce:	01 c3                	add    %eax,%ebx
  8057d0:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8057d3:	89 f0                	mov    %esi,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  8057d5:	85 c0                	test   %eax,%eax
  8057d7:	75 ea                	jne    8057c3 <tcp_segs_free+0xf>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  8057d9:	89 d8                	mov    %ebx,%eax
  8057db:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057de:	5b                   	pop    %ebx
  8057df:	5e                   	pop    %esi
  8057e0:	5d                   	pop    %ebp
  8057e1:	c3                   	ret    

008057e2 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8057e2:	55                   	push   %ebp
  8057e3:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8057e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8057eb:	88 50 14             	mov    %dl,0x14(%eax)
}
  8057ee:	5d                   	pop    %ebp
  8057ef:	c3                   	ret    

008057f0 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8057f0:	55                   	push   %ebp
  8057f1:	89 e5                	mov    %esp,%ebp
  8057f3:	53                   	push   %ebx
  8057f4:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8057f7:	6a 04                	push   $0x4
  8057f9:	e8 63 ec ff ff       	call   804461 <memp_malloc>
  8057fe:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805800:	83 c4 10             	add    $0x10,%esp
  805803:	85 c0                	test   %eax,%eax
  805805:	74 1c                	je     805823 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805807:	83 ec 04             	sub    $0x4,%esp
  80580a:	6a 14                	push   $0x14
  80580c:	ff 75 08             	pushl  0x8(%ebp)
  80580f:	50                   	push   %eax
  805810:	e8 8d 94 00 00       	call   80eca2 <memcpy>
  pbuf_ref(cseg->p);
  805815:	83 c4 04             	add    $0x4,%esp
  805818:	ff 73 04             	pushl  0x4(%ebx)
  80581b:	e8 81 f4 ff ff       	call   804ca1 <pbuf_ref>
  return cseg;
  805820:	83 c4 10             	add    $0x10,%esp
}
  805823:	89 d8                	mov    %ebx,%eax
  805825:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805828:	c9                   	leave  
  805829:	c3                   	ret    

0080582a <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  80582a:	55                   	push   %ebp
  80582b:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  80582d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805830:	8b 45 08             	mov    0x8(%ebp),%eax
  805833:	89 50 18             	mov    %edx,0x18(%eax)
}
  805836:	5d                   	pop    %ebp
  805837:	c3                   	ret    

00805838 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805838:	55                   	push   %ebp
  805839:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  80583b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80583e:	8b 45 08             	mov    0x8(%ebp),%eax
  805841:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805847:	5d                   	pop    %ebp
  805848:	c3                   	ret    

00805849 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805849:	55                   	push   %ebp
  80584a:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80584c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80584f:	8b 45 08             	mov    0x8(%ebp),%eax
  805852:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805858:	5d                   	pop    %ebp
  805859:	c3                   	ret    

0080585a <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  80585a:	55                   	push   %ebp
  80585b:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80585d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805860:	8b 45 08             	mov    0x8(%ebp),%eax
  805863:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805869:	5d                   	pop    %ebp
  80586a:	c3                   	ret    

0080586b <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  80586b:	55                   	push   %ebp
  80586c:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80586e:	8b 55 0c             	mov    0xc(%ebp),%edx
  805871:	8b 45 08             	mov    0x8(%ebp),%eax
  805874:	89 50 20             	mov    %edx,0x20(%eax)
}
  805877:	5d                   	pop    %ebp
  805878:	c3                   	ret    

00805879 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805879:	55                   	push   %ebp
  80587a:	89 e5                	mov    %esp,%ebp
  80587c:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80587f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805882:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805888:	8b 55 10             	mov    0x10(%ebp),%edx
  80588b:	88 50 31             	mov    %dl,0x31(%eax)
}
  80588e:	5d                   	pop    %ebp
  80588f:	c3                   	ret    

00805890 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805890:	55                   	push   %ebp
  805891:	89 e5                	mov    %esp,%ebp
  805893:	53                   	push   %ebx
  805894:	83 ec 04             	sub    $0x4,%esp
  805897:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  80589a:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  80589d:	83 f8 0a             	cmp    $0xa,%eax
  8058a0:	74 64                	je     805906 <tcp_pcb_purge+0x76>
  8058a2:	83 f8 01             	cmp    $0x1,%eax
  8058a5:	76 5f                	jbe    805906 <tcp_pcb_purge+0x76>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8058a7:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8058ad:	85 c0                	test   %eax,%eax
  8058af:	74 16                	je     8058c7 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8058b1:	83 ec 0c             	sub    $0xc,%esp
  8058b4:	50                   	push   %eax
  8058b5:	e8 70 ef ff ff       	call   80482a <pbuf_free>
      pcb->refused_data = NULL;
  8058ba:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8058c1:	00 00 00 
  8058c4:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8058c7:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8058cd:	83 ec 0c             	sub    $0xc,%esp
  8058d0:	ff 73 7c             	pushl  0x7c(%ebx)
  8058d3:	e8 dc fe ff ff       	call   8057b4 <tcp_segs_free>
    pcb->ooseq = NULL;
  8058d8:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8058df:	83 c4 04             	add    $0x4,%esp
  8058e2:	ff 73 74             	pushl  0x74(%ebx)
  8058e5:	e8 ca fe ff ff       	call   8057b4 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8058ea:	83 c4 04             	add    $0x4,%esp
  8058ed:	ff 73 78             	pushl  0x78(%ebx)
  8058f0:	e8 bf fe ff ff       	call   8057b4 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8058f5:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8058fc:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805903:	83 c4 10             	add    $0x10,%esp
  }
}
  805906:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805909:	c9                   	leave  
  80590a:	c3                   	ret    

0080590b <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  80590b:	55                   	push   %ebp
  80590c:	89 e5                	mov    %esp,%ebp
  80590e:	57                   	push   %edi
  80590f:	56                   	push   %esi
  805910:	53                   	push   %ebx
  805911:	83 ec 1c             	sub    $0x1c,%esp
  805914:	8b 45 08             	mov    0x8(%ebp),%eax
  805917:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80591a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  TCP_RMV(pcblist, pcb);
  80591d:	8b 10                	mov    (%eax),%edx
  80591f:	39 fa                	cmp    %edi,%edx
  805921:	75 07                	jne    80592a <tcp_pcb_remove+0x1f>
  805923:	8b 52 0c             	mov    0xc(%edx),%edx
  805926:	89 10                	mov    %edx,(%eax)
  805928:	eb 55                	jmp    80597f <tcp_pcb_remove+0x74>
  80592a:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805930:	bf 00 00 00 00       	mov    $0x0,%edi
  805935:	eb 34                	jmp    80596b <tcp_pcb_remove+0x60>
  805937:	8b 42 0c             	mov    0xc(%edx),%eax
  80593a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  80593d:	0f 94 c1             	sete   %cl
  805940:	89 ce                	mov    %ecx,%esi
  805942:	85 c0                	test   %eax,%eax
  805944:	0f 95 c1             	setne  %cl
  805947:	89 f3                	mov    %esi,%ebx
  805949:	84 cb                	test   %cl,%bl
  80594b:	74 17                	je     805964 <tcp_pcb_remove+0x59>
  80594d:	89 f8                	mov    %edi,%eax
  80594f:	84 c0                	test   %al,%al
  805951:	74 06                	je     805959 <tcp_pcb_remove+0x4e>
  805953:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805959:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80595c:	8b 40 0c             	mov    0xc(%eax),%eax
  80595f:	89 42 0c             	mov    %eax,0xc(%edx)
  805962:	eb 1b                	jmp    80597f <tcp_pcb_remove+0x74>
  805964:	bf 01 00 00 00       	mov    $0x1,%edi
  805969:	89 c2                	mov    %eax,%edx
  80596b:	85 d2                	test   %edx,%edx
  80596d:	75 c8                	jne    805937 <tcp_pcb_remove+0x2c>
  80596f:	89 f8                	mov    %edi,%eax
  805971:	84 c0                	test   %al,%al
  805973:	74 0a                	je     80597f <tcp_pcb_remove+0x74>
  805975:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80597c:	00 00 00 
  80597f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805982:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)

  tcp_pcb_purge(pcb);
  805989:	83 ec 0c             	sub    $0xc,%esp
  80598c:	57                   	push   %edi
  80598d:	e8 fe fe ff ff       	call   805890 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805992:	8b 47 10             	mov    0x10(%edi),%eax
  805995:	83 c4 10             	add    $0x10,%esp
  805998:	83 f8 0a             	cmp    $0xa,%eax
  80599b:	74 22                	je     8059bf <tcp_pcb_remove+0xb4>
  80599d:	83 f8 01             	cmp    $0x1,%eax
  8059a0:	74 1d                	je     8059bf <tcp_pcb_remove+0xb4>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  8059a2:	0f b6 47 20          	movzbl 0x20(%edi),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  8059a6:	a8 01                	test   $0x1,%al
  8059a8:	74 15                	je     8059bf <tcp_pcb_remove+0xb4>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  8059aa:	83 c8 02             	or     $0x2,%eax
  8059ad:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8059b0:	88 46 20             	mov    %al,0x20(%esi)
    tcp_output(pcb);
  8059b3:	83 ec 0c             	sub    $0xc,%esp
  8059b6:	56                   	push   %esi
  8059b7:	e8 43 26 00 00       	call   807fff <tcp_output>
  8059bc:	83 c4 10             	add    $0x10,%esp
  }

  if (pcb->state != LISTEN) {
  8059bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059c2:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  8059c6:	74 5d                	je     805a25 <tcp_pcb_remove+0x11a>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8059c8:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  8059cc:	74 17                	je     8059e5 <tcp_pcb_remove+0xda>
  8059ce:	83 ec 04             	sub    $0x4,%esp
  8059d1:	68 1e 1d 81 00       	push   $0x811d1e
  8059d6:	68 b4 04 00 00       	push   $0x4b4
  8059db:	68 0a 1d 81 00       	push   $0x811d0a
  8059e0:	e8 65 8a 00 00       	call   80e44a <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8059e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059e8:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  8059ec:	74 17                	je     805a05 <tcp_pcb_remove+0xfa>
  8059ee:	83 ec 04             	sub    $0x4,%esp
  8059f1:	68 36 1d 81 00       	push   $0x811d36
  8059f6:	68 b5 04 00 00       	push   $0x4b5
  8059fb:	68 0a 1d 81 00       	push   $0x811d0a
  805a00:	e8 45 8a 00 00       	call   80e44a <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805a05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a08:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
  805a0c:	74 17                	je     805a25 <tcp_pcb_remove+0x11a>
  805a0e:	83 ec 04             	sub    $0x4,%esp
  805a11:	68 4f 1d 81 00       	push   $0x811d4f
  805a16:	68 b7 04 00 00       	push   $0x4b7
  805a1b:	68 0a 1d 81 00       	push   $0x811d0a
  805a20:	e8 25 8a 00 00       	call   80e44a <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805a25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a28:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805a2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805a32:	5b                   	pop    %ebx
  805a33:	5e                   	pop    %esi
  805a34:	5f                   	pop    %edi
  805a35:	5d                   	pop    %ebp
  805a36:	c3                   	ret    

00805a37 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  805a37:	55                   	push   %ebp
  805a38:	89 e5                	mov    %esp,%ebp
  805a3a:	57                   	push   %edi
  805a3b:	56                   	push   %esi
  805a3c:	53                   	push   %ebx
  805a3d:	83 ec 1c             	sub    $0x1c,%esp
  805a40:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  805a43:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805a47:	0f 87 37 01 00 00    	ja     805b84 <tcp_close+0x14d>
  805a4d:	8b 43 10             	mov    0x10(%ebx),%eax
  805a50:	ff 24 85 68 1d 81 00 	jmp    *0x811d68(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a57:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805a5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805a5f:	39 c3                	cmp    %eax,%ebx
  805a61:	75 0a                	jne    805a6d <tcp_close+0x36>
  805a63:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a66:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805a6b:	eb 5e                	jmp    805acb <tcp_close+0x94>
  805a6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a70:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805a75:	bf 00 00 00 00       	mov    $0x0,%edi
  805a7a:	eb 39                	jmp    805ab5 <tcp_close+0x7e>
  805a7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a7f:	8b 40 0c             	mov    0xc(%eax),%eax
  805a82:	39 c3                	cmp    %eax,%ebx
  805a84:	0f 94 c1             	sete   %cl
  805a87:	89 ce                	mov    %ecx,%esi
  805a89:	85 c0                	test   %eax,%eax
  805a8b:	0f 95 c1             	setne  %cl
  805a8e:	89 f2                	mov    %esi,%edx
  805a90:	84 ca                	test   %cl,%dl
  805a92:	74 19                	je     805aad <tcp_close+0x76>
  805a94:	89 f8                	mov    %edi,%eax
  805a96:	84 c0                	test   %al,%al
  805a98:	74 08                	je     805aa2 <tcp_close+0x6b>
  805a9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a9d:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805aa2:	8b 43 0c             	mov    0xc(%ebx),%eax
  805aa5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805aa8:	89 47 0c             	mov    %eax,0xc(%edi)
  805aab:	eb 1e                	jmp    805acb <tcp_close+0x94>
  805aad:	bf 01 00 00 00       	mov    $0x1,%edi
  805ab2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805ab5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805ab9:	75 c1                	jne    805a7c <tcp_close+0x45>
  805abb:	89 f8                	mov    %edi,%eax
  805abd:	84 c0                	test   %al,%al
  805abf:	74 0a                	je     805acb <tcp_close+0x94>
  805ac1:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805ac8:	00 00 00 
  805acb:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805ad2:	83 ec 08             	sub    $0x8,%esp
  805ad5:	53                   	push   %ebx
  805ad6:	6a 02                	push   $0x2
  805ad8:	e8 da e9 ff ff       	call   8044b7 <memp_free>
    pcb = NULL;
    break;
  805add:	83 c4 10             	add    $0x10,%esp
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  805ae0:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  805ae5:	e9 bb 00 00 00       	jmp    805ba5 <tcp_close+0x16e>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805aea:	83 ec 08             	sub    $0x8,%esp
  805aed:	53                   	push   %ebx
  805aee:	68 44 b2 b3 00       	push   $0xb3b244
  805af3:	e8 13 fe ff ff       	call   80590b <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805af8:	83 c4 08             	add    $0x8,%esp
  805afb:	53                   	push   %ebx
  805afc:	6a 03                	push   $0x3
  805afe:	e8 b4 e9 ff ff       	call   8044b7 <memp_free>
    pcb = NULL;
    break;
  805b03:	83 c4 10             	add    $0x10,%esp
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  805b06:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  805b0b:	e9 95 00 00 00       	jmp    805ba5 <tcp_close+0x16e>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b10:	83 ec 08             	sub    $0x8,%esp
  805b13:	53                   	push   %ebx
  805b14:	68 3c b2 b3 00       	push   $0xb3b23c
  805b19:	e8 ed fd ff ff       	call   80590b <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b1e:	83 c4 08             	add    $0x8,%esp
  805b21:	53                   	push   %ebx
  805b22:	6a 02                	push   $0x2
  805b24:	e8 8e e9 ff ff       	call   8044b7 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805b29:	83 c4 10             	add    $0x10,%esp
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  805b2c:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805b31:	eb 72                	jmp    805ba5 <tcp_close+0x16e>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b33:	83 ec 08             	sub    $0x8,%esp
  805b36:	6a 01                	push   $0x1
  805b38:	53                   	push   %ebx
  805b39:	e8 4f 24 00 00       	call   807f8d <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b3e:	83 c4 10             	add    $0x10,%esp
  805b41:	84 c0                	test   %al,%al
  805b43:	75 60                	jne    805ba5 <tcp_close+0x16e>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  805b45:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b4c:	eb 3b                	jmp    805b89 <tcp_close+0x152>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b4e:	83 ec 08             	sub    $0x8,%esp
  805b51:	6a 01                	push   $0x1
  805b53:	53                   	push   %ebx
  805b54:	e8 34 24 00 00       	call   807f8d <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b59:	83 c4 10             	add    $0x10,%esp
  805b5c:	84 c0                	test   %al,%al
  805b5e:	75 45                	jne    805ba5 <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  805b60:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b67:	eb 20                	jmp    805b89 <tcp_close+0x152>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b69:	83 ec 08             	sub    $0x8,%esp
  805b6c:	6a 01                	push   $0x1
  805b6e:	53                   	push   %ebx
  805b6f:	e8 19 24 00 00       	call   807f8d <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b74:	83 c4 10             	add    $0x10,%esp
  805b77:	84 c0                	test   %al,%al
  805b79:	75 2a                	jne    805ba5 <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  805b7b:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805b82:	eb 05                	jmp    805b89 <tcp_close+0x152>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  805b84:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  805b89:	85 db                	test   %ebx,%ebx
  805b8b:	74 13                	je     805ba0 <tcp_close+0x169>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  805b8d:	83 ec 0c             	sub    $0xc,%esp
  805b90:	53                   	push   %ebx
  805b91:	e8 69 24 00 00       	call   807fff <tcp_output>
  805b96:	83 c4 10             	add    $0x10,%esp
  805b99:	b8 00 00 00 00       	mov    $0x0,%eax
  805b9e:	eb 05                	jmp    805ba5 <tcp_close+0x16e>
  805ba0:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  805ba5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805ba8:	5b                   	pop    %ebx
  805ba9:	5e                   	pop    %esi
  805baa:	5f                   	pop    %edi
  805bab:	5d                   	pop    %ebp
  805bac:	c3                   	ret    

00805bad <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  805bad:	55                   	push   %ebp
  805bae:	89 e5                	mov    %esp,%ebp
  805bb0:	83 ec 08             	sub    $0x8,%esp
  805bb3:	8b 45 10             	mov    0x10(%ebp),%eax
  805bb6:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  805bb9:	85 c0                	test   %eax,%eax
  805bbb:	74 13                	je     805bd0 <tcp_recv_null+0x23>
    pbuf_free(p);
  805bbd:	83 ec 0c             	sub    $0xc,%esp
  805bc0:	50                   	push   %eax
  805bc1:	e8 64 ec ff ff       	call   80482a <pbuf_free>
  805bc6:	83 c4 10             	add    $0x10,%esp
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  805bc9:	b8 00 00 00 00       	mov    $0x0,%eax
  805bce:	eb 17                	jmp    805be7 <tcp_recv_null+0x3a>
  805bd0:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  805bd5:	84 d2                	test   %dl,%dl
  805bd7:	75 0e                	jne    805be7 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
  805bd9:	83 ec 0c             	sub    $0xc,%esp
  805bdc:	ff 75 0c             	pushl  0xc(%ebp)
  805bdf:	e8 53 fe ff ff       	call   805a37 <tcp_close>
  805be4:	83 c4 10             	add    $0x10,%esp
  }
  return ERR_OK;
}
  805be7:	c9                   	leave  
  805be8:	c3                   	ret    

00805be9 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805be9:	55                   	push   %ebp
  805bea:	89 e5                	mov    %esp,%ebp
  805bec:	57                   	push   %edi
  805bed:	56                   	push   %esi
  805bee:	53                   	push   %ebx
  805bef:	83 ec 2c             	sub    $0x2c,%esp
  805bf2:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805bf5:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805bf9:	75 21                	jne    805c1c <tcp_abort+0x33>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805bfb:	83 ec 08             	sub    $0x8,%esp
  805bfe:	53                   	push   %ebx
  805bff:	68 50 b2 b3 00       	push   $0xb3b250
  805c04:	e8 02 fd ff ff       	call   80590b <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c09:	83 c4 08             	add    $0x8,%esp
  805c0c:	53                   	push   %ebx
  805c0d:	6a 02                	push   $0x2
  805c0f:	e8 a3 e8 ff ff       	call   8044b7 <memp_free>
  805c14:	83 c4 10             	add    $0x10,%esp
  805c17:	e9 d1 00 00 00       	jmp    805ced <tcp_abort+0x104>
  } else {
    seqno = pcb->snd_nxt;
  805c1c:	8b 43 54             	mov    0x54(%ebx),%eax
  805c1f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805c22:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805c25:	85 db                	test   %ebx,%ebx
  805c27:	74 04                	je     805c2d <tcp_abort+0x44>
  805c29:	8b 03                	mov    (%ebx),%eax
  805c2b:	eb 05                	jmp    805c32 <tcp_abort+0x49>
  805c2d:	b8 00 00 00 00       	mov    $0x0,%eax
  805c32:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805c35:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805c38:	74 05                	je     805c3f <tcp_abort+0x56>
  805c3a:	8b 43 04             	mov    0x4(%ebx),%eax
  805c3d:	eb 05                	jmp    805c44 <tcp_abort+0x5b>
  805c3f:	b8 00 00 00 00       	mov    $0x0,%eax
  805c44:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805c47:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c4b:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805c4f:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805c53:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805c57:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805c5d:	8b 43 18             	mov    0x18(%ebx),%eax
  805c60:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805c63:	83 ec 08             	sub    $0x8,%esp
  805c66:	53                   	push   %ebx
  805c67:	68 3c b2 b3 00       	push   $0xb3b23c
  805c6c:	e8 9a fc ff ff       	call   80590b <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805c71:	8b 43 78             	mov    0x78(%ebx),%eax
  805c74:	83 c4 10             	add    $0x10,%esp
  805c77:	85 c0                	test   %eax,%eax
  805c79:	74 0c                	je     805c87 <tcp_abort+0x9e>
      tcp_segs_free(pcb->unacked);
  805c7b:	83 ec 0c             	sub    $0xc,%esp
  805c7e:	50                   	push   %eax
  805c7f:	e8 30 fb ff ff       	call   8057b4 <tcp_segs_free>
  805c84:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
  805c87:	8b 43 74             	mov    0x74(%ebx),%eax
  805c8a:	85 c0                	test   %eax,%eax
  805c8c:	74 0c                	je     805c9a <tcp_abort+0xb1>
      tcp_segs_free(pcb->unsent);
  805c8e:	83 ec 0c             	sub    $0xc,%esp
  805c91:	50                   	push   %eax
  805c92:	e8 1d fb ff ff       	call   8057b4 <tcp_segs_free>
  805c97:	83 c4 10             	add    $0x10,%esp
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  805c9a:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805c9d:	85 c0                	test   %eax,%eax
  805c9f:	74 0c                	je     805cad <tcp_abort+0xc4>
      tcp_segs_free(pcb->ooseq);
  805ca1:	83 ec 0c             	sub    $0xc,%esp
  805ca4:	50                   	push   %eax
  805ca5:	e8 0a fb ff ff       	call   8057b4 <tcp_segs_free>
  805caa:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  805cad:	83 ec 08             	sub    $0x8,%esp
  805cb0:	53                   	push   %ebx
  805cb1:	6a 02                	push   $0x2
  805cb3:	e8 ff e7 ff ff       	call   8044b7 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805cb8:	83 c4 10             	add    $0x10,%esp
  805cbb:	85 f6                	test   %esi,%esi
  805cbd:	74 0d                	je     805ccc <tcp_abort+0xe3>
  805cbf:	83 ec 08             	sub    $0x8,%esp
  805cc2:	6a fb                	push   $0xfffffffb
  805cc4:	ff 75 cc             	pushl  -0x34(%ebp)
  805cc7:	ff d6                	call   *%esi
  805cc9:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805ccc:	83 ec 08             	sub    $0x8,%esp
  805ccf:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805cd3:	50                   	push   %eax
  805cd4:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805cd8:	50                   	push   %eax
  805cd9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805cdc:	50                   	push   %eax
  805cdd:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805ce0:	50                   	push   %eax
  805ce1:	57                   	push   %edi
  805ce2:	ff 75 d4             	pushl  -0x2c(%ebp)
  805ce5:	e8 8c 27 00 00       	call   808476 <tcp_rst>
  805cea:	83 c4 20             	add    $0x20,%esp
  }
}
  805ced:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805cf0:	5b                   	pop    %ebx
  805cf1:	5e                   	pop    %esi
  805cf2:	5f                   	pop    %edi
  805cf3:	5d                   	pop    %ebp
  805cf4:	c3                   	ret    

00805cf5 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  805cf5:	55                   	push   %ebp
  805cf6:	89 e5                	mov    %esp,%ebp
  805cf8:	57                   	push   %edi
  805cf9:	56                   	push   %esi
  805cfa:	53                   	push   %ebx
  805cfb:	83 ec 1c             	sub    $0x1c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  805cfe:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  805d05:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  805d0b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  805d0f:	bf 00 00 00 00       	mov    $0x0,%edi
  805d14:	e9 53 03 00 00       	jmp    80606c <tcp_slowtmr+0x377>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805d19:	8b 43 10             	mov    0x10(%ebx),%eax
  805d1c:	85 c0                	test   %eax,%eax
  805d1e:	75 17                	jne    805d37 <tcp_slowtmr+0x42>
  805d20:	83 ec 04             	sub    $0x4,%esp
  805d23:	68 78 1b 81 00       	push   $0x811b78
  805d28:	68 36 02 00 00       	push   $0x236
  805d2d:	68 0a 1d 81 00       	push   $0x811d0a
  805d32:	e8 13 87 00 00       	call   80e44a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805d37:	83 f8 01             	cmp    $0x1,%eax
  805d3a:	75 17                	jne    805d53 <tcp_slowtmr+0x5e>
  805d3c:	83 ec 04             	sub    $0x4,%esp
  805d3f:	68 a4 1b 81 00       	push   $0x811ba4
  805d44:	68 37 02 00 00       	push   $0x237
  805d49:	68 0a 1d 81 00       	push   $0x811d0a
  805d4e:	e8 f7 86 00 00       	call   80e44a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805d53:	83 f8 0a             	cmp    $0xa,%eax
  805d56:	75 17                	jne    805d6f <tcp_slowtmr+0x7a>
  805d58:	83 ec 04             	sub    $0x4,%esp
  805d5b:	68 d0 1b 81 00       	push   $0x811bd0
  805d60:	68 38 02 00 00       	push   $0x238
  805d65:	68 0a 1d 81 00       	push   $0x811d0a
  805d6a:	e8 db 86 00 00       	call   80e44a <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805d6f:	83 f8 02             	cmp    $0x2,%eax
  805d72:	75 12                	jne    805d86 <tcp_slowtmr+0x91>
  805d74:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805d78:	80 fa 06             	cmp    $0x6,%dl
  805d7b:	0f 85 ac 03 00 00    	jne    80612d <tcp_slowtmr+0x438>
  805d81:	e9 a0 01 00 00       	jmp    805f26 <tcp_slowtmr+0x231>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d86:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805d8a:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d8f:	80 fa 0c             	cmp    $0xc,%dl
  805d92:	0f 84 ee 00 00 00    	je     805e86 <tcp_slowtmr+0x191>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  805d98:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  805d9f:	84 c9                	test   %cl,%cl
  805da1:	74 54                	je     805df7 <tcp_slowtmr+0x102>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  805da3:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805da9:	83 c0 01             	add    $0x1,%eax
  805dac:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805db2:	0f b6 d1             	movzbl %cl,%edx
  805db5:	0f b6 92 87 1d 81 00 	movzbl 0x811d87(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805dbc:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805dc1:	39 d0                	cmp    %edx,%eax
  805dc3:	0f 82 bd 00 00 00    	jb     805e86 <tcp_slowtmr+0x191>
          pcb->persist_cnt = 0;
  805dc9:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805dd0:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805dd3:	80 f9 06             	cmp    $0x6,%cl
  805dd6:	77 09                	ja     805de1 <tcp_slowtmr+0xec>
            pcb->persist_backoff++;
  805dd8:	83 c1 01             	add    $0x1,%ecx
  805ddb:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  805de1:	83 ec 0c             	sub    $0xc,%esp
  805de4:	53                   	push   %ebx
  805de5:	e8 79 29 00 00       	call   808763 <tcp_zero_window_probe>
  805dea:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805ded:	be 00 00 00 00       	mov    $0x0,%esi
  805df2:	e9 8f 00 00 00       	jmp    805e86 <tcp_slowtmr+0x191>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  805df7:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805dfb:	66 85 c9             	test   %cx,%cx
  805dfe:	78 07                	js     805e07 <tcp_slowtmr+0x112>
          ++pcb->rtime;
  805e00:	83 c1 01             	add    $0x1,%ecx
  805e03:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805e07:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805e0b:	74 74                	je     805e81 <tcp_slowtmr+0x18c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805e0d:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805e12:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  805e16:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  805e1a:	7c 6a                	jl     805e86 <tcp_slowtmr+0x191>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  805e1c:	83 f8 02             	cmp    $0x2,%eax
  805e1f:	74 1f                	je     805e40 <tcp_slowtmr+0x14b>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805e21:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805e25:	66 c1 f8 03          	sar    $0x3,%ax
  805e29:	98                   	cwtl   
  805e2a:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805e2e:	01 c8                	add    %ecx,%eax
  805e30:	0f b6 d2             	movzbl %dl,%edx
  805e33:	0f b6 8a 90 1d 81 00 	movzbl 0x811d90(%edx),%ecx
  805e3a:	d3 e0                	shl    %cl,%eax
  805e3c:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  805e40:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  805e46:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805e4a:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805e4e:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
  805e53:	66 d1 e8             	shr    %ax
  805e56:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  805e5a:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  805e5e:	66 39 d0             	cmp    %dx,%ax
  805e61:	73 07                	jae    805e6a <tcp_slowtmr+0x175>
            pcb->ssthresh = pcb->mss * 2;
  805e63:	8d 04 12             	lea    (%edx,%edx,1),%eax
  805e66:	66 89 43 50          	mov    %ax,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  805e6a:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  805e6e:	83 ec 0c             	sub    $0xc,%esp
  805e71:	53                   	push   %ebx
  805e72:	e8 24 27 00 00       	call   80859b <tcp_rexmit_rto>
  805e77:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805e7a:	be 00 00 00 00       	mov    $0x0,%esi
  805e7f:	eb 05                	jmp    805e86 <tcp_slowtmr+0x191>
  805e81:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  805e86:	8b 43 10             	mov    0x10(%ebx),%eax
  805e89:	83 f8 06             	cmp    $0x6,%eax
  805e8c:	75 21                	jne    805eaf <tcp_slowtmr+0x1ba>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e8e:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e93:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805e96:	83 f8 29             	cmp    $0x29,%eax
  805e99:	89 f0                	mov    %esi,%eax
  805e9b:	1c ff                	sbb    $0xff,%al
  805e9d:	89 c6                	mov    %eax,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805e9f:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805ea2:	85 c9                	test   %ecx,%ecx
  805ea4:	0f 85 8f 00 00 00    	jne    805f39 <tcp_slowtmr+0x244>
  805eaa:	e9 e6 00 00 00       	jmp    805f95 <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805eaf:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805eb3:	74 7d                	je     805f32 <tcp_slowtmr+0x23d>
  805eb5:	83 f8 04             	cmp    $0x4,%eax
  805eb8:	74 05                	je     805ebf <tcp_slowtmr+0x1ca>
  805eba:	83 f8 07             	cmp    $0x7,%eax
  805ebd:	75 73                	jne    805f32 <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ebf:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805ec4:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805ec7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805eca:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ed0:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  805ed6:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805edb:	f7 e2                	mul    %edx
  805edd:	c1 ea 05             	shr    $0x5,%edx
  805ee0:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805ee3:	76 0e                	jbe    805ef3 <tcp_slowtmr+0x1fe>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  805ee5:	83 ec 0c             	sub    $0xc,%esp
  805ee8:	53                   	push   %ebx
  805ee9:	e8 fb fc ff ff       	call   805be9 <tcp_abort>
  805eee:	83 c4 10             	add    $0x10,%esp
  805ef1:	eb 3f                	jmp    805f32 <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ef3:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805efa:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805f00:	01 ca                	add    %ecx,%edx
  805f02:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f07:	f7 e2                	mul    %edx
  805f09:	c1 ea 05             	shr    $0x5,%edx
  805f0c:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805f0f:	76 21                	jbe    805f32 <tcp_slowtmr+0x23d>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  805f11:	83 ec 0c             	sub    $0xc,%esp
  805f14:	53                   	push   %ebx
  805f15:	e8 27 27 00 00       	call   808641 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805f1a:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805f21:	83 c4 10             	add    $0x10,%esp
  805f24:	eb 0c                	jmp    805f32 <tcp_slowtmr+0x23d>
  805f26:	be 01 00 00 00       	mov    $0x1,%esi
  805f2b:	eb 05                	jmp    805f32 <tcp_slowtmr+0x23d>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f2d:	be 01 00 00 00       	mov    $0x1,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805f32:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805f35:	85 c9                	test   %ecx,%ecx
  805f37:	74 29                	je     805f62 <tcp_slowtmr+0x26d>
  805f39:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805f3f:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805f42:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805f46:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805f49:	01 c0                	add    %eax,%eax
  805f4b:	39 c2                	cmp    %eax,%edx
  805f4d:	72 13                	jb     805f62 <tcp_slowtmr+0x26d>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  805f4f:	83 ec 0c             	sub    $0xc,%esp
  805f52:	51                   	push   %ecx
  805f53:	e8 5c f8 ff ff       	call   8057b4 <tcp_segs_free>
      pcb->ooseq = NULL;
  805f58:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805f5f:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  805f62:	8b 43 10             	mov    0x10(%ebx),%eax
  805f65:	83 f8 03             	cmp    $0x3,%eax
  805f68:	75 13                	jne    805f7d <tcp_slowtmr+0x288>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805f6a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805f6f:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805f72:	83 f8 29             	cmp    $0x29,%eax
  805f75:	89 f0                	mov    %esi,%eax
  805f77:	1c ff                	sbb    $0xff,%al
  805f79:	89 c6                	mov    %eax,%esi
  805f7b:	eb 18                	jmp    805f95 <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  805f7d:	83 f8 09             	cmp    $0x9,%eax
  805f80:	75 13                	jne    805f95 <tcp_slowtmr+0x2a0>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805f82:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805f87:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805f8a:	3d f1 00 00 00       	cmp    $0xf1,%eax
  805f8f:	89 f0                	mov    %esi,%eax
  805f91:	1c ff                	sbb    $0xff,%al
  805f93:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805f95:	89 f0                	mov    %esi,%eax
  805f97:	84 c0                	test   %al,%al
  805f99:	0f 84 8a 00 00 00    	je     806029 <tcp_slowtmr+0x334>
      tcp_pcb_purge(pcb);      
  805f9f:	83 ec 0c             	sub    $0xc,%esp
  805fa2:	53                   	push   %ebx
  805fa3:	e8 e8 f8 ff ff       	call   805890 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  805fa8:	83 c4 10             	add    $0x10,%esp
  805fab:	85 ff                	test   %edi,%edi
  805fad:	74 27                	je     805fd6 <tcp_slowtmr+0x2e1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805faf:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fb5:	75 17                	jne    805fce <tcp_slowtmr+0x2d9>
  805fb7:	83 ec 04             	sub    $0x4,%esp
  805fba:	68 00 1c 81 00       	push   $0x811c00
  805fbf:	68 c1 02 00 00       	push   $0x2c1
  805fc4:	68 0a 1d 81 00       	push   $0x811d0a
  805fc9:	e8 7c 84 00 00       	call   80e44a <_panic>
        prev->next = pcb->next;
  805fce:	8b 43 0c             	mov    0xc(%ebx),%eax
  805fd1:	89 47 0c             	mov    %eax,0xc(%edi)
  805fd4:	eb 27                	jmp    805ffd <tcp_slowtmr+0x308>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fd6:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fdc:	74 17                	je     805ff5 <tcp_slowtmr+0x300>
  805fde:	83 ec 04             	sub    $0x4,%esp
  805fe1:	68 2c 1c 81 00       	push   $0x811c2c
  805fe6:	68 c5 02 00 00       	push   $0x2c5
  805feb:	68 0a 1d 81 00       	push   $0x811d0a
  805ff0:	e8 55 84 00 00       	call   80e44a <_panic>
        tcp_active_pcbs = pcb->next;
  805ff5:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ff8:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805ffd:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  806003:	85 c0                	test   %eax,%eax
  806005:	74 0d                	je     806014 <tcp_slowtmr+0x31f>
  806007:	83 ec 08             	sub    $0x8,%esp
  80600a:	6a fb                	push   $0xfffffffb
  80600c:	ff 73 18             	pushl  0x18(%ebx)
  80600f:	ff d0                	call   *%eax
  806011:	83 c4 10             	add    $0x10,%esp

      pcb2 = pcb->next;
  806014:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806017:	83 ec 08             	sub    $0x8,%esp
  80601a:	53                   	push   %ebx
  80601b:	6a 02                	push   $0x2
  80601d:	e8 95 e4 ff ff       	call   8044b7 <memp_free>
  806022:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806025:	89 f3                	mov    %esi,%ebx
  806027:	eb 43                	jmp    80606c <tcp_slowtmr+0x377>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  806029:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  80602d:	83 c0 01             	add    $0x1,%eax
  806030:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  806033:	3a 43 31             	cmp    0x31(%ebx),%al
  806036:	72 2f                	jb     806067 <tcp_slowtmr+0x372>
        pcb->polltmr = 0;
  806038:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80603c:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806042:	85 c0                	test   %eax,%eax
  806044:	74 0f                	je     806055 <tcp_slowtmr+0x360>
  806046:	83 ec 08             	sub    $0x8,%esp
  806049:	53                   	push   %ebx
  80604a:	ff 73 18             	pushl  0x18(%ebx)
  80604d:	ff d0                	call   *%eax
  80604f:	88 45 e3             	mov    %al,-0x1d(%ebp)
  806052:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  806055:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  806059:	75 0c                	jne    806067 <tcp_slowtmr+0x372>
          tcp_output(pcb);
  80605b:	83 ec 0c             	sub    $0xc,%esp
  80605e:	53                   	push   %ebx
  80605f:	e8 9b 1f 00 00       	call   807fff <tcp_output>
  806064:	83 c4 10             	add    $0x10,%esp
        }
      }
      
      prev = pcb;
  806067:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  806069:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80606c:	85 db                	test   %ebx,%ebx
  80606e:	0f 85 a5 fc ff ff    	jne    805d19 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  806074:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  80607a:	e9 a4 00 00 00       	jmp    806123 <tcp_slowtmr+0x42e>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80607f:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806083:	74 17                	je     80609c <tcp_slowtmr+0x3a7>
  806085:	83 ec 04             	sub    $0x4,%esp
  806088:	68 58 1c 81 00       	push   $0x811c58
  80608d:	68 e5 02 00 00       	push   $0x2e5
  806092:	68 0a 1d 81 00       	push   $0x811d0a
  806097:	e8 ae 83 00 00       	call   80e44a <_panic>
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80609c:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8060a1:	2b 46 2c             	sub    0x2c(%esi),%eax
  8060a4:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8060a9:	76 73                	jbe    80611e <tcp_slowtmr+0x429>
      tcp_pcb_purge(pcb);      
  8060ab:	83 ec 0c             	sub    $0xc,%esp
  8060ae:	56                   	push   %esi
  8060af:	e8 dc f7 ff ff       	call   805890 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  8060b4:	83 c4 10             	add    $0x10,%esp
  8060b7:	85 db                	test   %ebx,%ebx
  8060b9:	74 27                	je     8060e2 <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8060bb:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8060c1:	75 17                	jne    8060da <tcp_slowtmr+0x3e5>
  8060c3:	83 ec 04             	sub    $0x4,%esp
  8060c6:	68 88 1c 81 00       	push   $0x811c88
  8060cb:	68 f4 02 00 00       	push   $0x2f4
  8060d0:	68 0a 1d 81 00       	push   $0x811d0a
  8060d5:	e8 70 83 00 00       	call   80e44a <_panic>
        prev->next = pcb->next;
  8060da:	8b 46 0c             	mov    0xc(%esi),%eax
  8060dd:	89 43 0c             	mov    %eax,0xc(%ebx)
  8060e0:	eb 27                	jmp    806109 <tcp_slowtmr+0x414>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8060e2:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8060e8:	74 17                	je     806101 <tcp_slowtmr+0x40c>
  8060ea:	83 ec 04             	sub    $0x4,%esp
  8060ed:	68 b0 1c 81 00       	push   $0x811cb0
  8060f2:	68 f8 02 00 00       	push   $0x2f8
  8060f7:	68 0a 1d 81 00       	push   $0x811d0a
  8060fc:	e8 49 83 00 00       	call   80e44a <_panic>
        tcp_tw_pcbs = pcb->next;
  806101:	8b 46 0c             	mov    0xc(%esi),%eax
  806104:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
      }
      pcb2 = pcb->next;
  806109:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  80610c:	83 ec 08             	sub    $0x8,%esp
  80610f:	56                   	push   %esi
  806110:	6a 02                	push   $0x2
  806112:	e8 a0 e3 ff ff       	call   8044b7 <memp_free>
  806117:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  80611a:	89 fe                	mov    %edi,%esi
  80611c:	eb 05                	jmp    806123 <tcp_slowtmr+0x42e>
    } else {
      prev = pcb;
  80611e:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  806120:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  806123:	85 f6                	test   %esi,%esi
  806125:	0f 85 54 ff ff ff    	jne    80607f <tcp_slowtmr+0x38a>
  80612b:	eb 0e                	jmp    80613b <tcp_slowtmr+0x446>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80612d:	80 fa 0c             	cmp    $0xc,%dl
  806130:	0f 85 62 fc ff ff    	jne    805d98 <tcp_slowtmr+0xa3>
  806136:	e9 f2 fd ff ff       	jmp    805f2d <tcp_slowtmr+0x238>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  80613b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80613e:	5b                   	pop    %ebx
  80613f:	5e                   	pop    %esi
  806140:	5f                   	pop    %edi
  806141:	5d                   	pop    %ebp
  806142:	c3                   	ret    

00806143 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  806143:	55                   	push   %ebp
  806144:	89 e5                	mov    %esp,%ebp
  806146:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806149:	e8 ad f5 ff ff       	call   8056fb <tcp_fasttmr>

  if (++tcp_timer & 1) {
  80614e:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  806155:	83 c0 01             	add    $0x1,%eax
  806158:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  80615d:	a8 01                	test   $0x1,%al
  80615f:	74 05                	je     806166 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  806161:	e8 8f fb ff ff       	call   805cf5 <tcp_slowtmr>
  }
}
  806166:	c9                   	leave  
  806167:	c3                   	ret    

00806168 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806168:	55                   	push   %ebp
  806169:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80616b:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806170:	03 05 08 40 81 00    	add    0x814008,%eax
  806176:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  80617b:	5d                   	pop    %ebp
  80617c:	c3                   	ret    

0080617d <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80617d:	55                   	push   %ebp
  80617e:	89 e5                	mov    %esp,%ebp
  806180:	57                   	push   %edi
  806181:	56                   	push   %esi
  806182:	53                   	push   %ebx
  806183:	83 ec 28             	sub    $0x28,%esp
  806186:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  80618a:	6a 02                	push   $0x2
  80618c:	e8 d0 e2 ff ff       	call   804461 <memp_malloc>
  806191:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  806193:	83 c4 10             	add    $0x10,%esp
  806196:	85 c0                	test   %eax,%eax
  806198:	0f 85 bd 00 00 00    	jne    80625b <tcp_alloc+0xde>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80619e:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061a3:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8061a9:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8061ae:	bf 00 00 00 00       	mov    $0x0,%edi
  8061b3:	eb 10                	jmp    8061c5 <tcp_alloc+0x48>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061b5:	89 f2                	mov    %esi,%edx
  8061b7:	2b 50 2c             	sub    0x2c(%eax),%edx
  8061ba:	39 ca                	cmp    %ecx,%edx
  8061bc:	72 04                	jb     8061c2 <tcp_alloc+0x45>
      inactivity = tcp_ticks - pcb->tmr;
  8061be:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8061c0:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061c2:	8b 40 0c             	mov    0xc(%eax),%eax
  8061c5:	85 c0                	test   %eax,%eax
  8061c7:	75 ec                	jne    8061b5 <tcp_alloc+0x38>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8061c9:	85 ff                	test   %edi,%edi
  8061cb:	74 0c                	je     8061d9 <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8061cd:	83 ec 0c             	sub    $0xc,%esp
  8061d0:	57                   	push   %edi
  8061d1:	e8 13 fa ff ff       	call   805be9 <tcp_abort>
  8061d6:	83 c4 10             	add    $0x10,%esp
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8061d9:	83 ec 0c             	sub    $0xc,%esp
  8061dc:	6a 02                	push   $0x2
  8061de:	e8 7e e2 ff ff       	call   804461 <memp_malloc>
  8061e3:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  8061e5:	83 c4 10             	add    $0x10,%esp
  8061e8:	85 c0                	test   %eax,%eax
  8061ea:	75 6f                	jne    80625b <tcp_alloc+0xde>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8061ec:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061f1:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8061f7:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8061fc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  inactive = NULL;
  806203:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80620a:	eb 21                	jmp    80622d <tcp_alloc+0xb0>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80620c:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  806210:	38 d3                	cmp    %dl,%bl
  806212:	72 16                	jb     80622a <tcp_alloc+0xad>
  806214:	38 ca                	cmp    %cl,%dl
  806216:	77 12                	ja     80622a <tcp_alloc+0xad>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806218:	89 fe                	mov    %edi,%esi
  80621a:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  80621d:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  806220:	72 08                	jb     80622a <tcp_alloc+0xad>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  806222:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  806224:	89 75 e4             	mov    %esi,-0x1c(%ebp)
      inactive = pcb;
  806227:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80622a:	8b 40 0c             	mov    0xc(%eax),%eax
  80622d:	85 c0                	test   %eax,%eax
  80622f:	75 db                	jne    80620c <tcp_alloc+0x8f>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  806231:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806234:	85 c0                	test   %eax,%eax
  806236:	74 0c                	je     806244 <tcp_alloc+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806238:	83 ec 0c             	sub    $0xc,%esp
  80623b:	50                   	push   %eax
  80623c:	e8 a8 f9 ff ff       	call   805be9 <tcp_abort>
  806241:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  806244:	83 ec 0c             	sub    $0xc,%esp
  806247:	6a 02                	push   $0x2
  806249:	e8 13 e2 ff ff       	call   804461 <memp_malloc>
  80624e:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  806250:	83 c4 10             	add    $0x10,%esp
  806253:	85 c0                	test   %eax,%eax
  806255:	0f 84 96 00 00 00    	je     8062f1 <tcp_alloc+0x174>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  80625b:	83 ec 04             	sub    $0x4,%esp
  80625e:	68 a8 00 00 00       	push   $0xa8
  806263:	6a 00                	push   $0x0
  806265:	56                   	push   %esi
  806266:	e8 82 89 00 00       	call   80ebed <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  80626b:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  80626f:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  806275:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  80627b:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  806281:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  806287:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  80628b:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80628f:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806295:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  80629b:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8062a1:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  8062a7:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  8062ad:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  8062b3:	e8 b0 fe ff ff       	call   806168 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8062b8:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  8062bb:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  8062be:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  8062c1:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  8062c4:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  8062c7:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8062cc:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  8062cf:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8062d3:	c7 86 88 00 00 00 ad 	movl   $0x805bad,0x88(%esi)
  8062da:	5b 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8062dd:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  8062e4:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8062e7:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  8062ee:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8062f1:	89 f0                	mov    %esi,%eax
  8062f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8062f6:	5b                   	pop    %ebx
  8062f7:	5e                   	pop    %esi
  8062f8:	5f                   	pop    %edi
  8062f9:	5d                   	pop    %ebp
  8062fa:	c3                   	ret    

008062fb <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8062fb:	55                   	push   %ebp
  8062fc:	89 e5                	mov    %esp,%ebp
  8062fe:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806301:	6a 40                	push   $0x40
  806303:	e8 75 fe ff ff       	call   80617d <tcp_alloc>
}
  806308:	c9                   	leave  
  806309:	c3                   	ret    

0080630a <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  80630a:	55                   	push   %ebp
  80630b:	89 e5                	mov    %esp,%ebp
  80630d:	56                   	push   %esi
  80630e:	53                   	push   %ebx
  80630f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806312:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806314:	83 ec 0c             	sub    $0xc,%esp
  806317:	ff 75 0c             	pushl  0xc(%ebp)
  80631a:	e8 00 02 00 00       	call   80651f <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80631f:	83 c4 10             	add    $0x10,%esp
  806322:	85 c0                	test   %eax,%eax
  806324:	74 14                	je     80633a <tcp_eff_send_mss+0x30>
  806326:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80632a:	66 85 c0             	test   %ax,%ax
  80632d:	74 0b                	je     80633a <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80632f:	83 e8 28             	sub    $0x28,%eax
  806332:	66 39 c3             	cmp    %ax,%bx
  806335:	0f 46 c3             	cmovbe %ebx,%eax
  806338:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  80633a:	89 f0                	mov    %esi,%eax
  80633c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80633f:	5b                   	pop    %ebx
  806340:	5e                   	pop    %esi
  806341:	5d                   	pop    %ebp
  806342:	c3                   	ret    

00806343 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  806343:	55                   	push   %ebp
  806344:	89 e5                	mov    %esp,%ebp
  806346:	57                   	push   %edi
  806347:	56                   	push   %esi
  806348:	53                   	push   %ebx
  806349:	83 ec 1c             	sub    $0x1c,%esp
  80634c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80634f:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806352:	8b 7d 08             	mov    0x8(%ebp),%edi
  806355:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  806359:	74 17                	je     806372 <tcp_connect+0x2f>
  80635b:	83 ec 04             	sub    $0x4,%esp
  80635e:	68 d8 1c 81 00       	push   $0x811cd8
  806363:	68 ec 01 00 00       	push   $0x1ec
  806368:	68 0a 1d 81 00       	push   $0x811d0a
  80636d:	e8 d8 80 00 00       	call   80e44a <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  806372:	85 f6                	test   %esi,%esi
  806374:	0f 84 4c 01 00 00    	je     8064c6 <tcp_connect+0x183>
    pcb->remote_ip = *ipaddr;
  80637a:	8b 16                	mov    (%esi),%edx
  80637c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80637f:	89 57 04             	mov    %edx,0x4(%edi)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806382:	66 89 47 1e          	mov    %ax,0x1e(%edi)
  if (pcb->local_port == 0) {
  806386:	66 83 7f 1c 00       	cmpw   $0x0,0x1c(%edi)
  80638b:	75 0c                	jne    806399 <tcp_connect+0x56>
    pcb->local_port = tcp_new_port();
  80638d:	e8 ad ef ff ff       	call   80533f <tcp_new_port>
  806392:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806395:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  806399:	e8 ca fd ff ff       	call   806168 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  80639e:	8b 7d 08             	mov    0x8(%ebp),%edi
  8063a1:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%edi)
  pcb->snd_nxt = iss;
  8063a8:	89 47 54             	mov    %eax,0x54(%edi)
  pcb->lastack = iss - 1;
  8063ab:	83 e8 01             	sub    $0x1,%eax
  8063ae:	89 47 48             	mov    %eax,0x48(%edi)
  pcb->snd_lbb = iss - 1;
  8063b1:	89 47 68             	mov    %eax,0x68(%edi)
  pcb->rcv_wnd = TCP_WND;
  8063b4:	66 c7 47 28 c0 5d    	movw   $0x5dc0,0x28(%edi)
  pcb->rcv_ann_wnd = TCP_WND;
  8063ba:	66 c7 47 2a c0 5d    	movw   $0x5dc0,0x2a(%edi)
  pcb->snd_wnd = TCP_WND;
  8063c0:	66 c7 47 5c c0 5d    	movw   $0x5dc0,0x5c(%edi)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8063c6:	66 c7 47 34 18 02    	movw   $0x218,0x34(%edi)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8063cc:	83 ec 08             	sub    $0x8,%esp
  8063cf:	56                   	push   %esi
  8063d0:	68 18 02 00 00       	push   $0x218
  8063d5:	e8 30 ff ff ff       	call   80630a <tcp_eff_send_mss>
  8063da:	8b 7d 08             	mov    0x8(%ebp),%edi
  8063dd:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8063e1:	66 c7 47 4e 01 00    	movw   $0x1,0x4e(%edi)
  pcb->ssthresh = pcb->mss * 10;
  8063e7:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8063ea:	01 c0                	add    %eax,%eax
  8063ec:	66 89 47 50          	mov    %ax,0x50(%edi)
  pcb->state = SYN_SENT;
  8063f0:	c7 47 10 02 00 00 00 	movl   $0x2,0x10(%edi)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8063f7:	8b 45 14             	mov    0x14(%ebp),%eax
  8063fa:	89 87 8c 00 00 00    	mov    %eax,0x8c(%edi)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806400:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  806406:	83 c4 10             	add    $0x10,%esp
  806409:	39 d7                	cmp    %edx,%edi
  80640b:	75 0a                	jne    806417 <tcp_connect+0xd4>
  80640d:	8b 47 0c             	mov    0xc(%edi),%eax
  806410:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  806415:	eb 55                	jmp    80646c <tcp_connect+0x129>
  806417:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80641d:	bf 00 00 00 00       	mov    $0x0,%edi
  806422:	eb 34                	jmp    806458 <tcp_connect+0x115>
  806424:	8b 42 0c             	mov    0xc(%edx),%eax
  806427:	39 45 08             	cmp    %eax,0x8(%ebp)
  80642a:	0f 94 c1             	sete   %cl
  80642d:	89 ce                	mov    %ecx,%esi
  80642f:	85 c0                	test   %eax,%eax
  806431:	0f 95 c1             	setne  %cl
  806434:	89 f3                	mov    %esi,%ebx
  806436:	84 cb                	test   %cl,%bl
  806438:	74 17                	je     806451 <tcp_connect+0x10e>
  80643a:	89 f8                	mov    %edi,%eax
  80643c:	84 c0                	test   %al,%al
  80643e:	74 06                	je     806446 <tcp_connect+0x103>
  806440:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806446:	8b 45 08             	mov    0x8(%ebp),%eax
  806449:	8b 40 0c             	mov    0xc(%eax),%eax
  80644c:	89 42 0c             	mov    %eax,0xc(%edx)
  80644f:	eb 1b                	jmp    80646c <tcp_connect+0x129>
  806451:	bf 01 00 00 00       	mov    $0x1,%edi
  806456:	89 c2                	mov    %eax,%edx
  806458:	85 d2                	test   %edx,%edx
  80645a:	75 c8                	jne    806424 <tcp_connect+0xe1>
  80645c:	89 f8                	mov    %edi,%eax
  80645e:	84 c0                	test   %al,%al
  806460:	74 0a                	je     80646c <tcp_connect+0x129>
  806462:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  806469:	00 00 00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80646c:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  806471:	8b 7d 08             	mov    0x8(%ebp),%edi
  806474:	89 47 0c             	mov    %eax,0xc(%edi)
  806477:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  80647d:	e8 e7 bd ff ff       	call   802269 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  806482:	83 ec 0c             	sub    $0xc,%esp
  806485:	68 b4 05 04 02       	push   $0x20405b4
  80648a:	e8 66 12 00 00       	call   8076f5 <htonl>
  80648f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806492:	83 c4 0c             	add    $0xc,%esp
  806495:	6a 04                	push   $0x4
  806497:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80649a:	50                   	push   %eax
  80649b:	6a 00                	push   $0x0
  80649d:	6a 02                	push   $0x2
  80649f:	6a 00                	push   $0x0
  8064a1:	6a 00                	push   $0x0
  8064a3:	ff 75 08             	pushl  0x8(%ebp)
  8064a6:	e8 7b 14 00 00       	call   807926 <tcp_enqueue>
  8064ab:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8064ad:	83 c4 20             	add    $0x20,%esp
  8064b0:	84 c0                	test   %al,%al
  8064b2:	75 17                	jne    8064cb <tcp_connect+0x188>
    tcp_output(pcb);
  8064b4:	83 ec 0c             	sub    $0xc,%esp
  8064b7:	ff 75 08             	pushl  0x8(%ebp)
  8064ba:	e8 40 1b 00 00       	call   807fff <tcp_output>
  8064bf:	83 c4 10             	add    $0x10,%esp
  }
  return ret;
  8064c2:	89 f0                	mov    %esi,%eax
  8064c4:	eb 05                	jmp    8064cb <tcp_connect+0x188>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  8064c6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  8064cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8064ce:	5b                   	pop    %ebx
  8064cf:	5e                   	pop    %esi
  8064d0:	5f                   	pop    %edi
  8064d1:	5d                   	pop    %ebp
  8064d2:	c3                   	ret    

008064d3 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8064d3:	55                   	push   %ebp
  8064d4:	89 e5                	mov    %esp,%ebp
  8064d6:	53                   	push   %ebx
  8064d7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8064da:	8b 45 08             	mov    0x8(%ebp),%eax
  8064dd:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8064df:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8064e2:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8064e7:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8064ea:	77 30                	ja     80651c <ip_addr_isbroadcast+0x49>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8064ec:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  8064f0:	83 e0 02             	and    $0x2,%eax
  8064f3:	74 27                	je     80651c <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8064f5:	8b 41 04             	mov    0x4(%ecx),%eax
  8064f8:	39 c2                	cmp    %eax,%edx
  8064fa:	74 1b                	je     806517 <ip_addr_isbroadcast+0x44>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8064fc:	8b 59 08             	mov    0x8(%ecx),%ebx
  8064ff:	31 d0                	xor    %edx,%eax
  806501:	89 c1                	mov    %eax,%ecx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  806503:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806508:	85 d9                	test   %ebx,%ecx
  80650a:	75 10                	jne    80651c <ip_addr_isbroadcast+0x49>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  80650c:	f7 d3                	not    %ebx

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80650e:	21 da                	and    %ebx,%edx
  806510:	39 da                	cmp    %ebx,%edx
  806512:	0f 94 c0             	sete   %al
  806515:	eb 05                	jmp    80651c <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806517:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80651c:	5b                   	pop    %ebx
  80651d:	5d                   	pop    %ebp
  80651e:	c3                   	ret    

0080651f <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80651f:	55                   	push   %ebp
  806520:	89 e5                	mov    %esp,%ebp
  806522:	56                   	push   %esi
  806523:	53                   	push   %ebx
  806524:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806527:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  80652d:	eb 1c                	jmp    80654b <ip_route+0x2c>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  80652f:	83 ec 0c             	sub    $0xc,%esp
  806532:	53                   	push   %ebx
  806533:	e8 11 e2 ff ff       	call   804749 <netif_is_up>
  806538:	83 c4 10             	add    $0x10,%esp
  80653b:	84 c0                	test   %al,%al
  80653d:	74 0a                	je     806549 <ip_route+0x2a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  80653f:	8b 06                	mov    (%esi),%eax
  806541:	33 43 04             	xor    0x4(%ebx),%eax
  806544:	85 43 08             	test   %eax,0x8(%ebx)
  806547:	74 2b                	je     806574 <ip_route+0x55>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806549:	8b 1b                	mov    (%ebx),%ebx
  80654b:	85 db                	test   %ebx,%ebx
  80654d:	75 e0                	jne    80652f <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80654f:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  806554:	85 c0                	test   %eax,%eax
  806556:	74 1e                	je     806576 <ip_route+0x57>
  806558:	83 ec 0c             	sub    $0xc,%esp
  80655b:	50                   	push   %eax
  80655c:	e8 e8 e1 ff ff       	call   804749 <netif_is_up>
  806561:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806564:	84 c0                	test   %al,%al
  806566:	b8 00 00 00 00       	mov    $0x0,%eax
  80656b:	0f 45 05 38 b2 b3 00 	cmovne 0xb3b238,%eax
  806572:	eb 02                	jmp    806576 <ip_route+0x57>
  806574:	89 d8                	mov    %ebx,%eax
}
  806576:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806579:	5b                   	pop    %ebx
  80657a:	5e                   	pop    %esi
  80657b:	5d                   	pop    %ebp
  80657c:	c3                   	ret    

0080657d <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80657d:	55                   	push   %ebp
  80657e:	89 e5                	mov    %esp,%ebp
  806580:	57                   	push   %edi
  806581:	56                   	push   %esi
  806582:	53                   	push   %ebx
  806583:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806586:	8b 45 08             	mov    0x8(%ebp),%eax
  806589:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  80658c:	0f b7 06             	movzwl (%esi),%eax
  80658f:	50                   	push   %eax
  806590:	e8 53 11 00 00       	call   8076e8 <ntohs>
  806595:	66 c1 e8 0c          	shr    $0xc,%ax
  806599:	83 c4 10             	add    $0x10,%esp
  80659c:	66 83 f8 04          	cmp    $0x4,%ax
  8065a0:	74 13                	je     8065b5 <ip_input+0x38>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8065a2:	83 ec 0c             	sub    $0xc,%esp
  8065a5:	ff 75 08             	pushl  0x8(%ebp)
  8065a8:	e8 7d e2 ff ff       	call   80482a <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8065ad:	83 c4 10             	add    $0x10,%esp
  8065b0:	e9 bf 02 00 00       	jmp    806874 <ip_input+0x2f7>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  8065b5:	83 ec 0c             	sub    $0xc,%esp
  8065b8:	0f b7 06             	movzwl (%esi),%eax
  8065bb:	50                   	push   %eax
  8065bc:	e8 27 11 00 00       	call   8076e8 <ntohs>
  8065c1:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  8065c5:	83 e0 3c             	and    $0x3c,%eax
  8065c8:	89 c7                	mov    %eax,%edi
  8065ca:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8065ce:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8065d2:	89 04 24             	mov    %eax,(%esp)
  8065d5:	e8 0e 11 00 00       	call   8076e8 <ntohs>
  8065da:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8065dc:	83 c4 10             	add    $0x10,%esp
  8065df:	8b 55 08             	mov    0x8(%ebp),%edx
  8065e2:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  8065e6:	77 06                	ja     8065ee <ip_input+0x71>
  8065e8:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  8065ec:	76 13                	jbe    806601 <ip_input+0x84>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8065ee:	83 ec 0c             	sub    $0xc,%esp
  8065f1:	ff 75 08             	pushl  0x8(%ebp)
  8065f4:	e8 31 e2 ff ff       	call   80482a <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8065f9:	83 c4 10             	add    $0x10,%esp
  8065fc:	e9 73 02 00 00       	jmp    806874 <ip_input+0x2f7>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806601:	83 ec 08             	sub    $0x8,%esp
  806604:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806608:	50                   	push   %eax
  806609:	56                   	push   %esi
  80660a:	e8 a7 0f 00 00       	call   8075b6 <inet_chksum>
  80660f:	83 c4 10             	add    $0x10,%esp
  806612:	66 85 c0             	test   %ax,%ax
  806615:	74 13                	je     80662a <ip_input+0xad>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806617:	83 ec 0c             	sub    $0xc,%esp
  80661a:	ff 75 08             	pushl  0x8(%ebp)
  80661d:	e8 08 e2 ff ff       	call   80482a <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806622:	83 c4 10             	add    $0x10,%esp
  806625:	e9 4a 02 00 00       	jmp    806874 <ip_input+0x2f7>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  80662a:	83 ec 08             	sub    $0x8,%esp
  80662d:	0f b7 db             	movzwl %bx,%ebx
  806630:	53                   	push   %ebx
  806631:	ff 75 08             	pushl  0x8(%ebp)
  806634:	e8 3a e5 ff ff       	call   804b73 <pbuf_realloc>
  806639:	83 c4 10             	add    $0x10,%esp
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  80663c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  80663f:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806644:	8d 46 10             	lea    0x10(%esi),%eax
  806647:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80664a:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  80664d:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80664f:	83 ec 0c             	sub    $0xc,%esp
  806652:	53                   	push   %ebx
  806653:	e8 f1 e0 ff ff       	call   804749 <netif_is_up>
  806658:	83 c4 10             	add    $0x10,%esp
  80665b:	84 c0                	test   %al,%al
  80665d:	74 27                	je     806686 <ip_input+0x109>
  80665f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806662:	74 22                	je     806686 <ip_input+0x109>
  806664:	8b 43 04             	mov    0x4(%ebx),%eax
  806667:	85 c0                	test   %eax,%eax
  806669:	74 1b                	je     806686 <ip_input+0x109>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80666b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80666e:	3b 41 10             	cmp    0x10(%ecx),%eax
  806671:	74 35                	je     8066a8 <ip_input+0x12b>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806673:	83 ec 08             	sub    $0x8,%esp
  806676:	53                   	push   %ebx
  806677:	ff 75 dc             	pushl  -0x24(%ebp)
  80667a:	e8 54 fe ff ff       	call   8064d3 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80667f:	83 c4 10             	add    $0x10,%esp
  806682:	84 c0                	test   %al,%al
  806684:	75 22                	jne    8066a8 <ip_input+0x12b>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806686:	85 ff                	test   %edi,%edi
  806688:	74 08                	je     806692 <ip_input+0x115>
        first = 0;
        netif = netif_list;
  80668a:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806690:	eb 02                	jmp    806694 <ip_input+0x117>
      } else {
        netif = netif->next;
  806692:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  806694:	39 f3                	cmp    %esi,%ebx
  806696:	75 02                	jne    80669a <ip_input+0x11d>
        netif = netif->next;
  806698:	8b 1e                	mov    (%esi),%ebx
  80669a:	bf 00 00 00 00       	mov    $0x0,%edi
      }
    } while(netif != NULL);
  80669f:	85 db                	test   %ebx,%ebx
  8066a1:	75 ac                	jne    80664f <ip_input+0xd2>
  8066a3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8066a6:	eb 0b                	jmp    8066b3 <ip_input+0x136>
  8066a8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  8066ab:	85 db                	test   %ebx,%ebx
  8066ad:	0f 85 a2 01 00 00    	jne    806855 <ip_input+0x2d8>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8066b3:	83 ec 0c             	sub    $0xc,%esp
  8066b6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8066ba:	50                   	push   %eax
  8066bb:	e8 28 10 00 00       	call   8076e8 <ntohs>
  8066c0:	83 c4 10             	add    $0x10,%esp
  8066c3:	bb 00 00 00 00       	mov    $0x0,%ebx
  8066c8:	3c 11                	cmp    $0x11,%al
  8066ca:	0f 85 85 01 00 00    	jne    806855 <ip_input+0x2d8>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8066d0:	83 ec 0c             	sub    $0xc,%esp
  8066d3:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8066d7:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  8066dc:	50                   	push   %eax
  8066dd:	e8 06 10 00 00       	call   8076e8 <ntohs>
  8066e2:	83 c4 10             	add    $0x10,%esp
  8066e5:	66 83 f8 44          	cmp    $0x44,%ax
  8066e9:	74 3d                	je     806728 <ip_input+0x1ab>
  8066eb:	e9 65 01 00 00       	jmp    806855 <ip_input+0x2d8>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8066f0:	8b 7e 0c             	mov    0xc(%esi),%edi
  8066f3:	83 ec 0c             	sub    $0xc,%esp
  8066f6:	68 00 00 00 f0       	push   $0xf0000000
  8066fb:	e8 16 12 00 00       	call   807916 <ntohl>
  806700:	21 c7                	and    %eax,%edi
  806702:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806709:	e8 08 12 00 00       	call   807916 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80670e:	83 c4 10             	add    $0x10,%esp
  806711:	39 c7                	cmp    %eax,%edi
  806713:	75 16                	jne    80672b <ip_input+0x1ae>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806715:	83 ec 0c             	sub    $0xc,%esp
  806718:	ff 75 08             	pushl  0x8(%ebp)
  80671b:	e8 0a e1 ff ff       	call   80482a <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806720:	83 c4 10             	add    $0x10,%esp
  806723:	e9 4c 01 00 00       	jmp    806874 <ip_input+0x2f7>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806728:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  80672b:	85 db                	test   %ebx,%ebx
  80672d:	75 13                	jne    806742 <ip_input+0x1c5>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  80672f:	83 ec 0c             	sub    $0xc,%esp
  806732:	ff 75 08             	pushl  0x8(%ebp)
  806735:	e8 f0 e0 ff ff       	call   80482a <pbuf_free>
    return ERR_OK;
  80673a:	83 c4 10             	add    $0x10,%esp
  80673d:	e9 32 01 00 00       	jmp    806874 <ip_input+0x2f7>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806742:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806746:	83 ec 0c             	sub    $0xc,%esp
  806749:	68 ff 3f 00 00       	push   $0x3fff
  80674e:	e8 88 0f 00 00       	call   8076db <htons>
  806753:	83 c4 10             	add    $0x10,%esp
  806756:	66 85 c3             	test   %ax,%bx
  806759:	74 1c                	je     806777 <ip_input+0x1fa>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  80675b:	83 ec 0c             	sub    $0xc,%esp
  80675e:	ff 75 08             	pushl  0x8(%ebp)
  806761:	e8 18 05 00 00       	call   806c7e <ip_reass>
  806766:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806769:	83 c4 10             	add    $0x10,%esp
  80676c:	85 c0                	test   %eax,%eax
  80676e:	0f 84 00 01 00 00    	je     806874 <ip_input+0x2f7>
      return ERR_OK;
    }
    iphdr = p->payload;
  806774:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806777:	83 ec 08             	sub    $0x8,%esp
  80677a:	ff 75 0c             	pushl  0xc(%ebp)
  80677d:	ff 75 08             	pushl  0x8(%ebp)
  806780:	e8 d9 74 00 00       	call   80dc5e <raw_input>
  806785:	83 c4 10             	add    $0x10,%esp
  806788:	84 c0                	test   %al,%al
  80678a:	0f 85 e4 00 00 00    	jne    806874 <ip_input+0x2f7>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806790:	83 ec 0c             	sub    $0xc,%esp
  806793:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806797:	50                   	push   %eax
  806798:	e8 4b 0f 00 00       	call   8076e8 <ntohs>
  80679d:	83 c4 10             	add    $0x10,%esp
  8067a0:	0f b6 c0             	movzbl %al,%eax
  8067a3:	66 83 f8 06          	cmp    $0x6,%ax
  8067a7:	74 24                	je     8067cd <ip_input+0x250>
  8067a9:	66 83 f8 11          	cmp    $0x11,%ax
  8067ad:	74 08                	je     8067b7 <ip_input+0x23a>
  8067af:	66 83 f8 01          	cmp    $0x1,%ax
  8067b3:	75 41                	jne    8067f6 <ip_input+0x279>
  8067b5:	eb 2c                	jmp    8067e3 <ip_input+0x266>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  8067b7:	83 ec 08             	sub    $0x8,%esp
  8067ba:	ff 75 0c             	pushl  0xc(%ebp)
  8067bd:	ff 75 08             	pushl  0x8(%ebp)
  8067c0:	e8 e5 20 00 00       	call   8088aa <udp_input>
      break;
  8067c5:	83 c4 10             	add    $0x10,%esp
  8067c8:	e9 a7 00 00 00       	jmp    806874 <ip_input+0x2f7>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  8067cd:	83 ec 08             	sub    $0x8,%esp
  8067d0:	ff 75 0c             	pushl  0xc(%ebp)
  8067d3:	ff 75 08             	pushl  0x8(%ebp)
  8067d6:	e8 10 67 00 00       	call   80ceeb <tcp_input>
      break;
  8067db:	83 c4 10             	add    $0x10,%esp
  8067de:	e9 91 00 00 00       	jmp    806874 <ip_input+0x2f7>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  8067e3:	83 ec 08             	sub    $0x8,%esp
  8067e6:	ff 75 0c             	pushl  0xc(%ebp)
  8067e9:	ff 75 08             	pushl  0x8(%ebp)
  8067ec:	e8 29 77 00 00       	call   80df1a <icmp_input>
      break;
  8067f1:	83 c4 10             	add    $0x10,%esp
  8067f4:	eb 7e                	jmp    806874 <ip_input+0x2f7>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8067f6:	83 ec 08             	sub    $0x8,%esp
  8067f9:	ff 75 0c             	pushl  0xc(%ebp)
  8067fc:	8d 46 10             	lea    0x10(%esi),%eax
  8067ff:	50                   	push   %eax
  806800:	e8 ce fc ff ff       	call   8064d3 <ip_addr_isbroadcast>
  806805:	83 c4 10             	add    $0x10,%esp
  806808:	84 c0                	test   %al,%al
  80680a:	75 39                	jne    806845 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  80680c:	8b 5e 10             	mov    0x10(%esi),%ebx
  80680f:	83 ec 0c             	sub    $0xc,%esp
  806812:	68 00 00 00 f0       	push   $0xf0000000
  806817:	e8 fa 10 00 00       	call   807916 <ntohl>
  80681c:	21 c3                	and    %eax,%ebx
  80681e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806825:	e8 ec 10 00 00       	call   807916 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80682a:	83 c4 10             	add    $0x10,%esp
  80682d:	39 c3                	cmp    %eax,%ebx
  80682f:	74 14                	je     806845 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806831:	8b 45 08             	mov    0x8(%ebp),%eax
  806834:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806837:	83 ec 08             	sub    $0x8,%esp
  80683a:	6a 02                	push   $0x2
  80683c:	50                   	push   %eax
  80683d:	e8 ea 79 00 00       	call   80e22c <icmp_dest_unreach>
  806842:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806845:	83 ec 0c             	sub    $0xc,%esp
  806848:	ff 75 08             	pushl  0x8(%ebp)
  80684b:	e8 da df ff ff       	call   80482a <pbuf_free>
  806850:	83 c4 10             	add    $0x10,%esp
  806853:	eb 1f                	jmp    806874 <ip_input+0x2f7>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806855:	83 ec 08             	sub    $0x8,%esp
  806858:	ff 75 0c             	pushl  0xc(%ebp)
  80685b:	8d 46 0c             	lea    0xc(%esi),%eax
  80685e:	50                   	push   %eax
  80685f:	e8 6f fc ff ff       	call   8064d3 <ip_addr_isbroadcast>
  806864:	83 c4 10             	add    $0x10,%esp
  806867:	84 c0                	test   %al,%al
  806869:	0f 84 81 fe ff ff    	je     8066f0 <ip_input+0x173>
  80686f:	e9 a1 fe ff ff       	jmp    806715 <ip_input+0x198>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806874:	b8 00 00 00 00       	mov    $0x0,%eax
  806879:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80687c:	5b                   	pop    %ebx
  80687d:	5e                   	pop    %esi
  80687e:	5f                   	pop    %edi
  80687f:	5d                   	pop    %ebp
  806880:	c3                   	ret    

00806881 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806881:	55                   	push   %ebp
  806882:	89 e5                	mov    %esp,%ebp
  806884:	57                   	push   %edi
  806885:	56                   	push   %esi
  806886:	53                   	push   %ebx
  806887:	83 ec 1c             	sub    $0x1c,%esp
  80688a:	8b 75 08             	mov    0x8(%ebp),%esi
  80688d:	8b 7d 14             	mov    0x14(%ebp),%edi
  806890:	8b 45 18             	mov    0x18(%ebp),%eax
  806893:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806896:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806899:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80689c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8068a0:	0f 84 12 01 00 00    	je     8069b8 <ip_output_if+0x137>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8068a6:	83 ec 08             	sub    $0x8,%esp
  8068a9:	6a 14                	push   $0x14
  8068ab:	56                   	push   %esi
  8068ac:	e8 a7 de ff ff       	call   804758 <pbuf_header>
  8068b1:	83 c4 10             	add    $0x10,%esp
  8068b4:	84 c0                	test   %al,%al
  8068b6:	0f 85 40 01 00 00    	jne    8069fc <ip_output_if+0x17b>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  8068bc:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8068bf:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  8068c4:	77 17                	ja     8068dd <ip_output_if+0x5c>
  8068c6:	83 ec 04             	sub    $0x4,%esp
  8068c9:	68 a8 1d 81 00       	push   $0x811da8
  8068ce:	68 ee 01 00 00       	push   $0x1ee
  8068d3:	68 d5 1d 81 00       	push   $0x811dd5
  8068d8:	e8 6d 7b 00 00       	call   80e44a <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8068dd:	83 ec 0c             	sub    $0xc,%esp
  8068e0:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8068e4:	50                   	push   %eax
  8068e5:	e8 fe 0d 00 00       	call   8076e8 <ntohs>
  8068ea:	0f b6 c0             	movzbl %al,%eax
  8068ed:	c1 e7 08             	shl    $0x8,%edi
  8068f0:	09 c7                	or     %eax,%edi
  8068f2:	0f b7 ff             	movzwl %di,%edi
  8068f5:	89 3c 24             	mov    %edi,(%esp)
  8068f8:	e8 de 0d 00 00       	call   8076db <htons>
  8068fd:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806901:	0f b7 c0             	movzwl %ax,%eax
  806904:	89 04 24             	mov    %eax,(%esp)
  806907:	e8 dc 0d 00 00       	call   8076e8 <ntohs>
  80690c:	25 00 ff 00 00       	and    $0xff00,%eax
  806911:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806915:	09 d0                	or     %edx,%eax
  806917:	0f b7 c0             	movzwl %ax,%eax
  80691a:	89 04 24             	mov    %eax,(%esp)
  80691d:	e8 b9 0d 00 00       	call   8076db <htons>
  806922:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806926:	8b 45 10             	mov    0x10(%ebp),%eax
  806929:	8b 00                	mov    (%eax),%eax
  80692b:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  80692e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806932:	80 cc 45             	or     $0x45,%ah
  806935:	89 04 24             	mov    %eax,(%esp)
  806938:	e8 9e 0d 00 00       	call   8076db <htons>
  80693d:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806940:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806944:	89 04 24             	mov    %eax,(%esp)
  806947:	e8 8f 0d 00 00       	call   8076db <htons>
  80694c:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806950:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806956:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  80695d:	89 04 24             	mov    %eax,(%esp)
  806960:	e8 76 0d 00 00       	call   8076db <htons>
  806965:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806969:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  806970:	01 

    if (ip_addr_isany(src)) {
  806971:	83 c4 10             	add    $0x10,%esp
  806974:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806978:	74 09                	je     806983 <ip_output_if+0x102>
  80697a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80697d:	8b 00                	mov    (%eax),%eax
  80697f:	85 c0                	test   %eax,%eax
  806981:	75 18                	jne    80699b <ip_output_if+0x11a>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806983:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806987:	74 08                	je     806991 <ip_output_if+0x110>
  806989:	8b 45 20             	mov    0x20(%ebp),%eax
  80698c:	8b 40 04             	mov    0x4(%eax),%eax
  80698f:	eb 05                	jmp    806996 <ip_output_if+0x115>
  806991:	b8 00 00 00 00       	mov    $0x0,%eax
  806996:	89 43 0c             	mov    %eax,0xc(%ebx)
  806999:	eb 03                	jmp    80699e <ip_output_if+0x11d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  80699b:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  80699e:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8069a4:	83 ec 08             	sub    $0x8,%esp
  8069a7:	6a 14                	push   $0x14
  8069a9:	53                   	push   %ebx
  8069aa:	e8 07 0c 00 00       	call   8075b6 <inet_chksum>
  8069af:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  8069b3:	83 c4 10             	add    $0x10,%esp
  8069b6:	eb 09                	jmp    8069c1 <ip_output_if+0x140>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  8069b8:	8b 46 04             	mov    0x4(%esi),%eax
  8069bb:	83 c0 10             	add    $0x10,%eax
  8069be:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8069c1:	8b 45 20             	mov    0x20(%ebp),%eax
  8069c4:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8069c8:	66 85 c0             	test   %ax,%ax
  8069cb:	74 1a                	je     8069e7 <ip_output_if+0x166>
  8069cd:	66 3b 46 08          	cmp    0x8(%esi),%ax
  8069d1:	73 14                	jae    8069e7 <ip_output_if+0x166>
    return ip_frag(p,netif,dest);
  8069d3:	83 ec 04             	sub    $0x4,%esp
  8069d6:	ff 75 10             	pushl  0x10(%ebp)
  8069d9:	ff 75 20             	pushl  0x20(%ebp)
  8069dc:	56                   	push   %esi
  8069dd:	e8 84 07 00 00       	call   807166 <ip_frag>
  8069e2:	83 c4 10             	add    $0x10,%esp
  8069e5:	eb 1a                	jmp    806a01 <ip_output_if+0x180>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8069e7:	83 ec 04             	sub    $0x4,%esp
  8069ea:	ff 75 10             	pushl  0x10(%ebp)
  8069ed:	56                   	push   %esi
  8069ee:	ff 75 20             	pushl  0x20(%ebp)
  8069f1:	8b 45 20             	mov    0x20(%ebp),%eax
  8069f4:	ff 50 14             	call   *0x14(%eax)
  8069f7:	83 c4 10             	add    $0x10,%esp
  8069fa:	eb 05                	jmp    806a01 <ip_output_if+0x180>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  8069fc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806a01:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a04:	5b                   	pop    %ebx
  806a05:	5e                   	pop    %esi
  806a06:	5f                   	pop    %edi
  806a07:	5d                   	pop    %ebp
  806a08:	c3                   	ret    

00806a09 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806a09:	55                   	push   %ebp
  806a0a:	89 e5                	mov    %esp,%ebp
  806a0c:	57                   	push   %edi
  806a0d:	56                   	push   %esi
  806a0e:	53                   	push   %ebx
  806a0f:	83 ec 18             	sub    $0x18,%esp
  806a12:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806a15:	8b 75 18             	mov    0x18(%ebp),%esi
  806a18:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806a1b:	ff 75 10             	pushl  0x10(%ebp)
  806a1e:	e8 fc fa ff ff       	call   80651f <ip_route>
  806a23:	83 c4 10             	add    $0x10,%esp
  806a26:	85 c0                	test   %eax,%eax
  806a28:	74 27                	je     806a51 <ip_output+0x48>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806a2a:	83 ec 04             	sub    $0x4,%esp
  806a2d:	50                   	push   %eax
  806a2e:	89 f8                	mov    %edi,%eax
  806a30:	0f b6 f8             	movzbl %al,%edi
  806a33:	57                   	push   %edi
  806a34:	89 f0                	mov    %esi,%eax
  806a36:	0f b6 f0             	movzbl %al,%esi
  806a39:	56                   	push   %esi
  806a3a:	0f b6 db             	movzbl %bl,%ebx
  806a3d:	53                   	push   %ebx
  806a3e:	ff 75 10             	pushl  0x10(%ebp)
  806a41:	ff 75 0c             	pushl  0xc(%ebp)
  806a44:	ff 75 08             	pushl  0x8(%ebp)
  806a47:	e8 35 fe ff ff       	call   806881 <ip_output_if>
  806a4c:	83 c4 20             	add    $0x20,%esp
  806a4f:	eb 05                	jmp    806a56 <ip_output+0x4d>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  806a51:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806a56:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a59:	5b                   	pop    %ebx
  806a5a:	5e                   	pop    %esi
  806a5b:	5f                   	pop    %edi
  806a5c:	5d                   	pop    %ebp
  806a5d:	c3                   	ret    

00806a5e <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806a5e:	55                   	push   %ebp
  806a5f:	89 e5                	mov    %esp,%ebp
  806a61:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806a64:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  806a6a:	39 c1                	cmp    %eax,%ecx
  806a6c:	75 0a                	jne    806a78 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  806a6e:	8b 11                	mov    (%ecx),%edx
  806a70:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806a76:	eb 1f                	jmp    806a97 <ip_reass_dequeue_datagram+0x39>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a78:	85 d2                	test   %edx,%edx
  806a7a:	75 17                	jne    806a93 <ip_reass_dequeue_datagram+0x35>
  806a7c:	83 ec 04             	sub    $0x4,%esp
  806a7f:	68 ed 1d 81 00       	push   $0x811ded
  806a84:	68 29 01 00 00       	push   $0x129
  806a89:	68 06 1e 81 00       	push   $0x811e06
  806a8e:	e8 b7 79 00 00       	call   80e44a <_panic>
    prev->next = ipr->next;
  806a93:	8b 08                	mov    (%eax),%ecx
  806a95:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806a97:	83 ec 08             	sub    $0x8,%esp
  806a9a:	50                   	push   %eax
  806a9b:	6a 05                	push   $0x5
  806a9d:	e8 15 da ff ff       	call   8044b7 <memp_free>
}
  806aa2:	83 c4 10             	add    $0x10,%esp
  806aa5:	c9                   	leave  
  806aa6:	c3                   	ret    

00806aa7 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806aa7:	55                   	push   %ebp
  806aa8:	89 e5                	mov    %esp,%ebp
  806aaa:	57                   	push   %edi
  806aab:	56                   	push   %esi
  806aac:	53                   	push   %ebx
  806aad:	83 ec 1c             	sub    $0x1c,%esp
  806ab0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806ab3:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  806ab6:	39 c2                	cmp    %eax,%edx
  806ab8:	75 17                	jne    806ad1 <ip_reass_free_complete_datagram+0x2a>
  806aba:	83 ec 04             	sub    $0x4,%esp
  806abd:	68 23 1e 81 00       	push   $0x811e23
  806ac2:	68 99 00 00 00       	push   $0x99
  806ac7:	68 06 1e 81 00       	push   $0x811e06
  806acc:	e8 79 79 00 00       	call   80e44a <_panic>
  if (prev != NULL) {
  806ad1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ad4:	85 c0                	test   %eax,%eax
  806ad6:	74 1e                	je     806af6 <ip_reass_free_complete_datagram+0x4f>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806ad8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806adb:	3b 10                	cmp    (%eax),%edx
  806add:	74 17                	je     806af6 <ip_reass_free_complete_datagram+0x4f>
  806adf:	83 ec 04             	sub    $0x4,%esp
  806ae2:	68 2f 1e 81 00       	push   $0x811e2f
  806ae7:	68 9b 00 00 00       	push   $0x9b
  806aec:	68 06 1e 81 00       	push   $0x811e06
  806af1:	e8 54 79 00 00       	call   80e44a <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806af6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806af9:	8b 58 04             	mov    0x4(%eax),%ebx
  806afc:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  806aff:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  806b04:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806b09:	75 3a                	jne    806b45 <ip_reass_free_complete_datagram+0x9e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806b0b:	8b 00                	mov    (%eax),%eax
  806b0d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806b10:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806b13:	83 ec 04             	sub    $0x4,%esp
  806b16:	6a 14                	push   $0x14
  806b18:	8d 41 08             	lea    0x8(%ecx),%eax
  806b1b:	50                   	push   %eax
  806b1c:	ff 73 04             	pushl  0x4(%ebx)
  806b1f:	e8 7e 81 00 00       	call   80eca2 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806b24:	83 c4 08             	add    $0x8,%esp
  806b27:	6a 01                	push   $0x1
  806b29:	53                   	push   %ebx
  806b2a:	e8 dc 77 00 00       	call   80e30b <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806b2f:	89 1c 24             	mov    %ebx,(%esp)
  806b32:	e8 52 e1 ff ff       	call   804c89 <pbuf_clen>
  806b37:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806b3a:	89 1c 24             	mov    %ebx,(%esp)
  806b3d:	e8 e8 dc ff ff       	call   80482a <pbuf_free>
  806b42:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806b45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b48:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806b4b:	eb 20                	jmp    806b6d <ip_reass_free_complete_datagram+0xc6>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  806b4d:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806b50:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806b52:	83 ec 0c             	sub    $0xc,%esp
  806b55:	53                   	push   %ebx
  806b56:	e8 2e e1 ff ff       	call   804c89 <pbuf_clen>
  806b5b:	0f b6 c0             	movzbl %al,%eax
  806b5e:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806b60:	89 1c 24             	mov    %ebx,(%esp)
  806b63:	e8 c2 dc ff ff       	call   80482a <pbuf_free>
  806b68:	83 c4 10             	add    $0x10,%esp
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806b6b:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  806b6d:	85 db                	test   %ebx,%ebx
  806b6f:	75 dc                	jne    806b4d <ip_reass_free_complete_datagram+0xa6>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  806b71:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806b74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b77:	e8 e2 fe ff ff       	call   806a5e <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b7c:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806b83:	0f b7 d0             	movzwl %ax,%edx
  806b86:	39 d6                	cmp    %edx,%esi
  806b88:	7e 17                	jle    806ba1 <ip_reass_free_complete_datagram+0xfa>
  806b8a:	83 ec 04             	sub    $0x4,%esp
  806b8d:	68 41 1e 81 00       	push   $0x811e41
  806b92:	68 bc 00 00 00       	push   $0xbc
  806b97:	68 06 1e 81 00       	push   $0x811e06
  806b9c:	e8 a9 78 00 00       	call   80e44a <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  806ba1:	29 f0                	sub    %esi,%eax
  806ba3:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc

  return pbufs_freed;
}
  806ba9:	89 f0                	mov    %esi,%eax
  806bab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806bae:	5b                   	pop    %ebx
  806baf:	5e                   	pop    %esi
  806bb0:	5f                   	pop    %edi
  806bb1:	5d                   	pop    %ebp
  806bb2:	c3                   	ret    

00806bb3 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  806bb3:	55                   	push   %ebp
  806bb4:	89 e5                	mov    %esp,%ebp
  806bb6:	57                   	push   %edi
  806bb7:	56                   	push   %esi
  806bb8:	53                   	push   %ebx
  806bb9:	83 ec 1c             	sub    $0x1c,%esp
  806bbc:	89 c6                	mov    %eax,%esi
  806bbe:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  806bc1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  806bc8:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  806bce:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  806bd3:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  806bd8:	b8 00 00 00 00       	mov    $0x0,%eax
  806bdd:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806be0:	eb 39                	jmp    806c1b <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806be2:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806be5:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806be8:	75 12                	jne    806bfc <ip_reass_remove_oldest_datagram+0x49>
  806bea:	8b 7e 10             	mov    0x10(%esi),%edi
  806bed:	39 79 18             	cmp    %edi,0x18(%ecx)
  806bf0:	75 0a                	jne    806bfc <ip_reass_remove_oldest_datagram+0x49>
  806bf2:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806bf6:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806bfa:	74 16                	je     806c12 <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  806bfc:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806c00:	85 c0                	test   %eax,%eax
  806c02:	74 0c                	je     806c10 <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  806c04:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806c08:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806c0b:	0f 46 c1             	cmovbe %ecx,%eax
  806c0e:	eb 02                	jmp    806c12 <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  806c10:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  806c12:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806c14:	85 ff                	test   %edi,%edi
  806c16:	0f 45 d1             	cmovne %ecx,%edx
  806c19:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806c1b:	85 c9                	test   %ecx,%ecx
  806c1d:	75 c3                	jne    806be2 <ip_reass_remove_oldest_datagram+0x2f>
  806c1f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  806c22:	85 c0                	test   %eax,%eax
  806c24:	74 08                	je     806c2e <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806c26:	e8 7c fe ff ff       	call   806aa7 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806c2b:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806c2e:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806c31:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806c34:	7d 05                	jge    806c3b <ip_reass_remove_oldest_datagram+0x88>
  806c36:	83 fb 01             	cmp    $0x1,%ebx
  806c39:	7f 8d                	jg     806bc8 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  806c3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806c3e:	83 c4 1c             	add    $0x1c,%esp
  806c41:	5b                   	pop    %ebx
  806c42:	5e                   	pop    %esi
  806c43:	5f                   	pop    %edi
  806c44:	5d                   	pop    %ebp
  806c45:	c3                   	ret    

00806c46 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  806c46:	55                   	push   %ebp
  806c47:	89 e5                	mov    %esp,%ebp
  806c49:	56                   	push   %esi
  806c4a:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  806c4b:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  806c50:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  806c55:	eb 1f                	jmp    806c76 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  806c57:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806c5b:	84 d2                	test   %dl,%dl
  806c5d:	74 0c                	je     806c6b <ip_reass_tmr+0x25>
      r->timer--;
  806c5f:	83 ea 01             	sub    $0x1,%edx
  806c62:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  806c65:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806c67:	8b 00                	mov    (%eax),%eax
  806c69:	eb 0b                	jmp    806c76 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806c6b:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  806c6d:	89 da                	mov    %ebx,%edx
  806c6f:	e8 33 fe ff ff       	call   806aa7 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806c74:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  806c76:	85 c0                	test   %eax,%eax
  806c78:	75 dd                	jne    806c57 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  806c7a:	5b                   	pop    %ebx
  806c7b:	5e                   	pop    %esi
  806c7c:	5d                   	pop    %ebp
  806c7d:	c3                   	ret    

00806c7e <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806c7e:	55                   	push   %ebp
  806c7f:	89 e5                	mov    %esp,%ebp
  806c81:	57                   	push   %edi
  806c82:	56                   	push   %esi
  806c83:	53                   	push   %ebx
  806c84:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806c87:	8b 45 08             	mov    0x8(%ebp),%eax
  806c8a:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806c8d:	0f b7 03             	movzwl (%ebx),%eax
  806c90:	50                   	push   %eax
  806c91:	e8 52 0a 00 00       	call   8076e8 <ntohs>
  806c96:	66 c1 e8 08          	shr    $0x8,%ax
  806c9a:	83 e0 0f             	and    $0xf,%eax
  806c9d:	83 c4 10             	add    $0x10,%esp
  806ca0:	83 f8 05             	cmp    $0x5,%eax
  806ca3:	0f 85 71 04 00 00    	jne    80711a <ip_reass+0x49c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806ca9:	83 ec 0c             	sub    $0xc,%esp
  806cac:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806cb0:	50                   	push   %eax
  806cb1:	e8 32 0a 00 00       	call   8076e8 <ntohs>
  806cb6:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806cba:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806cbe:	89 04 24             	mov    %eax,(%esp)
  806cc1:	e8 22 0a 00 00       	call   8076e8 <ntohs>
  806cc6:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  806cca:	0f b7 03             	movzwl (%ebx),%eax
  806ccd:	89 04 24             	mov    %eax,(%esp)
  806cd0:	e8 13 0a 00 00       	call   8076e8 <ntohs>
  806cd5:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806cd9:	83 c4 04             	add    $0x4,%esp
  806cdc:	ff 75 08             	pushl  0x8(%ebp)
  806cdf:	e8 a5 df ff ff       	call   804c89 <pbuf_clen>
  806ce4:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806ce7:	0f b6 f0             	movzbl %al,%esi
  806cea:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806cf1:	01 f0                	add    %esi,%eax
  806cf3:	83 c4 10             	add    $0x10,%esp
  806cf6:	83 f8 0a             	cmp    $0xa,%eax
  806cf9:	7e 23                	jle    806d1e <ip_reass+0xa0>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806cfb:	89 f2                	mov    %esi,%edx
  806cfd:	89 d8                	mov    %ebx,%eax
  806cff:	e8 af fe ff ff       	call   806bb3 <ip_reass_remove_oldest_datagram>
  806d04:	85 c0                	test   %eax,%eax
  806d06:	0f 84 0e 04 00 00    	je     80711a <ip_reass+0x49c>
  806d0c:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806d13:	01 f0                	add    %esi,%eax
  806d15:	83 f8 0a             	cmp    $0xa,%eax
  806d18:	0f 8f fc 03 00 00    	jg     80711a <ip_reass+0x49c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d1e:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  806d24:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d29:	eb 1e                	jmp    806d49 <ip_reass+0xcb>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806d2b:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806d2e:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806d31:	75 12                	jne    806d45 <ip_reass+0xc7>
  806d33:	8b 53 10             	mov    0x10(%ebx),%edx
  806d36:	39 57 18             	cmp    %edx,0x18(%edi)
  806d39:	75 0a                	jne    806d45 <ip_reass+0xc7>
  806d3b:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806d3f:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806d43:	74 7f                	je     806dc4 <ip_reass+0x146>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d45:	89 f8                	mov    %edi,%eax
  806d47:	8b 3f                	mov    (%edi),%edi
  806d49:	85 ff                	test   %edi,%edi
  806d4b:	75 de                	jne    806d2b <ip_reass+0xad>
  806d4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  806d50:	83 ec 0c             	sub    $0xc,%esp
  806d53:	6a 05                	push   $0x5
  806d55:	e8 07 d7 ff ff       	call   804461 <memp_malloc>
  806d5a:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806d5c:	83 c4 10             	add    $0x10,%esp
  806d5f:	85 c0                	test   %eax,%eax
  806d61:	75 28                	jne    806d8b <ip_reass+0x10d>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806d63:	89 f2                	mov    %esi,%edx
  806d65:	89 d8                	mov    %ebx,%eax
  806d67:	e8 47 fe ff ff       	call   806bb3 <ip_reass_remove_oldest_datagram>
  806d6c:	39 c6                	cmp    %eax,%esi
  806d6e:	0f 8f a6 03 00 00    	jg     80711a <ip_reass+0x49c>
      ipr = memp_malloc(MEMP_REASSDATA);
  806d74:	83 ec 0c             	sub    $0xc,%esp
  806d77:	6a 05                	push   $0x5
  806d79:	e8 e3 d6 ff ff       	call   804461 <memp_malloc>
  806d7e:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  806d80:	83 c4 10             	add    $0x10,%esp
  806d83:	85 c0                	test   %eax,%eax
  806d85:	0f 84 8f 03 00 00    	je     80711a <ip_reass+0x49c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806d8b:	83 ec 04             	sub    $0x4,%esp
  806d8e:	6a 20                	push   $0x20
  806d90:	6a 00                	push   $0x0
  806d92:	57                   	push   %edi
  806d93:	e8 55 7e 00 00       	call   80ebed <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806d98:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  806d9c:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806da1:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806da3:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806da9:	83 c4 0c             	add    $0xc,%esp
  806dac:	6a 14                	push   $0x14
  806dae:	53                   	push   %ebx
  806daf:	8d 47 08             	lea    0x8(%edi),%eax
  806db2:	50                   	push   %eax
  806db3:	e8 ea 7e 00 00       	call   80eca2 <memcpy>

  if (ipr == NULL) {
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  806db8:	83 c4 10             	add    $0x10,%esp
  806dbb:	85 ff                	test   %edi,%edi
  806dbd:	75 46                	jne    806e05 <ip_reass+0x187>
  806dbf:	e9 56 03 00 00       	jmp    80711a <ip_reass+0x49c>
  806dc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806dc7:	83 ec 0c             	sub    $0xc,%esp
  806dca:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dce:	50                   	push   %eax
  806dcf:	e8 14 09 00 00       	call   8076e8 <ntohs>
  806dd4:	83 c4 10             	add    $0x10,%esp
  806dd7:	66 a9 ff 1f          	test   $0x1fff,%ax
  806ddb:	75 28                	jne    806e05 <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806ddd:	83 ec 0c             	sub    $0xc,%esp
  806de0:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806de4:	50                   	push   %eax
  806de5:	e8 fe 08 00 00       	call   8076e8 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806dea:	83 c4 10             	add    $0x10,%esp
  806ded:	66 a9 ff 1f          	test   $0x1fff,%ax
  806df1:	74 12                	je     806e05 <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806df3:	83 ec 04             	sub    $0x4,%esp
  806df6:	6a 14                	push   $0x14
  806df8:	53                   	push   %ebx
  806df9:	8d 47 08             	lea    0x8(%edi),%eax
  806dfc:	50                   	push   %eax
  806dfd:	e8 a0 7e 00 00       	call   80eca2 <memcpy>
  806e02:	83 c4 10             	add    $0x10,%esp
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806e05:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806e09:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806e10:	83 ec 0c             	sub    $0xc,%esp
  806e13:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e17:	50                   	push   %eax
  806e18:	e8 cb 08 00 00       	call   8076e8 <ntohs>
  806e1d:	83 c4 10             	add    $0x10,%esp
  806e20:	f6 c4 20             	test   $0x20,%ah
  806e23:	75 20                	jne    806e45 <ip_reass+0x1c7>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806e25:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806e29:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  806e2d:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  806e31:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  806e34:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  806e38:	66 c1 ea 06          	shr    $0x6,%dx
  806e3c:	83 e2 3c             	and    $0x3c,%edx
  806e3f:	29 d0                	sub    %edx,%eax
  806e41:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806e45:	8b 45 08             	mov    0x8(%ebp),%eax
  806e48:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e4b:	83 ec 0c             	sub    $0xc,%esp
  806e4e:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806e52:	50                   	push   %eax
  806e53:	e8 90 08 00 00       	call   8076e8 <ntohs>
  806e58:	89 c6                	mov    %eax,%esi
  806e5a:	0f b7 03             	movzwl (%ebx),%eax
  806e5d:	89 04 24             	mov    %eax,(%esp)
  806e60:	e8 83 08 00 00       	call   8076e8 <ntohs>
  806e65:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806e69:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e6d:	89 04 24             	mov    %eax,(%esp)
  806e70:	e8 73 08 00 00       	call   8076e8 <ntohs>
  806e75:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  806e7c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806e7f:	8b 51 04             	mov    0x4(%ecx),%edx
  806e82:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  806e85:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806e8b:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806e8f:	01 de                	add    %ebx,%esi
  806e91:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806e95:	66 c1 e8 06          	shr    $0x6,%ax
  806e99:	83 e0 3c             	and    $0x3c,%eax
  806e9c:	29 c6                	sub    %eax,%esi
  806e9e:	66 89 75 da          	mov    %si,-0x26(%ebp)
  806ea2:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806ea6:	8b 47 04             	mov    0x4(%edi),%eax
  806ea9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806eac:	83 c4 10             	add    $0x10,%esp
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  806eaf:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806eb4:	be 00 00 00 00       	mov    $0x0,%esi
  806eb9:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806ebc:	89 cf                	mov    %ecx,%edi
  806ebe:	eb 6f                	jmp    806f2f <ip_reass+0x2b1>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806ec0:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806ec3:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806ec7:	66 39 cb             	cmp    %cx,%bx
  806eca:	73 3c                	jae    806f08 <ip_reass+0x28a>
  806ecc:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806ecf:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  806ed2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806ed5:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806ed7:	85 f6                	test   %esi,%esi
  806ed9:	74 22                	je     806efd <ip_reass+0x27f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806edb:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806edf:	0f 82 6c 01 00 00    	jb     807051 <ip_reass+0x3d3>
  806ee5:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  806ee9:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806eed:	0f 87 5e 01 00 00    	ja     807051 <ip_reass+0x3d3>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  806ef3:	8b 45 08             	mov    0x8(%ebp),%eax
  806ef6:	89 06                	mov    %eax,(%esi)
  806ef8:	e9 92 00 00 00       	jmp    806f8f <ip_reass+0x311>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  806efd:	8b 45 08             	mov    0x8(%ebp),%eax
  806f00:	89 47 04             	mov    %eax,0x4(%edi)
  806f03:	e9 87 00 00 00       	jmp    806f8f <ip_reass+0x311>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  806f08:	66 39 cb             	cmp    %cx,%bx
  806f0b:	0f 84 40 01 00 00    	je     807051 <ip_reass+0x3d3>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  806f11:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806f15:	0f 82 36 01 00 00    	jb     807051 <ip_reass+0x3d3>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  806f1b:	85 f6                	test   %esi,%esi
  806f1d:	74 0c                	je     806f2b <ip_reass+0x2ad>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  806f1f:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806f23:	b8 00 00 00 00       	mov    $0x0,%eax
  806f28:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  806f2b:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806f2d:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806f2f:	85 c0                	test   %eax,%eax
  806f31:	75 8d                	jne    806ec0 <ip_reass+0x242>
  806f33:	e9 fe 01 00 00       	jmp    807136 <ip_reass+0x4b8>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806f38:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806f3c:	66 39 c3             	cmp    %ax,%bx
  806f3f:	73 17                	jae    806f58 <ip_reass+0x2da>
  806f41:	83 ec 04             	sub    $0x4,%esp
  806f44:	68 5c 1e 81 00       	push   $0x811e5c
  806f49:	68 83 01 00 00       	push   $0x183
  806f4e:	68 06 1e 81 00       	push   $0x811e06
  806f53:	e8 f2 74 00 00       	call   80e44a <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  806f58:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806f5b:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  806f5d:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806f60:	66 3b 46 04          	cmp    0x4(%esi),%ax
  806f64:	0f 85 ef 01 00 00    	jne    807159 <ip_reass+0x4db>
  806f6a:	eb 23                	jmp    806f8f <ip_reass+0x311>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f6c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  806f70:	74 17                	je     806f89 <ip_reass+0x30b>
  806f72:	83 ec 04             	sub    $0x4,%esp
  806f75:	68 88 1e 81 00       	push   $0x811e88
  806f7a:	68 8c 01 00 00       	push   $0x18c
  806f7f:	68 06 1e 81 00       	push   $0x811e06
  806f84:	e8 c1 74 00 00       	call   80e44a <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  806f89:	8b 45 08             	mov    0x8(%ebp),%eax
  806f8c:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806f8f:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806f93:	0f 84 c0 01 00 00    	je     807159 <ip_reass+0x4db>
    /* and had no wholes so far */
    if (valid) {
  806f99:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806f9d:	0f 84 b6 01 00 00    	je     807159 <ip_reass+0x4db>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806fa3:	8b 4f 04             	mov    0x4(%edi),%ecx
  806fa6:	8b 59 04             	mov    0x4(%ecx),%ebx
  806fa9:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806fae:	0f 85 a5 01 00 00    	jne    807159 <ip_reass+0x4db>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  806fb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806fb7:	8b 10                	mov    (%eax),%edx
  806fb9:	89 c6                	mov    %eax,%esi
  806fbb:	eb 15                	jmp    806fd2 <ip_reass+0x354>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806fbd:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806fc0:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806fc4:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806fc8:	0f 85 61 01 00 00    	jne    80712f <ip_reass+0x4b1>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  806fce:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806fd0:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  806fd2:	85 d2                	test   %edx,%edx
  806fd4:	75 e7                	jne    806fbd <ip_reass+0x33f>
  806fd6:	e9 6e 01 00 00       	jmp    807149 <ip_reass+0x4cb>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  806fdb:	83 ec 04             	sub    $0x4,%esp
  806fde:	68 7a 1e 81 00       	push   $0x811e7a
  806fe3:	68 ac 01 00 00       	push   $0x1ac
  806fe8:	68 06 1e 81 00       	push   $0x811e06
  806fed:	e8 58 74 00 00       	call   80e44a <_panic>
          LWIP_ASSERT("sanity check",
  806ff2:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  806ff5:	75 17                	jne    80700e <ip_reass+0x390>
  806ff7:	83 ec 04             	sub    $0x4,%esp
  806ffa:	68 7a 1e 81 00       	push   $0x811e7a
  806fff:	68 ae 01 00 00       	push   $0x1ae
  807004:	68 06 1e 81 00       	push   $0x811e06
  807009:	e8 3c 74 00 00       	call   80e44a <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80700e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807011:	83 38 00             	cmpl   $0x0,(%eax)
  807014:	74 17                	je     80702d <ip_reass+0x3af>
  807016:	83 ec 04             	sub    $0x4,%esp
  807019:	68 c0 1e 81 00       	push   $0x811ec0
  80701e:	68 b0 01 00 00       	push   $0x1b0
  807023:	68 06 1e 81 00       	push   $0x811e06
  807028:	e8 1d 74 00 00       	call   80e44a <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80702d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807030:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  807034:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  807038:	74 3f                	je     807079 <ip_reass+0x3fb>
  80703a:	83 ec 04             	sub    $0x4,%esp
  80703d:	68 e4 1e 81 00       	push   $0x811ee4
  807042:	68 b2 01 00 00       	push   $0x1b2
  807047:	68 06 1e 81 00       	push   $0x811e06
  80704c:	e8 f9 73 00 00       	call   80e44a <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807051:	83 ec 0c             	sub    $0xc,%esp
  807054:	ff 75 08             	pushl  0x8(%ebp)
  807057:	e8 2d dc ff ff       	call   804c89 <pbuf_clen>
  80705c:	0f b6 c0             	movzbl %al,%eax
  80705f:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  807066:	83 c4 04             	add    $0x4,%esp
  807069:	ff 75 08             	pushl  0x8(%ebp)
  80706c:	e8 b9 d7 ff ff       	call   80482a <pbuf_free>
  807071:	83 c4 10             	add    $0x10,%esp
  807074:	e9 e0 00 00 00       	jmp    807159 <ip_reass+0x4db>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  807079:	83 c0 14             	add    $0x14,%eax
  80707c:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  807080:	8b 71 04             	mov    0x4(%ecx),%esi
  807083:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  807085:	83 ec 04             	sub    $0x4,%esp
  807088:	6a 14                	push   $0x14
  80708a:	8d 47 08             	lea    0x8(%edi),%eax
  80708d:	50                   	push   %eax
  80708e:	56                   	push   %esi
  80708f:	e8 0e 7c 00 00       	call   80eca2 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807094:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807098:	89 04 24             	mov    %eax,(%esp)
  80709b:	e8 3b 06 00 00       	call   8076db <htons>
  8070a0:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  8070a4:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  8070aa:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  8070b0:	83 c4 08             	add    $0x8,%esp
  8070b3:	6a 14                	push   $0x14
  8070b5:	56                   	push   %esi
  8070b6:	e8 fb 04 00 00       	call   8075b6 <inet_chksum>
  8070bb:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  8070bf:	8b 47 04             	mov    0x4(%edi),%eax
  8070c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8070c5:	83 c4 10             	add    $0x10,%esp
  8070c8:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8070cb:	89 c7                	mov    %eax,%edi
  8070cd:	eb 1d                	jmp    8070ec <ip_reass+0x46e>
      iprh = (struct ip_reass_helper*)r->payload;
  8070cf:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  8070d2:	83 ec 08             	sub    $0x8,%esp
  8070d5:	6a ec                	push   $0xffffffec
  8070d7:	53                   	push   %ebx
  8070d8:	e8 7b d6 ff ff       	call   804758 <pbuf_header>
      pbuf_cat(p, r);
  8070dd:	83 c4 08             	add    $0x8,%esp
  8070e0:	53                   	push   %ebx
  8070e1:	57                   	push   %edi
  8070e2:	e8 cb db ff ff       	call   804cb2 <pbuf_cat>
      r = iprh->next_pbuf;
  8070e7:	8b 1e                	mov    (%esi),%ebx
  8070e9:	83 c4 10             	add    $0x10,%esp
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8070ec:	85 db                	test   %ebx,%ebx
  8070ee:	75 df                	jne    8070cf <ip_reass+0x451>
  8070f0:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8070f3:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8070f6:	89 f8                	mov    %edi,%eax
  8070f8:	e8 61 f9 ff ff       	call   806a5e <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8070fd:	83 ec 0c             	sub    $0xc,%esp
  807100:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807103:	56                   	push   %esi
  807104:	e8 80 db ff ff       	call   804c89 <pbuf_clen>
  807109:	0f b6 c0             	movzbl %al,%eax
  80710c:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc

    /* Return the pbuf chain */
    return p;
  807113:	83 c4 10             	add    $0x10,%esp
  807116:	89 f0                	mov    %esi,%eax
  807118:	eb 44                	jmp    80715e <ip_reass+0x4e0>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80711a:	83 ec 0c             	sub    $0xc,%esp
  80711d:	ff 75 08             	pushl  0x8(%ebp)
  807120:	e8 05 d7 ff ff       	call   80482a <pbuf_free>
  return NULL;
  807125:	83 c4 10             	add    $0x10,%esp
  807128:	b8 00 00 00 00       	mov    $0x0,%eax
  80712d:	eb 2f                	jmp    80715e <ip_reass+0x4e0>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  80712f:	b8 00 00 00 00       	mov    $0x0,%eax
  807134:	eb 28                	jmp    80715e <ip_reass+0x4e0>
  807136:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807139:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80713c:	85 f6                	test   %esi,%esi
  80713e:	0f 85 f4 fd ff ff    	jne    806f38 <ip_reass+0x2ba>
  807144:	e9 23 fe ff ff       	jmp    806f6c <ip_reass+0x2ee>
  807149:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80714c:	85 c9                	test   %ecx,%ecx
  80714e:	0f 85 9e fe ff ff    	jne    806ff2 <ip_reass+0x374>
  807154:	e9 82 fe ff ff       	jmp    806fdb <ip_reass+0x35d>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807159:	b8 00 00 00 00       	mov    $0x0,%eax
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  80715e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807161:	5b                   	pop    %ebx
  807162:	5e                   	pop    %esi
  807163:	5f                   	pop    %edi
  807164:	5d                   	pop    %ebp
  807165:	c3                   	ret    

00807166 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807166:	55                   	push   %ebp
  807167:	89 e5                	mov    %esp,%ebp
  807169:	57                   	push   %edi
  80716a:	56                   	push   %esi
  80716b:	53                   	push   %ebx
  80716c:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80716f:	8b 45 0c             	mov    0xc(%ebp),%eax
  807172:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807176:	6a 02                	push   $0x2
  807178:	6a 00                	push   $0x0
  80717a:	6a 02                	push   $0x2
  80717c:	e8 6f d7 ff ff       	call   8048f0 <pbuf_alloc>
  807181:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (rambuf == NULL) {
  807184:	83 c4 10             	add    $0x10,%esp
  807187:	85 c0                	test   %eax,%eax
  807189:	0f 84 9f 01 00 00    	je     80732e <ip_frag+0x1c8>
  80718f:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  807191:	66 89 58 0a          	mov    %bx,0xa(%eax)
  807195:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807199:	b8 03 44 b3 00       	mov    $0xb34403,%eax
  80719e:	83 e0 fc             	and    $0xfffffffc,%eax
  8071a1:	89 c7                	mov    %eax,%edi
  8071a3:	89 7e 04             	mov    %edi,0x4(%esi)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8071a6:	83 ec 04             	sub    $0x4,%esp
  8071a9:	6a 14                	push   $0x14
  8071ab:	8b 45 08             	mov    0x8(%ebp),%eax
  8071ae:	ff 70 04             	pushl  0x4(%eax)
  8071b1:	57                   	push   %edi
  8071b2:	e8 eb 7a 00 00       	call   80eca2 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8071b7:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  8071bb:	89 04 24             	mov    %eax,(%esp)
  8071be:	e8 25 05 00 00       	call   8076e8 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8071c3:	89 c6                	mov    %eax,%esi
  8071c5:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8071ca:	66 89 75 de          	mov    %si,-0x22(%ebp)
  omf = tmp & IP_MF;
  8071ce:	66 25 00 20          	and    $0x2000,%ax
  8071d2:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  left = p->tot_len - IP_HLEN;
  8071d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8071d9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8071dd:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  8071e1:	8d 70 ec             	lea    -0x14(%eax),%esi

  nfb = (mtu - IP_HLEN) / 8;
  8071e4:	0f b7 db             	movzwl %bx,%ebx
  8071e7:	8d 43 f3             	lea    -0xd(%ebx),%eax
  8071ea:	83 c4 10             	add    $0x10,%esp
  8071ed:	83 eb 14             	sub    $0x14,%ebx
  8071f0:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8071f3:	0f 49 c3             	cmovns %ebx,%eax
  8071f6:	c1 f8 03             	sar    $0x3,%eax
  8071f9:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  8071fd:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807203:	c1 e0 03             	shl    $0x3,%eax
  807206:	66 89 45 cc          	mov    %ax,-0x34(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80720a:	8d 47 14             	lea    0x14(%edi),%eax
  80720d:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807210:	e9 fb 00 00 00       	jmp    807310 <ip_frag+0x1aa>
    last = (left <= mtu - IP_HLEN);
  807215:	0f b7 c6             	movzwl %si,%eax
  807218:	89 45 d8             	mov    %eax,-0x28(%ebp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  80721b:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
  80721f:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807224:	66 0b 5d dc          	or     -0x24(%ebp),%bx
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807228:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  80722c:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80722f:	7d 0b                	jge    80723c <ip_frag+0xd6>
      tmp = tmp | IP_MF;
  807231:	80 cf 20             	or     $0x20,%bh

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807234:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  807238:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80723c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807240:	50                   	push   %eax
  807241:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807245:	50                   	push   %eax
  807246:	ff 75 d0             	pushl  -0x30(%ebp)
  807249:	ff 75 08             	pushl  0x8(%ebp)
  80724c:	e8 29 dd ff ff       	call   804f7a <pbuf_copy_partial>
  807251:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807255:	0f b7 db             	movzwl %bx,%ebx
  807258:	89 1c 24             	mov    %ebx,(%esp)
  80725b:	e8 7b 04 00 00       	call   8076db <htons>
  807260:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807264:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  807268:	8d 41 14             	lea    0x14(%ecx),%eax
  80726b:	0f b7 c0             	movzwl %ax,%eax
  80726e:	89 04 24             	mov    %eax,(%esp)
  807271:	e8 65 04 00 00       	call   8076db <htons>
  807276:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80727a:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807280:	83 c4 08             	add    $0x8,%esp
  807283:	6a 14                	push   $0x14
  807285:	57                   	push   %edi
  807286:	e8 2b 03 00 00       	call   8075b6 <inet_chksum>
  80728b:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  80728f:	83 c4 10             	add    $0x10,%esp
  807292:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807295:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  807298:	7c 15                	jl     8072af <ip_frag+0x149>
      pbuf_realloc(rambuf, left + IP_HLEN);
  80729a:	83 ec 08             	sub    $0x8,%esp
  80729d:	8d 46 14             	lea    0x14(%esi),%eax
  8072a0:	0f b7 c0             	movzwl %ax,%eax
  8072a3:	50                   	push   %eax
  8072a4:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072a7:	e8 c7 d8 ff ff       	call   804b73 <pbuf_realloc>
  8072ac:	83 c4 10             	add    $0x10,%esp
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8072af:	83 ec 04             	sub    $0x4,%esp
  8072b2:	6a 00                	push   $0x0
  8072b4:	6a 00                	push   $0x0
  8072b6:	6a 02                	push   $0x2
  8072b8:	e8 33 d6 ff ff       	call   8048f0 <pbuf_alloc>
  8072bd:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8072bf:	83 c4 10             	add    $0x10,%esp
  8072c2:	85 c0                	test   %eax,%eax
  8072c4:	74 35                	je     8072fb <ip_frag+0x195>
      pbuf_chain(header, rambuf);
  8072c6:	83 ec 08             	sub    $0x8,%esp
  8072c9:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072cc:	50                   	push   %eax
  8072cd:	e8 4c da ff ff       	call   804d1e <pbuf_chain>
      netif->output(netif, header, dest);
  8072d2:	83 c4 0c             	add    $0xc,%esp
  8072d5:	ff 75 10             	pushl  0x10(%ebp)
  8072d8:	53                   	push   %ebx
  8072d9:	ff 75 0c             	pushl  0xc(%ebp)
  8072dc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8072df:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  8072e2:	89 1c 24             	mov    %ebx,(%esp)
  8072e5:	e8 40 d5 ff ff       	call   80482a <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  8072ea:	66 2b 75 e6          	sub    -0x1a(%ebp),%si
    ofo += nfb;
  8072ee:	0f b7 4d ce          	movzwl -0x32(%ebp),%ecx
  8072f2:	66 01 4d de          	add    %cx,-0x22(%ebp)
  8072f6:	83 c4 10             	add    $0x10,%esp
  8072f9:	eb 15                	jmp    807310 <ip_frag+0x1aa>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8072fb:	83 ec 0c             	sub    $0xc,%esp
  8072fe:	ff 75 d4             	pushl  -0x2c(%ebp)
  807301:	e8 24 d5 ff ff       	call   80482a <pbuf_free>
      return ERR_MEM;
  807306:	83 c4 10             	add    $0x10,%esp
  807309:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80730e:	eb 23                	jmp    807333 <ip_frag+0x1cd>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807310:	66 85 f6             	test   %si,%si
  807313:	0f 85 fc fe ff ff    	jne    807215 <ip_frag+0xaf>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807319:	83 ec 0c             	sub    $0xc,%esp
  80731c:	ff 75 d4             	pushl  -0x2c(%ebp)
  80731f:	e8 06 d5 ff ff       	call   80482a <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807324:	83 c4 10             	add    $0x10,%esp
  807327:	b8 00 00 00 00       	mov    $0x0,%eax
  80732c:	eb 05                	jmp    807333 <ip_frag+0x1cd>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  80732e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  807333:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807336:	5b                   	pop    %ebx
  807337:	5e                   	pop    %esi
  807338:	5f                   	pop    %edi
  807339:	5d                   	pop    %ebp
  80733a:	c3                   	ret    

0080733b <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80733b:	55                   	push   %ebp
  80733c:	89 e5                	mov    %esp,%ebp
  80733e:	57                   	push   %edi
  80733f:	56                   	push   %esi
  807340:	53                   	push   %ebx
  807341:	83 ec 1c             	sub    $0x1c,%esp
  807344:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  807347:	89 c3                	mov    %eax,%ebx
  while (len > 1) {
  807349:	89 d7                	mov    %edx,%edi
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  80734b:	be 00 00 00 00       	mov    $0x0,%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807350:	eb 17                	jmp    807369 <lwip_standard_chksum+0x2e>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  807352:	0f b6 03             	movzbl (%ebx),%eax
  807355:	c1 e0 08             	shl    $0x8,%eax
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807358:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  80735c:	09 c8                	or     %ecx,%eax
  80735e:	83 c3 02             	add    $0x2,%ebx
    octetptr++;
    acc += src;
  807361:	0f b7 c0             	movzwl %ax,%eax
  807364:	01 c6                	add    %eax,%esi
    len -= 2;
  807366:	83 ef 02             	sub    $0x2,%edi
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807369:	66 83 ff 01          	cmp    $0x1,%di
  80736d:	77 e3                	ja     807352 <lwip_standard_chksum+0x17>
  80736f:	89 d0                	mov    %edx,%eax
  807371:	66 d1 e8             	shr    %ax
  807374:	0f b7 c8             	movzwl %ax,%ecx
  807377:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80737a:	8d 0c 4f             	lea    (%edi,%ecx,2),%ecx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80737d:	f7 d8                	neg    %eax
  80737f:	8d 14 42             	lea    (%edx,%eax,2),%edx
  807382:	66 85 d2             	test   %dx,%dx
  807385:	74 0b                	je     807392 <lwip_standard_chksum+0x57>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  807387:	0f b6 01             	movzbl (%ecx),%eax
  80738a:	c1 e0 08             	shl    $0x8,%eax
  80738d:	0f b7 c0             	movzwl %ax,%eax
  807390:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807392:	89 f0                	mov    %esi,%eax
  807394:	c1 e8 10             	shr    $0x10,%eax
  807397:	0f b7 f6             	movzwl %si,%esi
  80739a:	01 c6                	add    %eax,%esi
  if ((acc & 0xffff0000) != 0) {
  80739c:	f7 c6 00 00 ff ff    	test   $0xffff0000,%esi
  8073a2:	74 0a                	je     8073ae <lwip_standard_chksum+0x73>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8073a4:	89 f0                	mov    %esi,%eax
  8073a6:	c1 e8 10             	shr    $0x10,%eax
  8073a9:	0f b7 f6             	movzwl %si,%esi
  8073ac:	01 c6                	add    %eax,%esi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8073ae:	83 ec 0c             	sub    $0xc,%esp
  8073b1:	0f b7 f6             	movzwl %si,%esi
  8073b4:	56                   	push   %esi
  8073b5:	e8 21 03 00 00       	call   8076db <htons>
}
  8073ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8073bd:	5b                   	pop    %ebx
  8073be:	5e                   	pop    %esi
  8073bf:	5f                   	pop    %edi
  8073c0:	5d                   	pop    %ebp
  8073c1:	c3                   	ret    

008073c2 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8073c2:	55                   	push   %ebp
  8073c3:	89 e5                	mov    %esp,%ebp
  8073c5:	57                   	push   %edi
  8073c6:	56                   	push   %esi
  8073c7:	53                   	push   %ebx
  8073c8:	83 ec 1c             	sub    $0x1c,%esp
  8073cb:	8b 75 08             	mov    0x8(%ebp),%esi
  8073ce:	8b 45 14             	mov    0x14(%ebp),%eax
  8073d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8073d4:	8b 45 18             	mov    0x18(%ebp),%eax
  8073d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8073da:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8073df:	bb 00 00 00 00       	mov    $0x0,%ebx
  8073e4:	89 f8                	mov    %edi,%eax
  8073e6:	89 df                	mov    %ebx,%edi
  8073e8:	89 c3                	mov    %eax,%ebx
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8073ea:	eb 3d                	jmp    807429 <inet_chksum_pseudo+0x67>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8073ec:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8073f0:	8b 46 04             	mov    0x4(%esi),%eax
  8073f3:	e8 43 ff ff ff       	call   80733b <lwip_standard_chksum>
  8073f8:	0f b7 c0             	movzwl %ax,%eax
  8073fb:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8073fd:	89 c7                	mov    %eax,%edi
  8073ff:	c1 ef 10             	shr    $0x10,%edi
  807402:	0f b7 c0             	movzwl %ax,%eax
  807405:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807407:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80740b:	74 1a                	je     807427 <inet_chksum_pseudo+0x65>
      swapped = 1 - swapped;
  80740d:	b8 01 00 00 00       	mov    $0x1,%eax
  807412:	29 d8                	sub    %ebx,%eax
  807414:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807416:	89 fa                	mov    %edi,%edx
  807418:	c1 e2 08             	shl    $0x8,%edx
  80741b:	0f b7 d2             	movzwl %dx,%edx
  80741e:	89 f8                	mov    %edi,%eax
  807420:	0f b6 c4             	movzbl %ah,%eax
  807423:	09 c2                	or     %eax,%edx
  807425:	89 d7                	mov    %edx,%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807427:	8b 36                	mov    (%esi),%esi
  807429:	85 f6                	test   %esi,%esi
  80742b:	75 bf                	jne    8073ec <inet_chksum_pseudo+0x2a>
  80742d:	89 d8                	mov    %ebx,%eax
  80742f:	89 fb                	mov    %edi,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807431:	84 c0                	test   %al,%al
  807433:	74 0d                	je     807442 <inet_chksum_pseudo+0x80>
    acc = SWAP_BYTES_IN_WORD(acc);
  807435:	89 f8                	mov    %edi,%eax
  807437:	c1 e0 08             	shl    $0x8,%eax
  80743a:	0f b7 c0             	movzwl %ax,%eax
  80743d:	0f b6 df             	movzbl %bh,%ebx
  807440:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  807442:	8b 45 0c             	mov    0xc(%ebp),%eax
  807445:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807447:	8b 45 10             	mov    0x10(%ebp),%eax
  80744a:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80744c:	0f b7 ca             	movzwl %dx,%ecx
  80744f:	c1 ea 10             	shr    $0x10,%edx
  807452:	01 ca                	add    %ecx,%edx
  807454:	0f b7 c8             	movzwl %ax,%ecx
  807457:	01 ca                	add    %ecx,%edx
  807459:	c1 e8 10             	shr    $0x10,%eax
  80745c:	01 d0                	add    %edx,%eax
  80745e:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  807460:	83 ec 0c             	sub    $0xc,%esp
  807463:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807467:	50                   	push   %eax
  807468:	e8 6e 02 00 00       	call   8076db <htons>
  80746d:	0f b7 c0             	movzwl %ax,%eax
  807470:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  807472:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807476:	89 04 24             	mov    %eax,(%esp)
  807479:	e8 5d 02 00 00       	call   8076db <htons>
  80747e:	0f b7 c0             	movzwl %ax,%eax
  807481:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807483:	89 d8                	mov    %ebx,%eax
  807485:	c1 e8 10             	shr    $0x10,%eax
  807488:	0f b7 db             	movzwl %bx,%ebx
  80748b:	01 d8                	add    %ebx,%eax
  acc = FOLD_U32T(acc);
  80748d:	89 c2                	mov    %eax,%edx
  80748f:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807492:	01 d0                	add    %edx,%eax
  807494:	f7 d0                	not    %eax
}
  807496:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807499:	5b                   	pop    %ebx
  80749a:	5e                   	pop    %esi
  80749b:	5f                   	pop    %edi
  80749c:	5d                   	pop    %ebp
  80749d:	c3                   	ret    

0080749e <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80749e:	55                   	push   %ebp
  80749f:	89 e5                	mov    %esp,%ebp
  8074a1:	57                   	push   %edi
  8074a2:	56                   	push   %esi
  8074a3:	53                   	push   %ebx
  8074a4:	83 ec 1c             	sub    $0x1c,%esp
  8074a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8074aa:	8b 45 14             	mov    0x14(%ebp),%eax
  8074ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8074b0:	8b 45 18             	mov    0x18(%ebp),%eax
  8074b3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8074b6:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  8074ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8074be:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8074c5:	eb 6d                	jmp    807534 <inet_chksum_pseudo_partial+0x96>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  8074c7:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8074cb:	66 39 fe             	cmp    %di,%si
  8074ce:	0f 46 fe             	cmovbe %esi,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  8074d1:	0f b7 d7             	movzwl %di,%edx
  8074d4:	8b 43 04             	mov    0x4(%ebx),%eax
  8074d7:	e8 5f fe ff ff       	call   80733b <lwip_standard_chksum>
  8074dc:	0f b7 c0             	movzwl %ax,%eax
  8074df:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8074e2:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074e4:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8074e9:	76 17                	jbe    807502 <inet_chksum_pseudo_partial+0x64>
  8074eb:	83 ec 04             	sub    $0x4,%esp
  8074ee:	68 11 1f 81 00       	push   $0x811f11
  8074f3:	68 60 01 00 00       	push   $0x160
  8074f8:	68 1c 1f 81 00       	push   $0x811f1c
  8074fd:	e8 48 6f 00 00       	call   80e44a <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807502:	89 c2                	mov    %eax,%edx
  807504:	c1 ea 10             	shr    $0x10,%edx
  807507:	0f b7 c0             	movzwl %ax,%eax
  80750a:	01 d0                	add    %edx,%eax
  80750c:	89 c2                	mov    %eax,%edx
  80750e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807511:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807515:	74 1b                	je     807532 <inet_chksum_pseudo_partial+0x94>
      swapped = 1 - swapped;
  807517:	b8 01 00 00 00       	mov    $0x1,%eax
  80751c:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80751f:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807522:	89 d0                	mov    %edx,%eax
  807524:	c1 e2 08             	shl    $0x8,%edx
  807527:	0f b7 d2             	movzwl %dx,%edx
  80752a:	0f b6 c4             	movzbl %ah,%eax
  80752d:	09 c2                	or     %eax,%edx
  80752f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807532:	8b 1b                	mov    (%ebx),%ebx
  807534:	85 db                	test   %ebx,%ebx
  807536:	74 05                	je     80753d <inet_chksum_pseudo_partial+0x9f>
  807538:	66 85 f6             	test   %si,%si
  80753b:	75 8a                	jne    8074c7 <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80753d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807541:	74 13                	je     807556 <inet_chksum_pseudo_partial+0xb8>
    acc = SWAP_BYTES_IN_WORD(acc);
  807543:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807546:	89 c8                	mov    %ecx,%eax
  807548:	c1 e0 08             	shl    $0x8,%eax
  80754b:	0f b7 c0             	movzwl %ax,%eax
  80754e:	0f b6 d5             	movzbl %ch,%edx
  807551:	09 d0                	or     %edx,%eax
  807553:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807556:	8b 45 0c             	mov    0xc(%ebp),%eax
  807559:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80755b:	8b 45 10             	mov    0x10(%ebp),%eax
  80755e:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807560:	0f b7 ca             	movzwl %dx,%ecx
  807563:	c1 ea 10             	shr    $0x10,%edx
  807566:	01 ca                	add    %ecx,%edx
  807568:	0f b7 d8             	movzwl %ax,%ebx
  80756b:	01 d3                	add    %edx,%ebx
  80756d:	c1 e8 10             	shr    $0x10,%eax
  807570:	01 c3                	add    %eax,%ebx
  807572:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807575:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons((u16_t)proto);
  807577:	83 ec 0c             	sub    $0xc,%esp
  80757a:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  80757e:	50                   	push   %eax
  80757f:	e8 57 01 00 00       	call   8076db <htons>
  807584:	0f b7 d0             	movzwl %ax,%edx
  807587:	8d 1c 32             	lea    (%edx,%esi,1),%ebx
  acc += (u32_t)htons(proto_len);
  80758a:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  80758e:	89 04 24             	mov    %eax,(%esp)
  807591:	e8 45 01 00 00       	call   8076db <htons>
  807596:	0f b7 d0             	movzwl %ax,%edx
  807599:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80759b:	89 d0                	mov    %edx,%eax
  80759d:	c1 e8 10             	shr    $0x10,%eax
  8075a0:	0f b7 d2             	movzwl %dx,%edx
  8075a3:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  8075a5:	89 c2                	mov    %eax,%edx
  8075a7:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8075aa:	01 d0                	add    %edx,%eax
  8075ac:	f7 d0                	not    %eax
}
  8075ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8075b1:	5b                   	pop    %ebx
  8075b2:	5e                   	pop    %esi
  8075b3:	5f                   	pop    %edi
  8075b4:	5d                   	pop    %ebp
  8075b5:	c3                   	ret    

008075b6 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8075b6:	55                   	push   %ebp
  8075b7:	89 e5                	mov    %esp,%ebp
  8075b9:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  8075bc:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8075c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8075c3:	e8 73 fd ff ff       	call   80733b <lwip_standard_chksum>
  8075c8:	f7 d0                	not    %eax
}
  8075ca:	c9                   	leave  
  8075cb:	c3                   	ret    

008075cc <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8075cc:	55                   	push   %ebp
  8075cd:	89 e5                	mov    %esp,%ebp
  8075cf:	57                   	push   %edi
  8075d0:	56                   	push   %esi
  8075d1:	53                   	push   %ebx
  8075d2:	83 ec 0c             	sub    $0xc,%esp
  8075d5:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8075d8:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8075dd:	bb 00 00 00 00       	mov    $0x0,%ebx
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  8075e2:	eb 3b                	jmp    80761f <inet_chksum_pbuf+0x53>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8075e4:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8075e8:	8b 46 04             	mov    0x4(%esi),%eax
  8075eb:	e8 4b fd ff ff       	call   80733b <lwip_standard_chksum>
  8075f0:	0f b7 c0             	movzwl %ax,%eax
  8075f3:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8075f5:	89 d8                	mov    %ebx,%eax
  8075f7:	c1 e8 10             	shr    $0x10,%eax
  8075fa:	0f b7 db             	movzwl %bx,%ebx
  8075fd:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8075ff:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807603:	74 18                	je     80761d <inet_chksum_pbuf+0x51>
      swapped = 1 - swapped;
  807605:	b8 01 00 00 00       	mov    $0x1,%eax
  80760a:	89 f9                	mov    %edi,%ecx
  80760c:	29 c8                	sub    %ecx,%eax
  80760e:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807610:	89 da                	mov    %ebx,%edx
  807612:	c1 e2 08             	shl    $0x8,%edx
  807615:	0f b7 d2             	movzwl %dx,%edx
  807618:	0f b6 df             	movzbl %bh,%ebx
  80761b:	09 d3                	or     %edx,%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80761d:	8b 36                	mov    (%esi),%esi
  80761f:	85 f6                	test   %esi,%esi
  807621:	75 c1                	jne    8075e4 <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807623:	89 f8                	mov    %edi,%eax
  807625:	84 c0                	test   %al,%al
  807627:	74 0d                	je     807636 <inet_chksum_pbuf+0x6a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807629:	89 da                	mov    %ebx,%edx
  80762b:	c1 e2 08             	shl    $0x8,%edx
  80762e:	0f b7 d2             	movzwl %dx,%edx
  807631:	0f b6 df             	movzbl %bh,%ebx
  807634:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807636:	89 d8                	mov    %ebx,%eax
  807638:	f7 d0                	not    %eax
}
  80763a:	83 c4 0c             	add    $0xc,%esp
  80763d:	5b                   	pop    %ebx
  80763e:	5e                   	pop    %esi
  80763f:	5f                   	pop    %edi
  807640:	5d                   	pop    %ebp
  807641:	c3                   	ret    

00807642 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807642:	55                   	push   %ebp
  807643:	89 e5                	mov    %esp,%ebp
  807645:	57                   	push   %edi
  807646:	56                   	push   %esi
  807647:	53                   	push   %ebx
  807648:	83 ec 14             	sub    $0x14,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80764b:	8b 45 08             	mov    0x8(%ebp),%eax
  80764e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807651:	8d 7d f0             	lea    -0x10(%ebp),%edi
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807654:	c7 45 e0 e4 49 b3 00 	movl   $0xb349e4,-0x20(%ebp)
  80765b:	0f b6 0f             	movzbl (%edi),%ecx
  80765e:	ba 00 00 00 00       	mov    $0x0,%edx
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807663:	0f b6 d9             	movzbl %cl,%ebx
  807666:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807669:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  80766c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80766f:	66 c1 e8 0b          	shr    $0xb,%ax
  807673:	89 c3                	mov    %eax,%ebx
  807675:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807678:	01 c0                	add    %eax,%eax
  80767a:	29 c1                	sub    %eax,%ecx
  80767c:	89 c8                	mov    %ecx,%eax
      *ap /= (u8_t)10;
  80767e:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  807680:	8d 72 01             	lea    0x1(%edx),%esi
  807683:	0f b6 d2             	movzbl %dl,%edx
  807686:	83 c0 30             	add    $0x30,%eax
  807689:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  80768d:	89 f2                	mov    %esi,%edx
    } while(*ap);
  80768f:	84 db                	test   %bl,%bl
  807691:	75 d0                	jne    807663 <inet_ntoa+0x21>
  807693:	c6 07 00             	movb   $0x0,(%edi)
  807696:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807699:	eb 0d                	jmp    8076a8 <inet_ntoa+0x66>
    while(i--)
      *rp++ = inv[i];
  80769b:	0f b6 c2             	movzbl %dl,%eax
  80769e:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  8076a3:	88 01                	mov    %al,(%ecx)
  8076a5:	83 c1 01             	add    $0x1,%ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  8076a8:	83 ea 01             	sub    $0x1,%edx
  8076ab:	80 fa ff             	cmp    $0xff,%dl
  8076ae:	75 eb                	jne    80769b <inet_ntoa+0x59>
  8076b0:	89 f0                	mov    %esi,%eax
  8076b2:	0f b6 f0             	movzbl %al,%esi
  8076b5:	03 75 e0             	add    -0x20(%ebp),%esi
      *rp++ = inv[i];
    *rp++ = '.';
  8076b8:	8d 46 01             	lea    0x1(%esi),%eax
  8076bb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8076be:	c6 06 2e             	movb   $0x2e,(%esi)
    ap++;
  8076c1:	83 c7 01             	add    $0x1,%edi
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8076c4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8076c7:	39 c7                	cmp    %eax,%edi
  8076c9:	75 90                	jne    80765b <inet_ntoa+0x19>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  8076cb:	c6 06 00             	movb   $0x0,(%esi)
  return str;
}
  8076ce:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  8076d3:	83 c4 14             	add    $0x14,%esp
  8076d6:	5b                   	pop    %ebx
  8076d7:	5e                   	pop    %esi
  8076d8:	5f                   	pop    %edi
  8076d9:	5d                   	pop    %ebp
  8076da:	c3                   	ret    

008076db <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8076db:	55                   	push   %ebp
  8076dc:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8076de:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076e2:	66 c1 c0 08          	rol    $0x8,%ax
}
  8076e6:	5d                   	pop    %ebp
  8076e7:	c3                   	ret    

008076e8 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8076e8:	55                   	push   %ebp
  8076e9:	89 e5                	mov    %esp,%ebp
  return htons(n);
  8076eb:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076ef:	66 c1 c0 08          	rol    $0x8,%ax
}
  8076f3:	5d                   	pop    %ebp
  8076f4:	c3                   	ret    

008076f5 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8076f5:	55                   	push   %ebp
  8076f6:	89 e5                	mov    %esp,%ebp
  8076f8:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8076fb:	89 d1                	mov    %edx,%ecx
  8076fd:	c1 e1 18             	shl    $0x18,%ecx
  807700:	89 d0                	mov    %edx,%eax
  807702:	c1 e8 18             	shr    $0x18,%eax
  807705:	09 c8                	or     %ecx,%eax
  807707:	89 d1                	mov    %edx,%ecx
  807709:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80770f:	c1 e1 08             	shl    $0x8,%ecx
  807712:	09 c8                	or     %ecx,%eax
  807714:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80771a:	c1 ea 08             	shr    $0x8,%edx
  80771d:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80771f:	5d                   	pop    %ebp
  807720:	c3                   	ret    

00807721 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807721:	55                   	push   %ebp
  807722:	89 e5                	mov    %esp,%ebp
  807724:	57                   	push   %edi
  807725:	56                   	push   %esi
  807726:	53                   	push   %ebx
  807727:	83 ec 20             	sub    $0x20,%esp
  80772a:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80772d:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  807730:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  807733:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807736:	0f b6 ca             	movzbl %dl,%ecx
  807739:	83 e9 30             	sub    $0x30,%ecx
  80773c:	83 f9 09             	cmp    $0x9,%ecx
  80773f:	0f 87 94 01 00 00    	ja     8078d9 <inet_aton+0x1b8>
      return (0);
    val = 0;
    base = 10;
  807745:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    if (c == '0') {
  80774c:	83 fa 30             	cmp    $0x30,%edx
  80774f:	75 2b                	jne    80777c <inet_aton+0x5b>
      c = *++cp;
  807751:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807755:	89 d1                	mov    %edx,%ecx
  807757:	83 e1 df             	and    $0xffffffdf,%ecx
  80775a:	80 f9 58             	cmp    $0x58,%cl
  80775d:	74 0f                	je     80776e <inet_aton+0x4d>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  80775f:	83 c0 01             	add    $0x1,%eax
  807762:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807765:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  80776c:	eb 0e                	jmp    80777c <inet_aton+0x5b>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  80776e:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807772:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807775:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
  80777c:	83 c0 01             	add    $0x1,%eax
  80777f:	be 00 00 00 00       	mov    $0x0,%esi
  807784:	eb 03                	jmp    807789 <inet_aton+0x68>
  807786:	83 c0 01             	add    $0x1,%eax
  807789:	8d 58 ff             	lea    -0x1(%eax),%ebx
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80778c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80778f:	0f b6 fa             	movzbl %dl,%edi
  807792:	8d 4f d0             	lea    -0x30(%edi),%ecx
  807795:	83 f9 09             	cmp    $0x9,%ecx
  807798:	77 0d                	ja     8077a7 <inet_aton+0x86>
        val = (val * base) + (int)(c - '0');
  80779a:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  80779e:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  8077a2:	0f be 10             	movsbl (%eax),%edx
  8077a5:	eb df                	jmp    807786 <inet_aton+0x65>
      } else if (base == 16 && isxdigit(c)) {
  8077a7:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  8077ab:	75 32                	jne    8077df <inet_aton+0xbe>
  8077ad:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  8077b0:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  8077b3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8077b6:	81 e1 df 00 00 00    	and    $0xdf,%ecx
  8077bc:	83 e9 41             	sub    $0x41,%ecx
  8077bf:	83 f9 05             	cmp    $0x5,%ecx
  8077c2:	77 1b                	ja     8077df <inet_aton+0xbe>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  8077c4:	c1 e6 04             	shl    $0x4,%esi
  8077c7:	83 c2 0a             	add    $0xa,%edx
  8077ca:	83 7d d8 1a          	cmpl   $0x1a,-0x28(%ebp)
  8077ce:	19 c9                	sbb    %ecx,%ecx
  8077d0:	83 e1 20             	and    $0x20,%ecx
  8077d3:	83 c1 41             	add    $0x41,%ecx
  8077d6:	29 ca                	sub    %ecx,%edx
  8077d8:	09 d6                	or     %edx,%esi
        c = *++cp;
  8077da:	0f be 10             	movsbl (%eax),%edx
  8077dd:	eb a7                	jmp    807786 <inet_aton+0x65>
      } else
        break;
    }
    if (c == '.') {
  8077df:	83 fa 2e             	cmp    $0x2e,%edx
  8077e2:	75 23                	jne    807807 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  8077e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8077e7:	8d 7d f0             	lea    -0x10(%ebp),%edi
  8077ea:	39 f8                	cmp    %edi,%eax
  8077ec:	0f 84 ee 00 00 00    	je     8078e0 <inet_aton+0x1bf>
        return (0);
      *pp++ = val;
  8077f2:	83 c0 04             	add    $0x4,%eax
  8077f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8077f8:	89 70 fc             	mov    %esi,-0x4(%eax)
      c = *++cp;
  8077fb:	8d 43 01             	lea    0x1(%ebx),%eax
  8077fe:	0f be 53 01          	movsbl 0x1(%ebx),%edx
    } else
      break;
  }
  807802:	e9 2f ff ff ff       	jmp    807736 <inet_aton+0x15>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807807:	85 d2                	test   %edx,%edx
  807809:	74 25                	je     807830 <inet_aton+0x10f>
  80780b:	8d 4f e0             	lea    -0x20(%edi),%ecx
    return (0);
  80780e:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807813:	83 f9 5f             	cmp    $0x5f,%ecx
  807816:	0f 87 d0 00 00 00    	ja     8078ec <inet_aton+0x1cb>
  80781c:	83 fa 20             	cmp    $0x20,%edx
  80781f:	74 0f                	je     807830 <inet_aton+0x10f>
  807821:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807824:	83 ea 09             	sub    $0x9,%edx
  807827:	83 fa 04             	cmp    $0x4,%edx
  80782a:	0f 87 bc 00 00 00    	ja     8078ec <inet_aton+0x1cb>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807830:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807833:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807836:	29 c2                	sub    %eax,%edx
  807838:	c1 fa 02             	sar    $0x2,%edx
  80783b:	83 c2 01             	add    $0x1,%edx
  80783e:	83 fa 02             	cmp    $0x2,%edx
  807841:	74 20                	je     807863 <inet_aton+0x142>
  807843:	83 fa 02             	cmp    $0x2,%edx
  807846:	7f 0f                	jg     807857 <inet_aton+0x136>

  case 0:
    return (0);       /* initial nondigit */
  807848:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80784d:	85 d2                	test   %edx,%edx
  80784f:	0f 84 97 00 00 00    	je     8078ec <inet_aton+0x1cb>
  807855:	eb 67                	jmp    8078be <inet_aton+0x19d>
  807857:	83 fa 03             	cmp    $0x3,%edx
  80785a:	74 1e                	je     80787a <inet_aton+0x159>
  80785c:	83 fa 04             	cmp    $0x4,%edx
  80785f:	74 38                	je     807899 <inet_aton+0x178>
  807861:	eb 5b                	jmp    8078be <inet_aton+0x19d>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  807863:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807868:	81 fe ff ff ff 00    	cmp    $0xffffff,%esi
  80786e:	77 7c                	ja     8078ec <inet_aton+0x1cb>
      return (0);
    val |= parts[0] << 24;
  807870:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807873:	c1 e0 18             	shl    $0x18,%eax
  807876:	09 c6                	or     %eax,%esi
    break;
  807878:	eb 44                	jmp    8078be <inet_aton+0x19d>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  80787a:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80787f:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  807885:	77 65                	ja     8078ec <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807887:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80788a:	c1 e2 18             	shl    $0x18,%edx
  80788d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  807890:	c1 e0 10             	shl    $0x10,%eax
  807893:	09 d0                	or     %edx,%eax
  807895:	09 c6                	or     %eax,%esi
    break;
  807897:	eb 25                	jmp    8078be <inet_aton+0x19d>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807899:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80789e:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  8078a4:	77 46                	ja     8078ec <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  8078a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8078a9:	c1 e2 18             	shl    $0x18,%edx
  8078ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8078af:	c1 e0 10             	shl    $0x10,%eax
  8078b2:	09 c2                	or     %eax,%edx
  8078b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8078b7:	c1 e0 08             	shl    $0x8,%eax
  8078ba:	09 d0                	or     %edx,%eax
  8078bc:	09 c6                	or     %eax,%esi
    break;
  }
  if (addr)
  8078be:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8078c2:	74 23                	je     8078e7 <inet_aton+0x1c6>
    addr->s_addr = htonl(val);
  8078c4:	56                   	push   %esi
  8078c5:	e8 2b fe ff ff       	call   8076f5 <htonl>
  8078ca:	83 c4 04             	add    $0x4,%esp
  8078cd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8078d0:	89 03                	mov    %eax,(%ebx)
  return (1);
  8078d2:	b8 01 00 00 00       	mov    $0x1,%eax
  8078d7:	eb 13                	jmp    8078ec <inet_aton+0x1cb>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  8078d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8078de:	eb 0c                	jmp    8078ec <inet_aton+0x1cb>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  8078e0:	b8 00 00 00 00       	mov    $0x0,%eax
  8078e5:	eb 05                	jmp    8078ec <inet_aton+0x1cb>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  8078e7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8078ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8078ef:	5b                   	pop    %ebx
  8078f0:	5e                   	pop    %esi
  8078f1:	5f                   	pop    %edi
  8078f2:	5d                   	pop    %ebp
  8078f3:	c3                   	ret    

008078f4 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  8078f4:	55                   	push   %ebp
  8078f5:	89 e5                	mov    %esp,%ebp
  8078f7:	83 ec 10             	sub    $0x10,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  8078fa:	8d 45 fc             	lea    -0x4(%ebp),%eax
  8078fd:	50                   	push   %eax
  8078fe:	ff 75 08             	pushl  0x8(%ebp)
  807901:	e8 1b fe ff ff       	call   807721 <inet_aton>
  807906:	83 c4 08             	add    $0x8,%esp
    return (val.s_addr);
  807909:	85 c0                	test   %eax,%eax
  80790b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807910:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  807914:	c9                   	leave  
  807915:	c3                   	ret    

00807916 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807916:	55                   	push   %ebp
  807917:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  807919:	ff 75 08             	pushl  0x8(%ebp)
  80791c:	e8 d4 fd ff ff       	call   8076f5 <htonl>
  807921:	83 c4 04             	add    $0x4,%esp
}
  807924:	c9                   	leave  
  807925:	c3                   	ret    

00807926 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807926:	55                   	push   %ebp
  807927:	89 e5                	mov    %esp,%ebp
  807929:	57                   	push   %edi
  80792a:	56                   	push   %esi
  80792b:	53                   	push   %ebx
  80792c:	83 ec 3c             	sub    $0x3c,%esp
  80792f:	8b 7d 08             	mov    0x8(%ebp),%edi
  807932:	8b 45 10             	mov    0x10(%ebp),%eax
  807935:	89 c6                	mov    %eax,%esi
  807937:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80793a:	8b 45 14             	mov    0x14(%ebp),%eax
  80793d:	89 c2                	mov    %eax,%edx
  80793f:	89 45 bc             	mov    %eax,-0x44(%ebp)
  807942:	8b 45 18             	mov    0x18(%ebp),%eax
  807945:	89 c3                	mov    %eax,%ebx
  807947:	89 45 b8             	mov    %eax,-0x48(%ebp)
  80794a:	8b 45 20             	mov    0x20(%ebp),%eax
  80794d:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807951:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807954:	89 da                	mov    %ebx,%edx
  807956:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807959:	66 85 f6             	test   %si,%si
  80795c:	74 1b                	je     807979 <tcp_enqueue+0x53>
  80795e:	84 c0                	test   %al,%al
  807960:	74 17                	je     807979 <tcp_enqueue+0x53>
  807962:	83 ec 04             	sub    $0x4,%esp
  807965:	68 40 1f 81 00       	push   $0x811f40
  80796a:	68 90 00 00 00       	push   $0x90
  80796f:	68 e2 20 81 00       	push   $0x8120e2
  807974:	e8 d1 6a 00 00       	call   80e44a <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807979:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80797d:	74 1d                	je     80799c <tcp_enqueue+0x76>
  80797f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807983:	74 17                	je     80799c <tcp_enqueue+0x76>
  807985:	83 ec 04             	sub    $0x4,%esp
  807988:	68 80 1f 81 00       	push   $0x811f80
  80798d:	68 92 00 00 00       	push   $0x92
  807992:	68 e2 20 81 00       	push   $0x8120e2
  807997:	e8 ae 6a 00 00       	call   80e44a <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80799c:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  8079a0:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  8079a4:	76 0e                	jbe    8079b4 <tcp_enqueue+0x8e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  8079a6:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079af:	e9 d1 05 00 00       	jmp    807f85 <tcp_enqueue+0x65f>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8079b4:	8b 4f 68             	mov    0x68(%edi),%ecx
  8079b7:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8079ba:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  8079be:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8079c2:	66 83 f9 1f          	cmp    $0x1f,%cx
  8079c6:	76 0e                	jbe    8079d6 <tcp_enqueue+0xb0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  8079c8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079d1:	e9 af 05 00 00       	jmp    807f85 <tcp_enqueue+0x65f>
  }
  if (queuelen != 0) {
  8079d6:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  8079db:	74 23                	je     807a00 <tcp_enqueue+0xda>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8079dd:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079e1:	75 29                	jne    807a0c <tcp_enqueue+0xe6>
  8079e3:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079e7:	75 23                	jne    807a0c <tcp_enqueue+0xe6>
  8079e9:	83 ec 04             	sub    $0x4,%esp
  8079ec:	68 c8 1f 81 00       	push   $0x811fc8
  8079f1:	68 ae 00 00 00       	push   $0xae
  8079f6:	68 e2 20 81 00       	push   $0x8120e2
  8079fb:	e8 4a 6a 00 00       	call   80e44a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807a00:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807a04:	75 41                	jne    807a47 <tcp_enqueue+0x121>
  807a06:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807a0a:	75 3b                	jne    807a47 <tcp_enqueue+0x121>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807a0c:	c0 e8 02             	shr    $0x2,%al
  807a0f:	c1 e0 0c             	shl    $0xc,%eax
  807a12:	66 05 00 50          	add    $0x5000,%ax
  807a16:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807a1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  807a1d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  807a20:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807a24:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807a28:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  807a2c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  807a33:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807a38:	83 e2 01             	and    $0x1,%edx
  807a3b:	88 55 c9             	mov    %dl,-0x37(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a3e:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807a42:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807a45:	eb 17                	jmp    807a5e <tcp_enqueue+0x138>
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807a47:	83 ec 04             	sub    $0x4,%esp
  807a4a:	68 04 20 81 00       	push   $0x812004
  807a4f:	68 b1 00 00 00       	push   $0xb1
  807a54:	68 e2 20 81 00       	push   $0x8120e2
  807a59:	e8 ec 69 00 00       	call   80e44a <_panic>
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  807a5e:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807a62:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807a66:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807a6b:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807a6f:	83 ec 0c             	sub    $0xc,%esp
  807a72:	6a 04                	push   $0x4
  807a74:	e8 e8 c9 ff ff       	call   804461 <memp_malloc>
  807a79:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807a7b:	83 c4 10             	add    $0x10,%esp
  807a7e:	85 c0                	test   %eax,%eax
  807a80:	0f 84 91 04 00 00    	je     807f17 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  807a86:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807a8c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  807a93:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807a97:	75 1f                	jne    807ab8 <tcp_enqueue+0x192>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807a99:	85 f6                	test   %esi,%esi
  807a9b:	75 17                	jne    807ab4 <tcp_enqueue+0x18e>
  807a9d:	83 ec 04             	sub    $0x4,%esp
  807aa0:	68 fa 20 81 00       	push   $0x8120fa
  807aa5:	68 ce 00 00 00       	push   $0xce
  807aaa:	68 e2 20 81 00       	push   $0x8120e2
  807aaf:	e8 96 69 00 00       	call   80e44a <_panic>
      useg->next = seg;
  807ab4:	89 06                	mov    %eax,(%esi)
  807ab6:	eb 03                	jmp    807abb <tcp_enqueue+0x195>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807ab8:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  807abb:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807abf:	74 5f                	je     807b20 <tcp_enqueue+0x1fa>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807ac1:	83 ec 04             	sub    $0x4,%esp
  807ac4:	6a 00                	push   $0x0
  807ac6:	ff 75 d4             	pushl  -0x2c(%ebp)
  807ac9:	6a 00                	push   $0x0
  807acb:	e8 20 ce ff ff       	call   8048f0 <pbuf_alloc>
  807ad0:	89 43 04             	mov    %eax,0x4(%ebx)
  807ad3:	83 c4 10             	add    $0x10,%esp
  807ad6:	85 c0                	test   %eax,%eax
  807ad8:	0f 84 39 04 00 00    	je     807f17 <tcp_enqueue+0x5f1>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807ade:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807ae2:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807ae6:	73 17                	jae    807aff <tcp_enqueue+0x1d9>
  807ae8:	83 ec 04             	sub    $0x4,%esp
  807aeb:	68 38 20 81 00       	push   $0x812038
  807af0:	68 df 00 00 00       	push   $0xdf
  807af5:	68 e2 20 81 00       	push   $0x8120e2
  807afa:	e8 4b 69 00 00       	call   80e44a <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  807aff:	83 ec 0c             	sub    $0xc,%esp
  807b02:	50                   	push   %eax
  807b03:	e8 81 d1 ff ff       	call   804c89 <pbuf_clen>
  807b08:	0f b6 c0             	movzbl %al,%eax
  807b0b:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807b0f:	8b 43 04             	mov    0x4(%ebx),%eax
  807b12:	8b 40 04             	mov    0x4(%eax),%eax
  807b15:	89 43 08             	mov    %eax,0x8(%ebx)
  807b18:	83 c4 10             	add    $0x10,%esp
  807b1b:	e9 00 01 00 00       	jmp    807c20 <tcp_enqueue+0x2fa>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807b20:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807b24:	74 7c                	je     807ba2 <tcp_enqueue+0x27c>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807b26:	83 ec 04             	sub    $0x4,%esp
  807b29:	6a 00                	push   $0x0
  807b2b:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807b2f:	0f b7 c6             	movzwl %si,%eax
  807b32:	50                   	push   %eax
  807b33:	6a 00                	push   $0x0
  807b35:	e8 b6 cd ff ff       	call   8048f0 <pbuf_alloc>
  807b3a:	89 43 04             	mov    %eax,0x4(%ebx)
  807b3d:	83 c4 10             	add    $0x10,%esp
  807b40:	85 c0                	test   %eax,%eax
  807b42:	0f 84 cf 03 00 00    	je     807f17 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807b48:	66 3b 70 0a          	cmp    0xa(%eax),%si
  807b4c:	76 17                	jbe    807b65 <tcp_enqueue+0x23f>
  807b4e:	83 ec 04             	sub    $0x4,%esp
  807b51:	68 60 20 81 00       	push   $0x812060
  807b56:	68 ea 00 00 00       	push   $0xea
  807b5b:	68 e2 20 81 00       	push   $0x8120e2
  807b60:	e8 e5 68 00 00       	call   80e44a <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  807b65:	83 ec 0c             	sub    $0xc,%esp
  807b68:	50                   	push   %eax
  807b69:	e8 1b d1 ff ff       	call   804c89 <pbuf_clen>
  807b6e:	0f b6 c0             	movzbl %al,%eax
  807b71:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807b75:	83 c4 10             	add    $0x10,%esp
  807b78:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807b7c:	74 19                	je     807b97 <tcp_enqueue+0x271>
        MEMCPY(seg->p->payload, ptr, seglen);
  807b7e:	83 ec 04             	sub    $0x4,%esp
  807b81:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807b85:	50                   	push   %eax
  807b86:	ff 75 cc             	pushl  -0x34(%ebp)
  807b89:	8b 43 04             	mov    0x4(%ebx),%eax
  807b8c:	ff 70 04             	pushl  0x4(%eax)
  807b8f:	e8 0e 71 00 00       	call   80eca2 <memcpy>
  807b94:	83 c4 10             	add    $0x10,%esp
      }
      seg->dataptr = seg->p->payload;
  807b97:	8b 43 04             	mov    0x4(%ebx),%eax
  807b9a:	8b 40 04             	mov    0x4(%eax),%eax
  807b9d:	89 43 08             	mov    %eax,0x8(%ebx)
  807ba0:	eb 7e                	jmp    807c20 <tcp_enqueue+0x2fa>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807ba2:	83 ec 04             	sub    $0x4,%esp
  807ba5:	6a 01                	push   $0x1
  807ba7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807bab:	50                   	push   %eax
  807bac:	6a 00                	push   $0x0
  807bae:	e8 3d cd ff ff       	call   8048f0 <pbuf_alloc>
  807bb3:	89 c6                	mov    %eax,%esi
  807bb5:	83 c4 10             	add    $0x10,%esp
  807bb8:	85 c0                	test   %eax,%eax
  807bba:	0f 84 57 03 00 00    	je     807f17 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  807bc0:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807bc4:	83 c0 01             	add    $0x1,%eax
  807bc7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  807bcb:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807bce:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807bd1:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807bd4:	83 ec 04             	sub    $0x4,%esp
  807bd7:	6a 00                	push   $0x0
  807bd9:	6a 00                	push   $0x0
  807bdb:	6a 00                	push   $0x0
  807bdd:	e8 0e cd ff ff       	call   8048f0 <pbuf_alloc>
  807be2:	89 43 04             	mov    %eax,0x4(%ebx)
  807be5:	83 c4 10             	add    $0x10,%esp
  807be8:	85 c0                	test   %eax,%eax
  807bea:	75 11                	jne    807bfd <tcp_enqueue+0x2d7>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  807bec:	83 ec 0c             	sub    $0xc,%esp
  807bef:	56                   	push   %esi
  807bf0:	e8 35 cc ff ff       	call   80482a <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  807bf5:	83 c4 10             	add    $0x10,%esp
  807bf8:	e9 1a 03 00 00       	jmp    807f17 <tcp_enqueue+0x5f1>
      }
      queuelen += pbuf_clen(seg->p);
  807bfd:	83 ec 0c             	sub    $0xc,%esp
  807c00:	50                   	push   %eax
  807c01:	e8 83 d0 ff ff       	call   804c89 <pbuf_clen>
  807c06:	0f b6 c0             	movzbl %al,%eax
  807c09:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807c0d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807c11:	83 c4 08             	add    $0x8,%esp
  807c14:	56                   	push   %esi
  807c15:	ff 73 04             	pushl  0x4(%ebx)
  807c18:	e8 95 d0 ff ff       	call   804cb2 <pbuf_cat>
  807c1d:	83 c4 10             	add    $0x10,%esp
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807c20:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807c25:	0f 87 ec 02 00 00    	ja     807f17 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  807c2b:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807c2f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807c33:	83 ec 08             	sub    $0x8,%esp
  807c36:	6a 14                	push   $0x14
  807c38:	ff 73 04             	pushl  0x4(%ebx)
  807c3b:	e8 18 cb ff ff       	call   804758 <pbuf_header>
  807c40:	83 c4 10             	add    $0x10,%esp
  807c43:	84 c0                	test   %al,%al
  807c45:	0f 85 cc 02 00 00    	jne    807f17 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  807c4b:	8b 43 04             	mov    0x4(%ebx),%eax
  807c4e:	8b 70 04             	mov    0x4(%eax),%esi
  807c51:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807c54:	83 ec 0c             	sub    $0xc,%esp
  807c57:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807c5b:	50                   	push   %eax
  807c5c:	e8 7a fa ff ff       	call   8076db <htons>
  807c61:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807c64:	8b 73 10             	mov    0x10(%ebx),%esi
  807c67:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807c6b:	89 04 24             	mov    %eax,(%esp)
  807c6e:	e8 68 fa ff ff       	call   8076db <htons>
  807c73:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807c77:	8b 73 10             	mov    0x10(%ebx),%esi
  807c7a:	83 c4 04             	add    $0x4,%esp
  807c7d:	ff 75 d8             	pushl  -0x28(%ebp)
  807c80:	e8 70 fa ff ff       	call   8076f5 <htonl>
  807c85:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807c88:	8b 43 10             	mov    0x10(%ebx),%eax
  807c8b:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807c91:	8b 73 10             	mov    0x10(%ebx),%esi
  807c94:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c98:	89 04 24             	mov    %eax,(%esp)
  807c9b:	e8 48 fa ff ff       	call   8076e8 <ntohs>
  807ca0:	83 e0 c0             	and    $0xffffffc0,%eax
  807ca3:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807ca7:	09 d0                	or     %edx,%eax
  807ca9:	0f b7 c0             	movzwl %ax,%eax
  807cac:	89 04 24             	mov    %eax,(%esp)
  807caf:	e8 27 fa ff ff       	call   8076db <htons>
  807cb4:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  807cb8:	83 c4 10             	add    $0x10,%esp
  807cbb:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807cbf:	75 27                	jne    807ce8 <tcp_enqueue+0x3c2>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807cc1:	8b 73 10             	mov    0x10(%ebx),%esi
  807cc4:	83 ec 0c             	sub    $0xc,%esp
  807cc7:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807ccb:	50                   	push   %eax
  807ccc:	e8 17 fa ff ff       	call   8076e8 <ntohs>
  807cd1:	83 e0 3f             	and    $0x3f,%eax
  807cd4:	80 cc 50             	or     $0x50,%ah
  807cd7:	89 04 24             	mov    %eax,(%esp)
  807cda:	e8 fc f9 ff ff       	call   8076db <htons>
  807cdf:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807ce3:	83 c4 10             	add    $0x10,%esp
  807ce6:	eb 3a                	jmp    807d22 <tcp_enqueue+0x3fc>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807ce8:	8b 73 10             	mov    0x10(%ebx),%esi
  807ceb:	83 ec 0c             	sub    $0xc,%esp
  807cee:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807cf2:	50                   	push   %eax
  807cf3:	e8 f0 f9 ff ff       	call   8076e8 <ntohs>
  807cf8:	83 e0 3f             	and    $0x3f,%eax
  807cfb:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807cff:	0f b7 c0             	movzwl %ax,%eax
  807d02:	89 04 24             	mov    %eax,(%esp)
  807d05:	e8 d1 f9 ff ff       	call   8076db <htons>
  807d0a:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807d0e:	83 c4 0c             	add    $0xc,%esp
  807d11:	ff 75 d4             	pushl  -0x2c(%ebp)
  807d14:	ff 75 1c             	pushl  0x1c(%ebp)
  807d17:	ff 73 08             	pushl  0x8(%ebx)
  807d1a:	e8 83 6f 00 00       	call   80eca2 <memcpy>
  807d1f:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807d22:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807d26:	0f b7 c1             	movzwl %cx,%eax
  807d29:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807d2c:	01 45 cc             	add    %eax,-0x34(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807d2f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  807d33:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807d37:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807d3b:	89 de                	mov    %ebx,%esi

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807d3d:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807d41:	0f 85 17 fd ff ff    	jne    807a5e <tcp_enqueue+0x138>
  807d47:	84 c0                	test   %al,%al
  807d49:	0f 85 0f fd ff ff    	jne    807a5e <tcp_enqueue+0x138>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807d4f:	8b 77 74             	mov    0x74(%edi),%esi
  807d52:	85 f6                	test   %esi,%esi
  807d54:	75 07                	jne    807d5d <tcp_enqueue+0x437>
  807d56:	e9 ff 00 00 00       	jmp    807e5a <tcp_enqueue+0x534>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807d5b:	89 c6                	mov    %eax,%esi
  807d5d:	8b 06                	mov    (%esi),%eax
  807d5f:	85 c0                	test   %eax,%eax
  807d61:	75 f8                	jne    807d5b <tcp_enqueue+0x435>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807d63:	85 f6                	test   %esi,%esi
  807d65:	0f 84 ef 00 00 00    	je     807e5a <tcp_enqueue+0x534>
    TCP_TCPLEN(useg) != 0 &&
  807d6b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807d6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807d72:	83 ec 0c             	sub    $0xc,%esp
  807d75:	8b 46 10             	mov    0x10(%esi),%eax
  807d78:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d7c:	50                   	push   %eax
  807d7d:	e8 66 f9 ff ff       	call   8076e8 <ntohs>
  807d82:	83 c4 10             	add    $0x10,%esp
  807d85:	ba 01 00 00 00       	mov    $0x1,%edx
  807d8a:	a8 01                	test   $0x1,%al
  807d8c:	75 1b                	jne    807da9 <tcp_enqueue+0x483>
  807d8e:	83 ec 0c             	sub    $0xc,%esp
  807d91:	8b 46 10             	mov    0x10(%esi),%eax
  807d94:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d98:	50                   	push   %eax
  807d99:	e8 4a f9 ff ff       	call   8076e8 <ntohs>
  807d9e:	66 d1 e8             	shr    %ax
  807da1:	89 c2                	mov    %eax,%edx
  807da3:	83 e2 01             	and    $0x1,%edx
  807da6:	83 c4 10             	add    $0x10,%esp
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807da9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807dac:	01 d0                	add    %edx,%eax
  807dae:	0f 84 c7 01 00 00    	je     807f7b <tcp_enqueue+0x655>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807db4:	83 ec 0c             	sub    $0xc,%esp
  807db7:	8b 46 10             	mov    0x10(%esi),%eax
  807dba:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807dbe:	50                   	push   %eax
  807dbf:	e8 24 f9 ff ff       	call   8076e8 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807dc4:	83 c4 10             	add    $0x10,%esp
  807dc7:	a8 03                	test   $0x3,%al
  807dc9:	0f 85 ac 01 00 00    	jne    807f7b <tcp_enqueue+0x655>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dcf:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807dd3:	0f 85 a2 01 00 00    	jne    807f7b <tcp_enqueue+0x655>
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807dd9:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  807ddd:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807de0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807de4:	01 d0                	add    %edx,%eax
  807de6:	0f b7 57 34          	movzwl 0x34(%edi),%edx
  807dea:	39 d0                	cmp    %edx,%eax
  807dec:	0f 8f 89 01 00 00    	jg     807f7b <tcp_enqueue+0x655>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807df2:	83 ec 08             	sub    $0x8,%esp
  807df5:	6a ec                	push   $0xffffffec
  807df7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807dfa:	ff 70 04             	pushl  0x4(%eax)
  807dfd:	e8 56 c9 ff ff       	call   804758 <pbuf_header>
  807e02:	83 c4 10             	add    $0x10,%esp
  807e05:	84 c0                	test   %al,%al
  807e07:	74 17                	je     807e20 <tcp_enqueue+0x4fa>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807e09:	83 ec 04             	sub    $0x4,%esp
  807e0c:	68 07 21 81 00       	push   $0x812107
  807e11:	68 52 01 00 00       	push   $0x152
  807e16:	68 e2 20 81 00       	push   $0x8120e2
  807e1b:	e8 2a 66 00 00       	call   80e44a <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807e20:	83 ec 08             	sub    $0x8,%esp
  807e23:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e26:	ff 70 04             	pushl  0x4(%eax)
  807e29:	ff 76 04             	pushl  0x4(%esi)
  807e2c:	e8 81 ce ff ff       	call   804cb2 <pbuf_cat>
    useg->len += queue->len;
  807e31:	8b 55 d0             	mov    -0x30(%ebp),%edx
  807e34:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807e38:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  807e3c:	8b 02                	mov    (%edx),%eax
  807e3e:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807e40:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807e43:	39 da                	cmp    %ebx,%edx
  807e45:	b8 00 00 00 00       	mov    $0x0,%eax
  807e4a:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807e4d:	52                   	push   %edx
  807e4e:	6a 04                	push   $0x4
  807e50:	e8 62 c6 ff ff       	call   8044b7 <memp_free>
  807e55:	83 c4 10             	add    $0x10,%esp
  807e58:	eb 1f                	jmp    807e79 <tcp_enqueue+0x553>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  807e5a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e5d:	89 47 74             	mov    %eax,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807e60:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807e64:	83 e2 03             	and    $0x3,%edx
    ++len;
  807e67:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807e6b:	83 c0 01             	add    $0x1,%eax
  807e6e:	84 d2                	test   %dl,%dl
  807e70:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807e75:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  807e79:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807e7d:	74 04                	je     807e83 <tcp_enqueue+0x55d>
    pcb->flags |= TF_FIN;
  807e7f:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  807e83:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807e87:	0f b7 c2             	movzwl %dx,%eax
  807e8a:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  807e8d:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  807e91:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807e95:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  807e99:	66 85 c0             	test   %ax,%ax
  807e9c:	74 23                	je     807ec1 <tcp_enqueue+0x59b>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807e9e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ea2:	75 1d                	jne    807ec1 <tcp_enqueue+0x59b>
  807ea4:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807ea8:	75 17                	jne    807ec1 <tcp_enqueue+0x59b>
  807eaa:	83 ec 04             	sub    $0x4,%esp
  807ead:	68 94 20 81 00       	push   $0x812094
  807eb2:	68 7a 01 00 00       	push   $0x17a
  807eb7:	68 e2 20 81 00       	push   $0x8120e2
  807ebc:	e8 89 65 00 00       	call   80e44a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ec1:	85 db                	test   %ebx,%ebx
  807ec3:	0f 84 8f 00 00 00    	je     807f58 <tcp_enqueue+0x632>
  807ec9:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807ece:	0f 84 84 00 00 00    	je     807f58 <tcp_enqueue+0x632>
  807ed4:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807ed7:	85 db                	test   %ebx,%ebx
  807ed9:	0f 84 80 00 00 00    	je     807f5f <tcp_enqueue+0x639>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807edf:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ee4:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807ee8:	0f 85 97 00 00 00    	jne    807f85 <tcp_enqueue+0x65f>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807eee:	83 ec 0c             	sub    $0xc,%esp
  807ef1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  807ef5:	50                   	push   %eax
  807ef6:	e8 ed f7 ff ff       	call   8076e8 <ntohs>
  807efb:	83 c8 08             	or     $0x8,%eax
  807efe:	0f b7 c0             	movzwl %ax,%eax
  807f01:	89 04 24             	mov    %eax,(%esp)
  807f04:	e8 d2 f7 ff ff       	call   8076db <htons>
  807f09:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807f0d:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
  807f10:	b8 00 00 00 00       	mov    $0x0,%eax
  807f15:	eb 6e                	jmp    807f85 <tcp_enqueue+0x65f>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807f17:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807f1b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807f1e:	85 c0                	test   %eax,%eax
  807f20:	74 0c                	je     807f2e <tcp_enqueue+0x608>
    tcp_segs_free(queue);
  807f22:	83 ec 0c             	sub    $0xc,%esp
  807f25:	50                   	push   %eax
  807f26:	e8 89 d8 ff ff       	call   8057b4 <tcp_segs_free>
  807f2b:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807f2e:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807f33:	74 31                	je     807f66 <tcp_enqueue+0x640>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807f35:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807f39:	75 32                	jne    807f6d <tcp_enqueue+0x647>
  807f3b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807f3f:	75 33                	jne    807f74 <tcp_enqueue+0x64e>
  807f41:	83 ec 04             	sub    $0x4,%esp
  807f44:	68 94 20 81 00       	push   $0x812094
  807f49:	68 8d 01 00 00       	push   $0x18d
  807f4e:	68 e2 20 81 00       	push   $0x8120e2
  807f53:	e8 f2 64 00 00       	call   80e44a <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807f58:	b8 00 00 00 00       	mov    $0x0,%eax
  807f5d:	eb 26                	jmp    807f85 <tcp_enqueue+0x65f>
  807f5f:	b8 00 00 00 00       	mov    $0x0,%eax
  807f64:	eb 1f                	jmp    807f85 <tcp_enqueue+0x65f>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f6b:	eb 18                	jmp    807f85 <tcp_enqueue+0x65f>
  807f6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f72:	eb 11                	jmp    807f85 <tcp_enqueue+0x65f>
  807f74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f79:	eb 0a                	jmp    807f85 <tcp_enqueue+0x65f>
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  807f7b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807f7e:	89 06                	mov    %eax,(%esi)
  807f80:	e9 db fe ff ff       	jmp    807e60 <tcp_enqueue+0x53a>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  807f85:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807f88:	5b                   	pop    %ebx
  807f89:	5e                   	pop    %esi
  807f8a:	5f                   	pop    %edi
  807f8b:	5d                   	pop    %ebp
  807f8c:	c3                   	ret    

00807f8d <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  807f8d:	55                   	push   %ebp
  807f8e:	89 e5                	mov    %esp,%ebp
  807f90:	83 ec 0c             	sub    $0xc,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807f93:	6a 00                	push   $0x0
  807f95:	6a 00                	push   $0x0
  807f97:	6a 01                	push   $0x1
  807f99:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807f9d:	50                   	push   %eax
  807f9e:	6a 00                	push   $0x0
  807fa0:	6a 00                	push   $0x0
  807fa2:	ff 75 08             	pushl  0x8(%ebp)
  807fa5:	e8 7c f9 ff ff       	call   807926 <tcp_enqueue>
}
  807faa:	c9                   	leave  
  807fab:	c3                   	ret    

00807fac <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  807fac:	55                   	push   %ebp
  807fad:	89 e5                	mov    %esp,%ebp
  807faf:	56                   	push   %esi
  807fb0:	53                   	push   %ebx
  807fb1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807fb4:	8b 55 10             	mov    0x10(%ebp),%edx
  807fb7:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  807fba:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  807fbd:	8d 70 fe             	lea    -0x2(%eax),%esi
  807fc0:	83 fe 02             	cmp    $0x2,%esi
  807fc3:	76 05                	jbe    807fca <tcp_write+0x1e>
  807fc5:	83 f8 07             	cmp    $0x7,%eax
  807fc8:	75 29                	jne    807ff3 <tcp_write+0x47>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  807fca:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  807fcf:	66 85 d2             	test   %dx,%dx
  807fd2:	74 24                	je     807ff8 <tcp_write+0x4c>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807fd4:	83 ec 04             	sub    $0x4,%esp
  807fd7:	6a 00                	push   $0x0
  807fd9:	6a 00                	push   $0x0
  807fdb:	0f b6 db             	movzbl %bl,%ebx
  807fde:	53                   	push   %ebx
  807fdf:	6a 00                	push   $0x0
  807fe1:	0f b7 d2             	movzwl %dx,%edx
  807fe4:	52                   	push   %edx
  807fe5:	ff 75 0c             	pushl  0xc(%ebp)
  807fe8:	51                   	push   %ecx
  807fe9:	e8 38 f9 ff ff       	call   807926 <tcp_enqueue>
  807fee:	83 c4 20             	add    $0x20,%esp
  807ff1:	eb 05                	jmp    807ff8 <tcp_write+0x4c>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  807ff3:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  807ff8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807ffb:	5b                   	pop    %ebx
  807ffc:	5e                   	pop    %esi
  807ffd:	5d                   	pop    %ebp
  807ffe:	c3                   	ret    

00807fff <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  807fff:	55                   	push   %ebp
  808000:	89 e5                	mov    %esp,%ebp
  808002:	57                   	push   %edi
  808003:	56                   	push   %esi
  808004:	53                   	push   %ebx
  808005:	83 ec 1c             	sub    $0x1c,%esp
  808008:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80800b:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  808011:	0f 84 36 04 00 00    	je     80844d <tcp_output+0x44e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808017:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80801b:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  80801f:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  808024:	0f b7 c0             	movzwl %ax,%eax
  808027:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80802a:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80802d:	8b 47 78             	mov    0x78(%edi),%eax
  808030:	89 45 dc             	mov    %eax,-0x24(%ebp)
  808033:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  808036:	85 c0                	test   %eax,%eax
  808038:	75 06                	jne    808040 <tcp_output+0x41>
  80803a:	eb 0d                	jmp    808049 <tcp_output+0x4a>
    for (; useg->next != NULL; useg = useg->next);
  80803c:	89 c2                	mov    %eax,%edx
  80803e:	eb 00                	jmp    808040 <tcp_output+0x41>
  808040:	8b 02                	mov    (%edx),%eax
  808042:	85 c0                	test   %eax,%eax
  808044:	75 f6                	jne    80803c <tcp_output+0x3d>
  808046:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808049:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80804d:	75 0b                	jne    80805a <tcp_output+0x5b>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80804f:	8d 47 04             	lea    0x4(%edi),%eax
  808052:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808055:	e9 8c 03 00 00       	jmp    8083e6 <tcp_output+0x3e7>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80805a:	85 db                	test   %ebx,%ebx
  80805c:	74 1f                	je     80807d <tcp_output+0x7e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80805e:	83 ec 0c             	sub    $0xc,%esp
  808061:	8b 43 10             	mov    0x10(%ebx),%eax
  808064:	ff 70 04             	pushl  0x4(%eax)
  808067:	e8 aa f8 ff ff       	call   807916 <ntohl>
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  80806c:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808070:	2b 57 48             	sub    0x48(%edi),%edx
  808073:	01 d0                	add    %edx,%eax
  808075:	83 c4 10             	add    $0x10,%esp
  808078:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80807b:	73 d2                	jae    80804f <tcp_output+0x50>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80807d:	83 ec 04             	sub    $0x4,%esp
  808080:	6a 00                	push   $0x0
  808082:	6a 14                	push   $0x14
  808084:	6a 01                	push   $0x1
  808086:	e8 65 c8 ff ff       	call   8048f0 <pbuf_alloc>
  80808b:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80808d:	83 c4 10             	add    $0x10,%esp
  808090:	85 c0                	test   %eax,%eax
  808092:	0f 84 bc 03 00 00    	je     808454 <tcp_output+0x455>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808098:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  80809c:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  80809f:	83 ec 0c             	sub    $0xc,%esp
  8080a2:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8080a6:	50                   	push   %eax
  8080a7:	e8 2f f6 ff ff       	call   8076db <htons>
  8080ac:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8080af:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8080b3:	89 04 24             	mov    %eax,(%esp)
  8080b6:	e8 20 f6 ff ff       	call   8076db <htons>
  8080bb:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8080bf:	83 c4 04             	add    $0x4,%esp
  8080c2:	ff 77 54             	pushl  0x54(%edi)
  8080c5:	e8 2b f6 ff ff       	call   8076f5 <htonl>
  8080ca:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8080cd:	83 c4 04             	add    $0x4,%esp
  8080d0:	ff 77 24             	pushl  0x24(%edi)
  8080d3:	e8 1d f6 ff ff       	call   8076f5 <htonl>
  8080d8:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8080db:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8080df:	89 04 24             	mov    %eax,(%esp)
  8080e2:	e8 01 f6 ff ff       	call   8076e8 <ntohs>
  8080e7:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8080ec:	83 c8 10             	or     $0x10,%eax
  8080ef:	89 04 24             	mov    %eax,(%esp)
  8080f2:	e8 e4 f5 ff ff       	call   8076db <htons>
  8080f7:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8080fb:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8080ff:	89 04 24             	mov    %eax,(%esp)
  808102:	e8 d4 f5 ff ff       	call   8076db <htons>
  808107:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80810b:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  808111:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808115:	89 04 24             	mov    %eax,(%esp)
  808118:	e8 cb f5 ff ff       	call   8076e8 <ntohs>
  80811d:	83 e0 3f             	and    $0x3f,%eax
  808120:	80 cc 50             	or     $0x50,%ah
  808123:	89 04 24             	mov    %eax,(%esp)
  808126:	e8 b0 f5 ff ff       	call   8076db <htons>
  80812b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80812f:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808135:	8d 47 04             	lea    0x4(%edi),%eax
  808138:	89 c1                	mov    %eax,%ecx
  80813a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80813e:	89 04 24             	mov    %eax,(%esp)
  808141:	6a 06                	push   $0x6
  808143:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808146:	51                   	push   %ecx
  808147:	57                   	push   %edi
  808148:	56                   	push   %esi
  808149:	e8 74 f2 ff ff       	call   8073c2 <inet_chksum_pseudo>
  80814e:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808152:	83 c4 18             	add    $0x18,%esp
  808155:	6a 06                	push   $0x6
  808157:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80815b:	50                   	push   %eax
  80815c:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808160:	50                   	push   %eax
  808161:	ff 75 e4             	pushl  -0x1c(%ebp)
  808164:	57                   	push   %edi
  808165:	56                   	push   %esi
  808166:	e8 9e e8 ff ff       	call   806a09 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80816b:	83 c4 14             	add    $0x14,%esp
  80816e:	56                   	push   %esi
  80816f:	e8 b6 c6 ff ff       	call   80482a <pbuf_free>

    return ERR_OK;
  808174:	83 c4 10             	add    $0x10,%esp
  808177:	b8 00 00 00 00       	mov    $0x0,%eax
  80817c:	e9 ed 02 00 00       	jmp    80846e <tcp_output+0x46f>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808181:	83 ec 0c             	sub    $0xc,%esp
  808184:	8b 43 10             	mov    0x10(%ebx),%eax
  808187:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80818b:	50                   	push   %eax
  80818c:	e8 57 f5 ff ff       	call   8076e8 <ntohs>
  808191:	83 c4 10             	add    $0x10,%esp
  808194:	a8 04                	test   $0x4,%al
  808196:	74 17                	je     8081af <tcp_output+0x1b0>
  808198:	83 ec 04             	sub    $0x4,%esp
  80819b:	68 1b 21 81 00       	push   $0x81211b
  8081a0:	68 05 02 00 00       	push   $0x205
  8081a5:	68 e2 20 81 00       	push   $0x8120e2
  8081aa:	e8 9b 62 00 00       	call   80e44a <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8081af:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8081b3:	74 1c                	je     8081d1 <tcp_output+0x1d2>
  8081b5:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8081b9:	a8 40                	test   $0x40,%al
  8081bb:	75 14                	jne    8081d1 <tcp_output+0x1d2>
  8081bd:	8b 57 74             	mov    0x74(%edi),%edx
  8081c0:	85 d2                	test   %edx,%edx
  8081c2:	0f 84 93 02 00 00    	je     80845b <tcp_output+0x45c>
  8081c8:	83 3a 00             	cmpl   $0x0,(%edx)
  8081cb:	0f 84 8a 02 00 00    	je     80845b <tcp_output+0x45c>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  8081d1:	8b 03                	mov    (%ebx),%eax
  8081d3:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  8081d6:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8081da:	74 29                	je     808205 <tcp_output+0x206>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8081dc:	8b 73 10             	mov    0x10(%ebx),%esi
  8081df:	83 ec 0c             	sub    $0xc,%esp
  8081e2:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8081e6:	50                   	push   %eax
  8081e7:	e8 fc f4 ff ff       	call   8076e8 <ntohs>
  8081ec:	83 c8 10             	or     $0x10,%eax
  8081ef:	0f b7 c0             	movzwl %ax,%eax
  8081f2:	89 04 24             	mov    %eax,(%esp)
  8081f5:	e8 e1 f4 ff ff       	call   8076db <htons>
  8081fa:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081fe:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  808202:	83 c4 10             	add    $0x10,%esp
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808205:	8b 73 10             	mov    0x10(%ebx),%esi
  808208:	83 ec 0c             	sub    $0xc,%esp
  80820b:	ff 77 24             	pushl  0x24(%edi)
  80820e:	e8 e2 f4 ff ff       	call   8076f5 <htonl>
  808213:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808216:	8b 73 10             	mov    0x10(%ebx),%esi
  808219:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80821d:	89 04 24             	mov    %eax,(%esp)
  808220:	e8 b6 f4 ff ff       	call   8076db <htons>
  808225:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  808229:	83 c4 10             	add    $0x10,%esp
  80822c:	85 ff                	test   %edi,%edi
  80822e:	74 05                	je     808235 <tcp_output+0x236>
  808230:	83 3f 00             	cmpl   $0x0,(%edi)
  808233:	75 27                	jne    80825c <tcp_output+0x25d>
    netif = ip_route(&(pcb->remote_ip));
  808235:	83 ec 0c             	sub    $0xc,%esp
  808238:	ff 75 e4             	pushl  -0x1c(%ebp)
  80823b:	e8 df e2 ff ff       	call   80651f <ip_route>
    if (netif == NULL) {
  808240:	83 c4 10             	add    $0x10,%esp
  808243:	85 c0                	test   %eax,%eax
  808245:	0f 84 a2 00 00 00    	je     8082ed <tcp_output+0x2ee>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80824b:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80824e:	74 05                	je     808255 <tcp_output+0x256>
  808250:	8b 40 04             	mov    0x4(%eax),%eax
  808253:	eb 05                	jmp    80825a <tcp_output+0x25b>
  808255:	b8 00 00 00 00       	mov    $0x0,%eax
  80825a:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80825c:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808261:	75 06                	jne    808269 <tcp_output+0x26a>
    pcb->rtime = 0;
  808263:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  808269:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80826d:	75 1c                	jne    80828b <tcp_output+0x28c>
    pcb->rttest = tcp_ticks;
  80826f:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  808274:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808277:	83 ec 0c             	sub    $0xc,%esp
  80827a:	8b 43 10             	mov    0x10(%ebx),%eax
  80827d:	ff 70 04             	pushl  0x4(%eax)
  808280:	e8 91 f6 ff ff       	call   807916 <ntohl>
  808285:	89 47 3c             	mov    %eax,0x3c(%edi)
  808288:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80828b:	8b 53 04             	mov    0x4(%ebx),%edx
  80828e:	8b 43 10             	mov    0x10(%ebx),%eax
  808291:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  808294:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808298:	8b 53 04             	mov    0x4(%ebx),%edx
  80829b:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  80829f:	8b 43 04             	mov    0x4(%ebx),%eax
  8082a2:	8b 53 10             	mov    0x10(%ebx),%edx
  8082a5:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  8082a8:	8b 43 10             	mov    0x10(%ebx),%eax
  8082ab:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8082b1:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8082b4:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8082b7:	83 ec 0c             	sub    $0xc,%esp
  8082ba:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8082be:	52                   	push   %edx
  8082bf:	6a 06                	push   $0x6
  8082c1:	ff 75 e4             	pushl  -0x1c(%ebp)
  8082c4:	57                   	push   %edi
  8082c5:	50                   	push   %eax
  8082c6:	e8 f7 f0 ff ff       	call   8073c2 <inet_chksum_pseudo>
  8082cb:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8082cf:	83 c4 18             	add    $0x18,%esp
  8082d2:	6a 06                	push   $0x6
  8082d4:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8082d8:	50                   	push   %eax
  8082d9:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8082dd:	50                   	push   %eax
  8082de:	ff 75 e4             	pushl  -0x1c(%ebp)
  8082e1:	57                   	push   %edi
  8082e2:	ff 73 04             	pushl  0x4(%ebx)
  8082e5:	e8 1f e7 ff ff       	call   806a09 <ip_output>
  8082ea:	83 c4 20             	add    $0x20,%esp
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8082ed:	83 ec 0c             	sub    $0xc,%esp
  8082f0:	8b 43 10             	mov    0x10(%ebx),%eax
  8082f3:	ff 70 04             	pushl  0x4(%eax)
  8082f6:	e8 1b f6 ff ff       	call   807916 <ntohl>
  8082fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8082fe:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808302:	8b 43 10             	mov    0x10(%ebx),%eax
  808305:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808309:	89 04 24             	mov    %eax,(%esp)
  80830c:	e8 d7 f3 ff ff       	call   8076e8 <ntohs>
  808311:	83 c4 10             	add    $0x10,%esp
  808314:	ba 01 00 00 00       	mov    $0x1,%edx
  808319:	a8 01                	test   $0x1,%al
  80831b:	75 1b                	jne    808338 <tcp_output+0x339>
  80831d:	83 ec 0c             	sub    $0xc,%esp
  808320:	8b 43 10             	mov    0x10(%ebx),%eax
  808323:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808327:	50                   	push   %eax
  808328:	e8 bb f3 ff ff       	call   8076e8 <ntohs>
  80832d:	66 d1 e8             	shr    %ax
  808330:	89 c2                	mov    %eax,%edx
  808332:	83 e2 01             	and    $0x1,%edx
  808335:	83 c4 10             	add    $0x10,%esp
  808338:	01 d6                	add    %edx,%esi
  80833a:	03 75 e0             	add    -0x20(%ebp),%esi
  80833d:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  808340:	39 77 58             	cmp    %esi,0x58(%edi)
  808343:	79 03                	jns    808348 <tcp_output+0x349>
      pcb->snd_max = pcb->snd_nxt;
  808345:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808348:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80834c:	83 ec 0c             	sub    $0xc,%esp
  80834f:	8b 43 10             	mov    0x10(%ebx),%eax
  808352:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808356:	50                   	push   %eax
  808357:	e8 8c f3 ff ff       	call   8076e8 <ntohs>
  80835c:	83 c4 10             	add    $0x10,%esp
  80835f:	ba 01 00 00 00       	mov    $0x1,%edx
  808364:	a8 01                	test   $0x1,%al
  808366:	75 1b                	jne    808383 <tcp_output+0x384>
  808368:	83 ec 0c             	sub    $0xc,%esp
  80836b:	8b 43 10             	mov    0x10(%ebx),%eax
  80836e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808372:	50                   	push   %eax
  808373:	e8 70 f3 ff ff       	call   8076e8 <ntohs>
  808378:	66 d1 e8             	shr    %ax
  80837b:	89 c2                	mov    %eax,%edx
  80837d:	83 e2 01             	and    $0x1,%edx
  808380:	83 c4 10             	add    $0x10,%esp
  808383:	01 f2                	add    %esi,%edx
  808385:	74 50                	je     8083d7 <tcp_output+0x3d8>
      seg->next = NULL;
  808387:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80838d:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808391:	75 08                	jne    80839b <tcp_output+0x39c>
        pcb->unacked = seg;
  808393:	89 5f 78             	mov    %ebx,0x78(%edi)
  808396:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808399:	eb 48                	jmp    8083e3 <tcp_output+0x3e4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80839b:	83 ec 0c             	sub    $0xc,%esp
  80839e:	8b 43 10             	mov    0x10(%ebx),%eax
  8083a1:	ff 70 04             	pushl  0x4(%eax)
  8083a4:	e8 6d f5 ff ff       	call   807916 <ntohl>
  8083a9:	89 c6                	mov    %eax,%esi
  8083ab:	83 c4 04             	add    $0x4,%esp
  8083ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8083b1:	8b 40 10             	mov    0x10(%eax),%eax
  8083b4:	ff 70 04             	pushl  0x4(%eax)
  8083b7:	e8 5a f5 ff ff       	call   807916 <ntohl>
  8083bc:	83 c4 10             	add    $0x10,%esp
  8083bf:	39 c6                	cmp    %eax,%esi
  8083c1:	79 0a                	jns    8083cd <tcp_output+0x3ce>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  8083c3:	8b 47 78             	mov    0x78(%edi),%eax
  8083c6:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  8083c8:	89 5f 78             	mov    %ebx,0x78(%edi)
  8083cb:	eb 16                	jmp    8083e3 <tcp_output+0x3e4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  8083cd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8083d0:	89 18                	mov    %ebx,(%eax)
  8083d2:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  8083d5:	eb 0c                	jmp    8083e3 <tcp_output+0x3e4>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  8083d7:	83 ec 0c             	sub    $0xc,%esp
  8083da:	53                   	push   %ebx
  8083db:	e8 90 d3 ff ff       	call   805770 <tcp_seg_free>
  8083e0:	83 c4 10             	add    $0x10,%esp
    }
    seg = pcb->unsent;
  8083e3:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8083e6:	85 db                	test   %ebx,%ebx
  8083e8:	74 58                	je     808442 <tcp_output+0x443>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  8083ea:	83 ec 0c             	sub    $0xc,%esp
  8083ed:	8b 43 10             	mov    0x10(%ebx),%eax
  8083f0:	ff 70 04             	pushl  0x4(%eax)
  8083f3:	e8 1e f5 ff ff       	call   807916 <ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8083f8:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8083fc:	2b 57 48             	sub    0x48(%edi),%edx
  8083ff:	01 d0                	add    %edx,%eax
  808401:	83 c4 10             	add    $0x10,%esp
  808404:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808407:	0f 83 74 fd ff ff    	jae    808181 <tcp_output+0x182>
  80840d:	eb 54                	jmp    808463 <tcp_output+0x464>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80840f:	83 ec 0c             	sub    $0xc,%esp
  808412:	8b 43 10             	mov    0x10(%ebx),%eax
  808415:	ff 70 04             	pushl  0x4(%eax)
  808418:	e8 f9 f4 ff ff       	call   807916 <ntohl>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80841d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808421:	2b 57 48             	sub    0x48(%edi),%edx
  808424:	01 d0                	add    %edx,%eax
  808426:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80842a:	83 c4 10             	add    $0x10,%esp
  80842d:	39 d0                	cmp    %edx,%eax
  80842f:	76 11                	jbe    808442 <tcp_output+0x443>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808431:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808438:	00 00 00 
    pcb->persist_backoff = 1;
  80843b:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808442:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808446:	b8 00 00 00 00       	mov    $0x0,%eax
  80844b:	eb 21                	jmp    80846e <tcp_output+0x46f>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  80844d:	b8 00 00 00 00       	mov    $0x0,%eax
  808452:	eb 1a                	jmp    80846e <tcp_output+0x46f>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808454:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808459:	eb 13                	jmp    80846e <tcp_output+0x46f>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80845b:	a8 a0                	test   $0xa0,%al
  80845d:	0f 85 6e fd ff ff    	jne    8081d1 <tcp_output+0x1d2>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808463:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80846a:	75 d6                	jne    808442 <tcp_output+0x443>
  80846c:	eb a1                	jmp    80840f <tcp_output+0x410>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  80846e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808471:	5b                   	pop    %ebx
  808472:	5e                   	pop    %esi
  808473:	5f                   	pop    %edi
  808474:	5d                   	pop    %ebp
  808475:	c3                   	ret    

00808476 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808476:	55                   	push   %ebp
  808477:	89 e5                	mov    %esp,%ebp
  808479:	57                   	push   %edi
  80847a:	56                   	push   %esi
  80847b:	53                   	push   %ebx
  80847c:	83 ec 20             	sub    $0x20,%esp
  80847f:	8b 7d 18             	mov    0x18(%ebp),%edi
  808482:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808485:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808488:	6a 00                	push   $0x0
  80848a:	6a 14                	push   $0x14
  80848c:	6a 01                	push   $0x1
  80848e:	e8 5d c4 ff ff       	call   8048f0 <pbuf_alloc>
  if (p == NULL) {
  808493:	83 c4 10             	add    $0x10,%esp
  808496:	85 c0                	test   %eax,%eax
  808498:	0f 84 f5 00 00 00    	je     808593 <tcp_rst+0x11d>
  80849e:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8084a0:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8084a5:	77 17                	ja     8084be <tcp_rst+0x48>
  8084a7:	83 ec 04             	sub    $0x4,%esp
  8084aa:	68 b4 20 81 00       	push   $0x8120b4
  8084af:	68 be 02 00 00       	push   $0x2be
  8084b4:	68 e2 20 81 00       	push   $0x8120e2
  8084b9:	e8 8c 5f 00 00       	call   80e44a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8084be:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8084c1:	83 ec 0c             	sub    $0xc,%esp
  8084c4:	0f b7 ff             	movzwl %di,%edi
  8084c7:	57                   	push   %edi
  8084c8:	e8 0e f2 ff ff       	call   8076db <htons>
  8084cd:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8084d0:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8084d4:	89 04 24             	mov    %eax,(%esp)
  8084d7:	e8 ff f1 ff ff       	call   8076db <htons>
  8084dc:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8084e0:	83 c4 04             	add    $0x4,%esp
  8084e3:	ff 75 08             	pushl  0x8(%ebp)
  8084e6:	e8 0a f2 ff ff       	call   8076f5 <htonl>
  8084eb:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8084ee:	83 c4 04             	add    $0x4,%esp
  8084f1:	ff 75 0c             	pushl  0xc(%ebp)
  8084f4:	e8 fc f1 ff ff       	call   8076f5 <htonl>
  8084f9:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8084fc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808500:	89 04 24             	mov    %eax,(%esp)
  808503:	e8 e0 f1 ff ff       	call   8076e8 <ntohs>
  808508:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80850d:	83 c8 14             	or     $0x14,%eax
  808510:	89 04 24             	mov    %eax,(%esp)
  808513:	e8 c3 f1 ff ff       	call   8076db <htons>
  808518:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80851c:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808523:	e8 b3 f1 ff ff       	call   8076db <htons>
  808528:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80852c:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808532:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808536:	89 04 24             	mov    %eax,(%esp)
  808539:	e8 aa f1 ff ff       	call   8076e8 <ntohs>
  80853e:	83 e0 3f             	and    $0x3f,%eax
  808541:	80 cc 50             	or     $0x50,%ah
  808544:	89 04 24             	mov    %eax,(%esp)
  808547:	e8 8f f1 ff ff       	call   8076db <htons>
  80854c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808550:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808556:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80855a:	89 04 24             	mov    %eax,(%esp)
  80855d:	6a 06                	push   $0x6
  80855f:	ff 75 14             	pushl  0x14(%ebp)
  808562:	ff 75 10             	pushl  0x10(%ebp)
  808565:	56                   	push   %esi
  808566:	e8 57 ee ff ff       	call   8073c2 <inet_chksum_pseudo>
  80856b:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80856f:	83 c4 18             	add    $0x18,%esp
  808572:	6a 06                	push   $0x6
  808574:	6a 00                	push   $0x0
  808576:	68 ff 00 00 00       	push   $0xff
  80857b:	ff 75 14             	pushl  0x14(%ebp)
  80857e:	ff 75 10             	pushl  0x10(%ebp)
  808581:	56                   	push   %esi
  808582:	e8 82 e4 ff ff       	call   806a09 <ip_output>
  pbuf_free(p);
  808587:	83 c4 14             	add    $0x14,%esp
  80858a:	56                   	push   %esi
  80858b:	e8 9a c2 ff ff       	call   80482a <pbuf_free>
  808590:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808593:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808596:	5b                   	pop    %ebx
  808597:	5e                   	pop    %esi
  808598:	5f                   	pop    %edi
  808599:	5d                   	pop    %ebp
  80859a:	c3                   	ret    

0080859b <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80859b:	55                   	push   %ebp
  80859c:	89 e5                	mov    %esp,%ebp
  80859e:	53                   	push   %ebx
  80859f:	83 ec 04             	sub    $0x4,%esp
  8085a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085a5:	8b 53 78             	mov    0x78(%ebx),%edx
  8085a8:	85 d2                	test   %edx,%edx
  8085aa:	75 04                	jne    8085b0 <tcp_rexmit_rto+0x15>
  8085ac:	eb 41                	jmp    8085ef <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8085ae:	89 c2                	mov    %eax,%edx
  8085b0:	8b 02                	mov    (%edx),%eax
  8085b2:	85 c0                	test   %eax,%eax
  8085b4:	75 f8                	jne    8085ae <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8085b6:	8b 43 74             	mov    0x74(%ebx),%eax
  8085b9:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8085bb:	8b 43 78             	mov    0x78(%ebx),%eax
  8085be:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8085c1:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8085c8:	83 ec 0c             	sub    $0xc,%esp
  8085cb:	8b 40 10             	mov    0x10(%eax),%eax
  8085ce:	ff 70 04             	pushl  0x4(%eax)
  8085d1:	e8 40 f3 ff ff       	call   807916 <ntohl>
  8085d6:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8085d9:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8085dd:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8085e4:	89 1c 24             	mov    %ebx,(%esp)
  8085e7:	e8 13 fa ff ff       	call   807fff <tcp_output>
  8085ec:	83 c4 10             	add    $0x10,%esp
}
  8085ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8085f2:	c9                   	leave  
  8085f3:	c3                   	ret    

008085f4 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8085f4:	55                   	push   %ebp
  8085f5:	89 e5                	mov    %esp,%ebp
  8085f7:	53                   	push   %ebx
  8085f8:	83 ec 04             	sub    $0x4,%esp
  8085fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085fe:	8b 43 78             	mov    0x78(%ebx),%eax
  808601:	85 c0                	test   %eax,%eax
  808603:	74 37                	je     80863c <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808605:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808607:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80860a:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80860c:	8b 43 78             	mov    0x78(%ebx),%eax
  80860f:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808612:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808615:	83 ec 0c             	sub    $0xc,%esp
  808618:	8b 40 10             	mov    0x10(%eax),%eax
  80861b:	ff 70 04             	pushl  0x4(%eax)
  80861e:	e8 f3 f2 ff ff       	call   807916 <ntohl>
  808623:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808626:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80862a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808631:	89 1c 24             	mov    %ebx,(%esp)
  808634:	e8 c6 f9 ff ff       	call   807fff <tcp_output>
  808639:	83 c4 10             	add    $0x10,%esp
}
  80863c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80863f:	c9                   	leave  
  808640:	c3                   	ret    

00808641 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808641:	55                   	push   %ebp
  808642:	89 e5                	mov    %esp,%ebp
  808644:	57                   	push   %edi
  808645:	56                   	push   %esi
  808646:	53                   	push   %ebx
  808647:	83 ec 20             	sub    $0x20,%esp
  80864a:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80864d:	6a 00                	push   $0x0
  80864f:	6a 14                	push   $0x14
  808651:	6a 01                	push   $0x1
  808653:	e8 98 c2 ff ff       	call   8048f0 <pbuf_alloc>
   
  if(p == NULL) {
  808658:	83 c4 10             	add    $0x10,%esp
  80865b:	85 c0                	test   %eax,%eax
  80865d:	0f 84 f8 00 00 00    	je     80875b <tcp_keepalive+0x11a>
  808663:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808665:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80866a:	77 17                	ja     808683 <tcp_keepalive+0x42>
  80866c:	83 ec 04             	sub    $0x4,%esp
  80866f:	68 b4 20 81 00       	push   $0x8120b4
  808674:	68 3a 03 00 00       	push   $0x33a
  808679:	68 e2 20 81 00       	push   $0x8120e2
  80867e:	e8 c7 5d 00 00       	call   80e44a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808683:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808686:	83 ec 0c             	sub    $0xc,%esp
  808689:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80868d:	50                   	push   %eax
  80868e:	e8 48 f0 ff ff       	call   8076db <htons>
  808693:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808696:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80869a:	89 04 24             	mov    %eax,(%esp)
  80869d:	e8 39 f0 ff ff       	call   8076db <htons>
  8086a2:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8086a6:	8b 46 54             	mov    0x54(%esi),%eax
  8086a9:	83 e8 01             	sub    $0x1,%eax
  8086ac:	89 04 24             	mov    %eax,(%esp)
  8086af:	e8 41 f0 ff ff       	call   8076f5 <htonl>
  8086b4:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086b7:	83 c4 04             	add    $0x4,%esp
  8086ba:	ff 76 24             	pushl  0x24(%esi)
  8086bd:	e8 33 f0 ff ff       	call   8076f5 <htonl>
  8086c2:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8086c5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086c9:	89 04 24             	mov    %eax,(%esp)
  8086cc:	e8 17 f0 ff ff       	call   8076e8 <ntohs>
  8086d1:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8086d6:	89 04 24             	mov    %eax,(%esp)
  8086d9:	e8 fd ef ff ff       	call   8076db <htons>
  8086de:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8086e2:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8086e6:	89 04 24             	mov    %eax,(%esp)
  8086e9:	e8 ed ef ff ff       	call   8076db <htons>
  8086ee:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8086f2:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8086f8:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086fc:	89 04 24             	mov    %eax,(%esp)
  8086ff:	e8 e4 ef ff ff       	call   8076e8 <ntohs>
  808704:	83 e0 3f             	and    $0x3f,%eax
  808707:	80 cc 50             	or     $0x50,%ah
  80870a:	89 04 24             	mov    %eax,(%esp)
  80870d:	e8 c9 ef ff ff       	call   8076db <htons>
  808712:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808716:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80871c:	8d 46 04             	lea    0x4(%esi),%eax
  80871f:	89 c2                	mov    %eax,%edx
  808721:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808725:	89 04 24             	mov    %eax,(%esp)
  808728:	6a 06                	push   $0x6
  80872a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80872d:	52                   	push   %edx
  80872e:	56                   	push   %esi
  80872f:	57                   	push   %edi
  808730:	e8 8d ec ff ff       	call   8073c2 <inet_chksum_pseudo>
  808735:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808739:	83 c4 18             	add    $0x18,%esp
  80873c:	6a 06                	push   $0x6
  80873e:	6a 00                	push   $0x0
  808740:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808744:	50                   	push   %eax
  808745:	ff 75 e4             	pushl  -0x1c(%ebp)
  808748:	56                   	push   %esi
  808749:	57                   	push   %edi
  80874a:	e8 ba e2 ff ff       	call   806a09 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80874f:	83 c4 14             	add    $0x14,%esp
  808752:	57                   	push   %edi
  808753:	e8 d2 c0 ff ff       	call   80482a <pbuf_free>
  808758:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80875b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80875e:	5b                   	pop    %ebx
  80875f:	5e                   	pop    %esi
  808760:	5f                   	pop    %edi
  808761:	5d                   	pop    %ebp
  808762:	c3                   	ret    

00808763 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808763:	55                   	push   %ebp
  808764:	89 e5                	mov    %esp,%ebp
  808766:	57                   	push   %edi
  808767:	56                   	push   %esi
  808768:	53                   	push   %ebx
  808769:	83 ec 1c             	sub    $0x1c,%esp
  80876c:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80876f:	8b 46 78             	mov    0x78(%esi),%eax
  808772:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808775:	85 c0                	test   %eax,%eax
  808777:	75 0e                	jne    808787 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808779:	8b 46 74             	mov    0x74(%esi),%eax
  80877c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80877f:	85 c0                	test   %eax,%eax
  808781:	0f 84 1b 01 00 00    	je     8088a2 <tcp_zero_window_probe+0x13f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808787:	83 ec 04             	sub    $0x4,%esp
  80878a:	6a 00                	push   $0x0
  80878c:	6a 15                	push   $0x15
  80878e:	6a 01                	push   $0x1
  808790:	e8 5b c1 ff ff       	call   8048f0 <pbuf_alloc>
  808795:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808797:	83 c4 10             	add    $0x10,%esp
  80879a:	85 c0                	test   %eax,%eax
  80879c:	0f 84 00 01 00 00    	je     8088a2 <tcp_zero_window_probe+0x13f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087a2:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087a7:	77 17                	ja     8087c0 <tcp_zero_window_probe+0x5d>
  8087a9:	83 ec 04             	sub    $0x4,%esp
  8087ac:	68 b4 20 81 00       	push   $0x8120b4
  8087b1:	68 8d 03 00 00       	push   $0x38d
  8087b6:	68 e2 20 81 00       	push   $0x8120e2
  8087bb:	e8 8a 5c 00 00       	call   80e44a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087c0:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087c3:	83 ec 0c             	sub    $0xc,%esp
  8087c6:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8087ca:	50                   	push   %eax
  8087cb:	e8 0b ef ff ff       	call   8076db <htons>
  8087d0:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8087d3:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8087d7:	89 04 24             	mov    %eax,(%esp)
  8087da:	e8 fc ee ff ff       	call   8076db <htons>
  8087df:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8087e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8087e6:	8b 40 10             	mov    0x10(%eax),%eax
  8087e9:	8b 40 04             	mov    0x4(%eax),%eax
  8087ec:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8087ef:	83 c4 04             	add    $0x4,%esp
  8087f2:	ff 76 24             	pushl  0x24(%esi)
  8087f5:	e8 fb ee ff ff       	call   8076f5 <htonl>
  8087fa:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8087fd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808801:	89 04 24             	mov    %eax,(%esp)
  808804:	e8 df ee ff ff       	call   8076e8 <ntohs>
  808809:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80880e:	89 04 24             	mov    %eax,(%esp)
  808811:	e8 c5 ee ff ff       	call   8076db <htons>
  808816:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80881a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80881e:	89 04 24             	mov    %eax,(%esp)
  808821:	e8 b5 ee ff ff       	call   8076db <htons>
  808826:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80882a:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808830:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808834:	89 04 24             	mov    %eax,(%esp)
  808837:	e8 ac ee ff ff       	call   8076e8 <ntohs>
  80883c:	83 e0 3f             	and    $0x3f,%eax
  80883f:	80 cc 50             	or     $0x50,%ah
  808842:	89 04 24             	mov    %eax,(%esp)
  808845:	e8 91 ee ff ff       	call   8076db <htons>
  80884a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80884e:	8b 47 04             	mov    0x4(%edi),%eax
  808851:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808854:	8b 51 08             	mov    0x8(%ecx),%edx
  808857:	0f b6 12             	movzbl (%edx),%edx
  80885a:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80885d:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808863:	8d 46 04             	lea    0x4(%esi),%eax
  808866:	89 c1                	mov    %eax,%ecx
  808868:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80886c:	89 04 24             	mov    %eax,(%esp)
  80886f:	6a 06                	push   $0x6
  808871:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808874:	51                   	push   %ecx
  808875:	56                   	push   %esi
  808876:	57                   	push   %edi
  808877:	e8 46 eb ff ff       	call   8073c2 <inet_chksum_pseudo>
  80887c:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808880:	83 c4 18             	add    $0x18,%esp
  808883:	6a 06                	push   $0x6
  808885:	6a 00                	push   $0x0
  808887:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80888b:	50                   	push   %eax
  80888c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80888f:	56                   	push   %esi
  808890:	57                   	push   %edi
  808891:	e8 73 e1 ff ff       	call   806a09 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808896:	83 c4 14             	add    $0x14,%esp
  808899:	57                   	push   %edi
  80889a:	e8 8b bf ff ff       	call   80482a <pbuf_free>
  80889f:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8088a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8088a5:	5b                   	pop    %ebx
  8088a6:	5e                   	pop    %esi
  8088a7:	5f                   	pop    %edi
  8088a8:	5d                   	pop    %ebp
  8088a9:	c3                   	ret    

008088aa <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8088aa:	55                   	push   %ebp
  8088ab:	89 e5                	mov    %esp,%ebp
  8088ad:	57                   	push   %edi
  8088ae:	56                   	push   %esi
  8088af:	53                   	push   %ebx
  8088b0:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8088b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8088b6:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8088b9:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8088bd:	0f b7 07             	movzwl (%edi),%eax
  8088c0:	50                   	push   %eax
  8088c1:	e8 22 ee ff ff       	call   8076e8 <ntohs>
  8088c6:	66 c1 e8 08          	shr    $0x8,%ax
  8088ca:	83 e0 0f             	and    $0xf,%eax
  8088cd:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8088d4:	83 c4 10             	add    $0x10,%esp
  8088d7:	39 c3                	cmp    %eax,%ebx
  8088d9:	7c 29                	jl     808904 <udp_input+0x5a>
  8088db:	83 ec 0c             	sub    $0xc,%esp
  8088de:	0f b7 07             	movzwl (%edi),%eax
  8088e1:	50                   	push   %eax
  8088e2:	e8 01 ee ff ff       	call   8076e8 <ntohs>
  8088e7:	83 c4 08             	add    $0x8,%esp
  8088ea:	66 c1 e8 06          	shr    $0x6,%ax
  8088ee:	83 e0 3c             	and    $0x3c,%eax
  8088f1:	f7 d8                	neg    %eax
  8088f3:	98                   	cwtl   
  8088f4:	50                   	push   %eax
  8088f5:	ff 75 08             	pushl  0x8(%ebp)
  8088f8:	e8 5b be ff ff       	call   804758 <pbuf_header>
  8088fd:	83 c4 10             	add    $0x10,%esp
  808900:	84 c0                	test   %al,%al
  808902:	74 13                	je     808917 <udp_input+0x6d>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808904:	83 ec 0c             	sub    $0xc,%esp
  808907:	ff 75 08             	pushl  0x8(%ebp)
  80890a:	e8 1b bf ff ff       	call   80482a <pbuf_free>
    goto end;
  80890f:	83 c4 10             	add    $0x10,%esp
  808912:	e9 ce 02 00 00       	jmp    808be5 <udp_input+0x33b>
  }

  udphdr = (struct udp_hdr *)p->payload;
  808917:	8b 45 08             	mov    0x8(%ebp),%eax
  80891a:	8b 40 04             	mov    0x4(%eax),%eax
  80891d:	89 c6                	mov    %eax,%esi
  80891f:	89 45 d0             	mov    %eax,-0x30(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  808922:	83 ec 0c             	sub    $0xc,%esp
  808925:	0f b7 00             	movzwl (%eax),%eax
  808928:	50                   	push   %eax
  808929:	e8 ba ed ff ff       	call   8076e8 <ntohs>
  80892e:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  dest = ntohs(udphdr->dest);
  808932:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808936:	89 04 24             	mov    %eax,(%esp)
  808939:	e8 aa ed ff ff       	call   8076e8 <ntohs>
  80893e:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  808940:	83 c4 10             	add    $0x10,%esp
  808943:	66 83 f8 44          	cmp    $0x44,%ax
  808947:	75 49                	jne    808992 <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  808949:	66 83 7d da 43       	cmpw   $0x43,-0x26(%ebp)
  80894e:	0f 85 06 01 00 00    	jne    808a5a <udp_input+0x1b0>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808954:	8b 45 0c             	mov    0xc(%ebp),%eax
  808957:	8b 40 20             	mov    0x20(%eax),%eax
  80895a:	85 c0                	test   %eax,%eax
  80895c:	0f 84 f8 00 00 00    	je     808a5a <udp_input+0x1b0>
  808962:	8b 40 08             	mov    0x8(%eax),%eax
  808965:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808968:	85 c0                	test   %eax,%eax
  80896a:	0f 84 ea 00 00 00    	je     808a5a <udp_input+0x1b0>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808970:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808973:	0f 84 f7 00 00 00    	je     808a70 <udp_input+0x1c6>
  808979:	8b 40 04             	mov    0x4(%eax),%eax
  80897c:	85 c0                	test   %eax,%eax
  80897e:	0f 84 ec 00 00 00    	je     808a70 <udp_input+0x1c6>
  808984:	3b 47 0c             	cmp    0xc(%edi),%eax
  808987:	0f 85 cd 00 00 00    	jne    808a5a <udp_input+0x1b0>
  80898d:	e9 de 00 00 00       	jmp    808a70 <udp_input+0x1c6>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808992:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  808998:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  80899f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8089a6:	8d 47 10             	lea    0x10(%edi),%eax
  8089a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8089ac:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8089af:	0f b7 7d da          	movzwl -0x26(%ebp),%edi
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089b3:	e9 91 00 00 00       	jmp    808a49 <udp_input+0x19f>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8089b8:	66 3b 73 12          	cmp    0x12(%ebx),%si
  8089bc:	0f 85 81 00 00 00    	jne    808a43 <udp_input+0x199>
  8089c2:	85 db                	test   %ebx,%ebx
  8089c4:	74 23                	je     8089e9 <udp_input+0x13f>
          (ip_addr_isany(&pcb->local_ip) ||
  8089c6:	8b 03                	mov    (%ebx),%eax
  8089c8:	85 c0                	test   %eax,%eax
  8089ca:	74 1d                	je     8089e9 <udp_input+0x13f>
  8089cc:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8089cf:	3b 42 10             	cmp    0x10(%edx),%eax
  8089d2:	74 15                	je     8089e9 <udp_input+0x13f>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8089d4:	83 ec 08             	sub    $0x8,%esp
  8089d7:	ff 75 0c             	pushl  0xc(%ebp)
  8089da:	ff 75 d4             	pushl  -0x2c(%ebp)
  8089dd:	e8 f1 da ff ff       	call   8064d3 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8089e2:	83 c4 10             	add    $0x10,%esp
  8089e5:	84 c0                	test   %al,%al
  8089e7:	74 5a                	je     808a43 <udp_input+0x199>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8089e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8089ed:	0f 85 db 01 00 00    	jne    808bce <udp_input+0x324>
  8089f3:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8089f7:	83 e0 04             	and    $0x4,%eax
  8089fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8089fd:	0f 44 c3             	cmove  %ebx,%eax
  808a00:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808a03:	e9 c6 01 00 00       	jmp    808bce <udp_input+0x324>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  808a08:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808a0b:	74 0f                	je     808a1c <udp_input+0x172>
          (ip_addr_isany(&pcb->remote_ip) ||
  808a0d:	8b 43 04             	mov    0x4(%ebx),%eax
  808a10:	85 c0                	test   %eax,%eax
  808a12:	74 08                	je     808a1c <udp_input+0x172>
  808a14:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808a17:	3b 41 0c             	cmp    0xc(%ecx),%eax
  808a1a:	75 27                	jne    808a43 <udp_input+0x199>
  808a1c:	8b 7d dc             	mov    -0x24(%ebp),%edi
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  808a1f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808a22:	85 d2                	test   %edx,%edx
  808a24:	0f 84 b3 01 00 00    	je     808bdd <udp_input+0x333>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  808a2a:	8b 43 0c             	mov    0xc(%ebx),%eax
  808a2d:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808a30:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808a35:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808a38:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808a3e:	e9 9a 01 00 00       	jmp    808bdd <udp_input+0x333>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808a43:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808a46:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808a49:	85 db                	test   %ebx,%ebx
  808a4b:	0f 85 67 ff ff ff    	jne    8089b8 <udp_input+0x10e>
  808a51:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808a54:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  808a58:	75 16                	jne    808a70 <udp_input+0x1c6>
  808a5a:	8b 45 0c             	mov    0xc(%ebp),%eax
  808a5d:	8b 57 10             	mov    0x10(%edi),%edx
  808a60:	39 50 04             	cmp    %edx,0x4(%eax)
  808a63:	0f 85 55 01 00 00    	jne    808bbe <udp_input+0x314>
  808a69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  808a70:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808a73:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808a78:	74 38                	je     808ab2 <udp_input+0x208>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808a7a:	83 ec 0c             	sub    $0xc,%esp
  808a7d:	8b 45 08             	mov    0x8(%ebp),%eax
  808a80:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808a84:	50                   	push   %eax
  808a85:	6a 11                	push   $0x11
  808a87:	8d 47 10             	lea    0x10(%edi),%eax
  808a8a:	50                   	push   %eax
  808a8b:	8d 47 0c             	lea    0xc(%edi),%eax
  808a8e:	50                   	push   %eax
  808a8f:	ff 75 08             	pushl  0x8(%ebp)
  808a92:	e8 2b e9 ff ff       	call   8073c2 <inet_chksum_pseudo>
  808a97:	83 c4 20             	add    $0x20,%esp
  808a9a:	66 85 c0             	test   %ax,%ax
  808a9d:	74 13                	je     808ab2 <udp_input+0x208>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  808a9f:	83 ec 0c             	sub    $0xc,%esp
  808aa2:	ff 75 08             	pushl  0x8(%ebp)
  808aa5:	e8 80 bd ff ff       	call   80482a <pbuf_free>
          goto end;
  808aaa:	83 c4 10             	add    $0x10,%esp
  808aad:	e9 33 01 00 00       	jmp    808be5 <udp_input+0x33b>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  808ab2:	83 ec 08             	sub    $0x8,%esp
  808ab5:	6a f8                	push   $0xfffffff8
  808ab7:	ff 75 08             	pushl  0x8(%ebp)
  808aba:	e8 99 bc ff ff       	call   804758 <pbuf_header>
  808abf:	83 c4 10             	add    $0x10,%esp
  808ac2:	84 c0                	test   %al,%al
  808ac4:	74 17                	je     808add <udp_input+0x233>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808ac6:	83 ec 04             	sub    $0x4,%esp
  808ac9:	68 07 21 81 00       	push   $0x812107
  808ace:	68 0a 01 00 00       	push   $0x10a
  808ad3:	68 32 21 81 00       	push   $0x812132
  808ad8:	e8 6d 59 00 00       	call   80e44a <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  808add:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  808ae0:	85 c9                	test   %ecx,%ecx
  808ae2:	74 37                	je     808b1b <udp_input+0x271>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  808ae4:	8b 41 18             	mov    0x18(%ecx),%eax
  808ae7:	85 c0                	test   %eax,%eax
  808ae9:	74 1d                	je     808b08 <udp_input+0x25e>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808aeb:	83 ec 0c             	sub    $0xc,%esp
  808aee:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  808af2:	52                   	push   %edx
  808af3:	83 c7 0c             	add    $0xc,%edi
  808af6:	57                   	push   %edi
  808af7:	ff 75 08             	pushl  0x8(%ebp)
  808afa:	51                   	push   %ecx
  808afb:	ff 71 1c             	pushl  0x1c(%ecx)
  808afe:	ff d0                	call   *%eax
  808b00:	83 c4 20             	add    $0x20,%esp
  808b03:	e9 dd 00 00 00       	jmp    808be5 <udp_input+0x33b>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  808b08:	83 ec 0c             	sub    $0xc,%esp
  808b0b:	ff 75 08             	pushl  0x8(%ebp)
  808b0e:	e8 17 bd ff ff       	call   80482a <pbuf_free>
        goto end;
  808b13:	83 c4 10             	add    $0x10,%esp
  808b16:	e9 ca 00 00 00       	jmp    808be5 <udp_input+0x33b>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b1b:	83 ec 08             	sub    $0x8,%esp
  808b1e:	ff 75 0c             	pushl  0xc(%ebp)
  808b21:	8d 47 10             	lea    0x10(%edi),%eax
  808b24:	50                   	push   %eax
  808b25:	e8 a9 d9 ff ff       	call   8064d3 <ip_addr_isbroadcast>
  808b2a:	83 c4 10             	add    $0x10,%esp
  808b2d:	84 c0                	test   %al,%al
  808b2f:	75 7d                	jne    808bae <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808b31:	8b 5f 10             	mov    0x10(%edi),%ebx
  808b34:	83 ec 0c             	sub    $0xc,%esp
  808b37:	68 00 00 00 f0       	push   $0xf0000000
  808b3c:	e8 d5 ed ff ff       	call   807916 <ntohl>
  808b41:	21 c3                	and    %eax,%ebx
  808b43:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808b4a:	e8 c7 ed ff ff       	call   807916 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b4f:	83 c4 10             	add    $0x10,%esp
  808b52:	39 c3                	cmp    %eax,%ebx
  808b54:	74 58                	je     808bae <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808b56:	83 ec 0c             	sub    $0xc,%esp
  808b59:	0f b7 07             	movzwl (%edi),%eax
  808b5c:	50                   	push   %eax
  808b5d:	e8 86 eb ff ff       	call   8076e8 <ntohs>
  808b62:	83 c4 08             	add    $0x8,%esp
  808b65:	66 c1 e8 08          	shr    $0x8,%ax
  808b69:	83 e0 0f             	and    $0xf,%eax
  808b6c:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b73:	50                   	push   %eax
  808b74:	ff 75 08             	pushl  0x8(%ebp)
  808b77:	e8 dc bb ff ff       	call   804758 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b7c:	83 c4 10             	add    $0x10,%esp
  808b7f:	8b 45 08             	mov    0x8(%ebp),%eax
  808b82:	3b 78 04             	cmp    0x4(%eax),%edi
  808b85:	74 17                	je     808b9e <udp_input+0x2f4>
  808b87:	83 ec 04             	sub    $0x4,%esp
  808b8a:	68 46 21 81 00       	push   $0x812146
  808b8f:	68 25 01 00 00       	push   $0x125
  808b94:	68 32 21 81 00       	push   $0x812132
  808b99:	e8 ac 58 00 00       	call   80e44a <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808b9e:	83 ec 08             	sub    $0x8,%esp
  808ba1:	6a 03                	push   $0x3
  808ba3:	ff 75 08             	pushl  0x8(%ebp)
  808ba6:	e8 81 56 00 00       	call   80e22c <icmp_dest_unreach>
  808bab:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  808bae:	83 ec 0c             	sub    $0xc,%esp
  808bb1:	ff 75 08             	pushl  0x8(%ebp)
  808bb4:	e8 71 bc ff ff       	call   80482a <pbuf_free>
  808bb9:	83 c4 10             	add    $0x10,%esp
  808bbc:	eb 27                	jmp    808be5 <udp_input+0x33b>
    }
  } else {
    pbuf_free(p);
  808bbe:	83 ec 0c             	sub    $0xc,%esp
  808bc1:	ff 75 08             	pushl  0x8(%ebp)
  808bc4:	e8 61 bc ff ff       	call   80482a <pbuf_free>
  808bc9:	83 c4 10             	add    $0x10,%esp
  }
end:
  PERF_STOP("udp_input");
}
  808bcc:	eb 17                	jmp    808be5 <udp_input+0x33b>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  808bce:	66 3b 7b 14          	cmp    0x14(%ebx),%di
  808bd2:	0f 85 6b fe ff ff    	jne    808a43 <udp_input+0x199>
  808bd8:	e9 2b fe ff ff       	jmp    808a08 <udp_input+0x15e>
  808bdd:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  808be0:	e9 8b fe ff ff       	jmp    808a70 <udp_input+0x1c6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808be5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808be8:	5b                   	pop    %ebx
  808be9:	5e                   	pop    %esi
  808bea:	5f                   	pop    %edi
  808beb:	5d                   	pop    %ebp
  808bec:	c3                   	ret    

00808bed <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808bed:	55                   	push   %ebp
  808bee:	89 e5                	mov    %esp,%ebp
  808bf0:	57                   	push   %edi
  808bf1:	56                   	push   %esi
  808bf2:	53                   	push   %ebx
  808bf3:	83 ec 0c             	sub    $0xc,%esp
  808bf6:	8b 55 08             	mov    0x8(%ebp),%edx
  808bf9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808bfc:	8b 75 10             	mov    0x10(%ebp),%esi
  808bff:	89 f1                	mov    %esi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c01:	a1 54 b2 b3 00       	mov    0xb3b254,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  808c06:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c0b:	eb 27                	jmp    808c34 <udp_bind+0x47>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  808c0d:	39 d0                	cmp    %edx,%eax
  808c0f:	75 20                	jne    808c31 <udp_bind+0x44>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c11:	84 db                	test   %bl,%bl
  808c13:	74 17                	je     808c2c <udp_bind+0x3f>
  808c15:	83 ec 04             	sub    $0x4,%esp
  808c18:	68 5a 21 81 00       	push   $0x81215a
  808c1d:	68 41 02 00 00       	push   $0x241
  808c22:	68 32 21 81 00       	push   $0x812132
  808c27:	e8 1e 58 00 00       	call   80e44a <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  808c2c:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c31:	8b 40 0c             	mov    0xc(%eax),%eax
  808c34:	85 c0                	test   %eax,%eax
  808c36:	75 d5                	jne    808c0d <udp_bind+0x20>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808c38:	85 ff                	test   %edi,%edi
  808c3a:	74 04                	je     808c40 <udp_bind+0x53>
  808c3c:	8b 07                	mov    (%edi),%eax
  808c3e:	eb 05                	jmp    808c45 <udp_bind+0x58>
  808c40:	b8 00 00 00 00       	mov    $0x0,%eax
  808c45:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808c47:	66 85 f6             	test   %si,%si
  808c4a:	75 2e                	jne    808c7a <udp_bind+0x8d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808c4c:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808c52:	89 f0                	mov    %esi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  808c54:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c59:	eb 10                	jmp    808c6b <udp_bind+0x7e>
      if (ipcb->local_port == port) {
  808c5b:	66 3b 48 12          	cmp    0x12(%eax),%cx
  808c5f:	75 07                	jne    808c68 <udp_bind+0x7b>
        /* port is already used by another udp_pcb */
        port++;
  808c61:	83 c1 01             	add    $0x1,%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808c64:	89 f0                	mov    %esi,%eax
  808c66:	eb 03                	jmp    808c6b <udp_bind+0x7e>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808c68:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c6b:	85 c0                	test   %eax,%eax
  808c6d:	74 07                	je     808c76 <udp_bind+0x89>
  808c6f:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808c74:	75 e5                	jne    808c5b <udp_bind+0x6e>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  808c76:	85 c0                	test   %eax,%eax
  808c78:	75 22                	jne    808c9c <udp_bind+0xaf>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808c7a:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c7e:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  808c83:	84 db                	test   %bl,%bl
  808c85:	75 1a                	jne    808ca1 <udp_bind+0xb4>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  808c87:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808c8c:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808c8f:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c95:	b8 00 00 00 00       	mov    $0x0,%eax
  808c9a:	eb 05                	jmp    808ca1 <udp_bind+0xb4>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  808c9c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  808ca1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ca4:	5b                   	pop    %ebx
  808ca5:	5e                   	pop    %esi
  808ca6:	5f                   	pop    %edi
  808ca7:	5d                   	pop    %ebp
  808ca8:	c3                   	ret    

00808ca9 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  808ca9:	55                   	push   %ebp
  808caa:	89 e5                	mov    %esp,%ebp
  808cac:	57                   	push   %edi
  808cad:	56                   	push   %esi
  808cae:	53                   	push   %ebx
  808caf:	83 ec 1c             	sub    $0x1c,%esp
  808cb2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808cb5:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  808cb8:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808cbd:	75 17                	jne    808cd6 <udp_sendto_if+0x2d>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808cbf:	83 ec 04             	sub    $0x4,%esp
  808cc2:	6a 00                	push   $0x0
  808cc4:	53                   	push   %ebx
  808cc5:	53                   	push   %ebx
  808cc6:	e8 22 ff ff ff       	call   808bed <udp_bind>
    if (err != ERR_OK) {
  808ccb:	83 c4 10             	add    $0x10,%esp
  808cce:	84 c0                	test   %al,%al
  808cd0:	0f 85 54 01 00 00    	jne    808e2a <udp_sendto_if+0x181>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808cd6:	83 ec 08             	sub    $0x8,%esp
  808cd9:	6a 08                	push   $0x8
  808cdb:	ff 75 0c             	pushl  0xc(%ebp)
  808cde:	e8 75 ba ff ff       	call   804758 <pbuf_header>
  808ce3:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  808ce6:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808ce9:	84 c0                	test   %al,%al
  808ceb:	74 2a                	je     808d17 <udp_sendto_if+0x6e>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808ced:	83 ec 04             	sub    $0x4,%esp
  808cf0:	6a 00                	push   $0x0
  808cf2:	6a 08                	push   $0x8
  808cf4:	6a 01                	push   $0x1
  808cf6:	e8 f5 bb ff ff       	call   8048f0 <pbuf_alloc>
  808cfb:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  808cfd:	83 c4 10             	add    $0x10,%esp
  808d00:	85 c0                	test   %eax,%eax
  808d02:	0f 84 1d 01 00 00    	je     808e25 <udp_sendto_if+0x17c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  808d08:	83 ec 08             	sub    $0x8,%esp
  808d0b:	ff 75 0c             	pushl  0xc(%ebp)
  808d0e:	50                   	push   %eax
  808d0f:	e8 0a c0 ff ff       	call   804d1e <pbuf_chain>
  808d14:	83 c4 10             	add    $0x10,%esp
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808d17:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  808d1c:	77 17                	ja     808d35 <udp_sendto_if+0x8c>
  808d1e:	83 ec 04             	sub    $0x4,%esp
  808d21:	68 68 21 81 00       	push   $0x812168
  808d26:	68 b2 01 00 00       	push   $0x1b2
  808d2b:	68 32 21 81 00       	push   $0x812132
  808d30:	e8 15 57 00 00       	call   80e44a <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  808d35:	8b 46 04             	mov    0x4(%esi),%eax
  808d38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  808d3b:	83 ec 0c             	sub    $0xc,%esp
  808d3e:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  808d42:	50                   	push   %eax
  808d43:	e8 93 e9 ff ff       	call   8076db <htons>
  808d48:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808d4b:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  808d4e:	0f b7 ff             	movzwl %di,%edi
  808d51:	89 3c 24             	mov    %edi,(%esp)
  808d54:	e8 82 e9 ff ff       	call   8076db <htons>
  808d59:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808d5c:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  808d60:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  808d66:	89 df                	mov    %ebx,%edi
  808d68:	83 c4 10             	add    $0x10,%esp
  808d6b:	85 db                	test   %ebx,%ebx
  808d6d:	74 06                	je     808d75 <udp_sendto_if+0xcc>
  808d6f:	8b 03                	mov    (%ebx),%eax
  808d71:	85 c0                	test   %eax,%eax
  808d73:	75 08                	jne    808d7d <udp_sendto_if+0xd4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  808d75:	8b 45 18             	mov    0x18(%ebp),%eax
  808d78:	8d 78 04             	lea    0x4(%eax),%edi
  808d7b:	eb 2c                	jmp    808da9 <udp_sendto_if+0x100>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808d7d:	8b 55 18             	mov    0x18(%ebp),%edx
  808d80:	3b 42 04             	cmp    0x4(%edx),%eax
  808d83:	74 24                	je     808da9 <udp_sendto_if+0x100>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808d85:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  808d8a:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808d8d:	0f 84 97 00 00 00    	je     808e2a <udp_sendto_if+0x181>
        /* free the header pbuf */
        pbuf_free(q);
  808d93:	83 ec 0c             	sub    $0xc,%esp
  808d96:	56                   	push   %esi
  808d97:	e8 8e ba ff ff       	call   80482a <pbuf_free>
  808d9c:	83 c4 10             	add    $0x10,%esp
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808d9f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  808da4:	e9 81 00 00 00       	jmp    808e2a <udp_sendto_if+0x181>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  808da9:	83 ec 0c             	sub    $0xc,%esp
  808dac:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808db0:	50                   	push   %eax
  808db1:	e8 25 e9 ff ff       	call   8076db <htons>
  808db6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808db9:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808dbd:	83 c4 10             	add    $0x10,%esp
  808dc0:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  808dc4:	75 29                	jne    808def <udp_sendto_if+0x146>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808dc6:	83 ec 0c             	sub    $0xc,%esp
  808dc9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808dcd:	50                   	push   %eax
  808dce:	6a 11                	push   $0x11
  808dd0:	ff 75 10             	pushl  0x10(%ebp)
  808dd3:	57                   	push   %edi
  808dd4:	56                   	push   %esi
  808dd5:	e8 e8 e5 ff ff       	call   8073c2 <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808dda:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808ddd:	66 85 c0             	test   %ax,%ax
  808de0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808de5:	0f 44 c2             	cmove  %edx,%eax
  808de8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808deb:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808def:	83 ec 04             	sub    $0x4,%esp
  808df2:	ff 75 18             	pushl  0x18(%ebp)
  808df5:	6a 11                	push   $0x11
  808df7:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808dfb:	50                   	push   %eax
  808dfc:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808e00:	50                   	push   %eax
  808e01:	ff 75 10             	pushl  0x10(%ebp)
  808e04:	57                   	push   %edi
  808e05:	56                   	push   %esi
  808e06:	e8 76 da ff ff       	call   806881 <ip_output_if>
  808e0b:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  808e0d:	83 c4 20             	add    $0x20,%esp
  808e10:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808e13:	74 15                	je     808e2a <udp_sendto_if+0x181>
    /* free the header pbuf */
    pbuf_free(q);
  808e15:	83 ec 0c             	sub    $0xc,%esp
  808e18:	56                   	push   %esi
  808e19:	e8 0c ba ff ff       	call   80482a <pbuf_free>
  808e1e:	83 c4 10             	add    $0x10,%esp
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  808e21:	89 d8                	mov    %ebx,%eax
  808e23:	eb 05                	jmp    808e2a <udp_sendto_if+0x181>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  808e25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  808e2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808e2d:	5b                   	pop    %ebx
  808e2e:	5e                   	pop    %esi
  808e2f:	5f                   	pop    %edi
  808e30:	5d                   	pop    %ebp
  808e31:	c3                   	ret    

00808e32 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  808e32:	55                   	push   %ebp
  808e33:	89 e5                	mov    %esp,%ebp
  808e35:	56                   	push   %esi
  808e36:	53                   	push   %ebx
  808e37:	8b 75 10             	mov    0x10(%ebp),%esi
  808e3a:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  808e3d:	83 ec 0c             	sub    $0xc,%esp
  808e40:	56                   	push   %esi
  808e41:	e8 d9 d6 ff ff       	call   80651f <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  808e46:	83 c4 10             	add    $0x10,%esp
  808e49:	85 c0                	test   %eax,%eax
  808e4b:	74 19                	je     808e66 <udp_sendto+0x34>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808e4d:	83 ec 0c             	sub    $0xc,%esp
  808e50:	50                   	push   %eax
  808e51:	0f b7 db             	movzwl %bx,%ebx
  808e54:	53                   	push   %ebx
  808e55:	56                   	push   %esi
  808e56:	ff 75 0c             	pushl  0xc(%ebp)
  808e59:	ff 75 08             	pushl  0x8(%ebp)
  808e5c:	e8 48 fe ff ff       	call   808ca9 <udp_sendto_if>
  808e61:	83 c4 20             	add    $0x20,%esp
  808e64:	eb 05                	jmp    808e6b <udp_sendto+0x39>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  808e66:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  808e6b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808e6e:	5b                   	pop    %ebx
  808e6f:	5e                   	pop    %esi
  808e70:	5d                   	pop    %ebp
  808e71:	c3                   	ret    

00808e72 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  808e72:	55                   	push   %ebp
  808e73:	89 e5                	mov    %esp,%ebp
  808e75:	83 ec 08             	sub    $0x8,%esp
  808e78:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808e7b:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808e7f:	52                   	push   %edx
  808e80:	8d 50 04             	lea    0x4(%eax),%edx
  808e83:	52                   	push   %edx
  808e84:	ff 75 0c             	pushl  0xc(%ebp)
  808e87:	50                   	push   %eax
  808e88:	e8 a5 ff ff ff       	call   808e32 <udp_sendto>
}
  808e8d:	c9                   	leave  
  808e8e:	c3                   	ret    

00808e8f <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808e8f:	55                   	push   %ebp
  808e90:	89 e5                	mov    %esp,%ebp
  808e92:	57                   	push   %edi
  808e93:	56                   	push   %esi
  808e94:	53                   	push   %ebx
  808e95:	83 ec 0c             	sub    $0xc,%esp
  808e98:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808e9b:	8b 75 0c             	mov    0xc(%ebp),%esi
  808e9e:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808ea1:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808ea6:	75 13                	jne    808ebb <udp_connect+0x2c>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808ea8:	83 ec 04             	sub    $0x4,%esp
  808eab:	6a 00                	push   $0x0
  808ead:	53                   	push   %ebx
  808eae:	53                   	push   %ebx
  808eaf:	e8 39 fd ff ff       	call   808bed <udp_bind>
    if (err != ERR_OK)
  808eb4:	83 c4 10             	add    $0x10,%esp
  808eb7:	84 c0                	test   %al,%al
  808eb9:	75 3d                	jne    808ef8 <udp_connect+0x69>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808ebb:	85 f6                	test   %esi,%esi
  808ebd:	74 04                	je     808ec3 <udp_connect+0x34>
  808ebf:	8b 06                	mov    (%esi),%eax
  808ec1:	eb 05                	jmp    808ec8 <udp_connect+0x39>
  808ec3:	b8 00 00 00 00       	mov    $0x0,%eax
  808ec8:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808ecb:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808ecf:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ed3:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808ed9:	89 d0                	mov    %edx,%eax
  808edb:	eb 07                	jmp    808ee4 <udp_connect+0x55>
    if (pcb == ipcb) {
  808edd:	39 d8                	cmp    %ebx,%eax
  808edf:	74 12                	je     808ef3 <udp_connect+0x64>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ee1:	8b 40 0c             	mov    0xc(%eax),%eax
  808ee4:	85 c0                	test   %eax,%eax
  808ee6:	75 f5                	jne    808edd <udp_connect+0x4e>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808ee8:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808eeb:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
  808ef1:	eb 05                	jmp    808ef8 <udp_connect+0x69>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  808ef3:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  808ef8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808efb:	5b                   	pop    %ebx
  808efc:	5e                   	pop    %esi
  808efd:	5f                   	pop    %edi
  808efe:	5d                   	pop    %ebp
  808eff:	c3                   	ret    

00808f00 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808f00:	55                   	push   %ebp
  808f01:	89 e5                	mov    %esp,%ebp
  808f03:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808f06:	8b 15 a4 1d 81 00    	mov    0x811da4,%edx
  808f0c:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808f0f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808f15:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808f19:	5d                   	pop    %ebp
  808f1a:	c3                   	ret    

00808f1b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808f1b:	55                   	push   %ebp
  808f1c:	89 e5                	mov    %esp,%ebp
  808f1e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808f21:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f24:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808f27:	8b 55 10             	mov    0x10(%ebp),%edx
  808f2a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808f2d:	5d                   	pop    %ebp
  808f2e:	c3                   	ret    

00808f2f <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808f2f:	55                   	push   %ebp
  808f30:	89 e5                	mov    %esp,%ebp
  808f32:	83 ec 08             	sub    $0x8,%esp
  808f35:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808f38:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808f3d:	39 c8                	cmp    %ecx,%eax
  808f3f:	75 1e                	jne    808f5f <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808f41:	8b 40 0c             	mov    0xc(%eax),%eax
  808f44:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
  808f49:	eb 18                	jmp    808f63 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808f4b:	8b 50 0c             	mov    0xc(%eax),%edx
  808f4e:	39 d1                	cmp    %edx,%ecx
  808f50:	75 0a                	jne    808f5c <udp_remove+0x2d>
  808f52:	85 d2                	test   %edx,%edx
  808f54:	74 06                	je     808f5c <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  808f56:	8b 51 0c             	mov    0xc(%ecx),%edx
  808f59:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808f5c:	8b 40 0c             	mov    0xc(%eax),%eax
  808f5f:	85 c0                	test   %eax,%eax
  808f61:	75 e8                	jne    808f4b <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808f63:	83 ec 08             	sub    $0x8,%esp
  808f66:	51                   	push   %ecx
  808f67:	6a 01                	push   $0x1
  808f69:	e8 49 b5 ff ff       	call   8044b7 <memp_free>
}
  808f6e:	83 c4 10             	add    $0x10,%esp
  808f71:	c9                   	leave  
  808f72:	c3                   	ret    

00808f73 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808f73:	55                   	push   %ebp
  808f74:	89 e5                	mov    %esp,%ebp
  808f76:	53                   	push   %ebx
  808f77:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808f7a:	6a 01                	push   $0x1
  808f7c:	e8 e0 b4 ff ff       	call   804461 <memp_malloc>
  808f81:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808f83:	83 c4 10             	add    $0x10,%esp
  808f86:	85 c0                	test   %eax,%eax
  808f88:	74 14                	je     808f9e <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808f8a:	83 ec 04             	sub    $0x4,%esp
  808f8d:	6a 20                	push   $0x20
  808f8f:	6a 00                	push   $0x0
  808f91:	50                   	push   %eax
  808f92:	e8 56 5c 00 00       	call   80ebed <memset>
    pcb->ttl = UDP_TTL;
  808f97:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808f9b:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808f9e:	89 d8                	mov    %ebx,%eax
  808fa0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808fa3:	c9                   	leave  
  808fa4:	c3                   	ret    

00808fa5 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808fa5:	55                   	push   %ebp
  808fa6:	89 e5                	mov    %esp,%ebp
  808fa8:	56                   	push   %esi
  808fa9:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808faa:	85 c0                	test   %eax,%eax
  808fac:	75 17                	jne    808fc5 <free_etharp_q+0x20>
  808fae:	83 ec 04             	sub    $0x4,%esp
  808fb1:	68 a8 18 81 00       	push   $0x8118a8
  808fb6:	68 93 00 00 00       	push   $0x93
  808fbb:	68 96 21 81 00       	push   $0x812196
  808fc0:	e8 85 54 00 00       	call   80e44a <_panic>
  808fc5:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808fc7:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808fcb:	75 17                	jne    808fe4 <free_etharp_q+0x3f>
  808fcd:	83 ec 04             	sub    $0x4,%esp
  808fd0:	68 ae 21 81 00       	push   $0x8121ae
  808fd5:	68 94 00 00 00       	push   $0x94
  808fda:	68 96 21 81 00       	push   $0x812196
  808fdf:	e8 66 54 00 00       	call   80e44a <_panic>
  while (q) {
    r = q;
    q = q->next;
  808fe4:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808fe6:	8b 43 04             	mov    0x4(%ebx),%eax
  808fe9:	85 c0                	test   %eax,%eax
  808feb:	75 17                	jne    809004 <free_etharp_q+0x5f>
  808fed:	83 ec 04             	sub    $0x4,%esp
  808ff0:	68 bb 21 81 00       	push   $0x8121bb
  808ff5:	68 98 00 00 00       	push   $0x98
  808ffa:	68 96 21 81 00       	push   $0x812196
  808fff:	e8 46 54 00 00       	call   80e44a <_panic>
    pbuf_free(r->p);
  809004:	83 ec 0c             	sub    $0xc,%esp
  809007:	50                   	push   %eax
  809008:	e8 1d b8 ff ff       	call   80482a <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80900d:	83 c4 08             	add    $0x8,%esp
  809010:	53                   	push   %ebx
  809011:	6a 0a                	push   $0xa
  809013:	e8 9f b4 ff ff       	call   8044b7 <memp_free>
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
  809018:	89 f3                	mov    %esi,%ebx
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80901a:	83 c4 10             	add    $0x10,%esp
  80901d:	85 f6                	test   %esi,%esi
  80901f:	75 c3                	jne    808fe4 <free_etharp_q+0x3f>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  809021:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809024:	5b                   	pop    %ebx
  809025:	5e                   	pop    %esi
  809026:	5d                   	pop    %ebp
  809027:	c3                   	ret    

00809028 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809028:	55                   	push   %ebp
  809029:	89 e5                	mov    %esp,%ebp
  80902b:	57                   	push   %edi
  80902c:	56                   	push   %esi
  80902d:	53                   	push   %ebx
  80902e:	83 ec 1c             	sub    $0x1c,%esp
  809031:	89 d7                	mov    %edx,%edi
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809033:	85 c0                	test   %eax,%eax
  809035:	74 2e                	je     809065 <find_entry+0x3d>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809037:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  80903e:	0f b6 ca             	movzbl %dl,%ecx
  809041:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  809044:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  80904b:	75 37                	jne    809084 <find_entry+0x5c>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80904d:	8b 8b 24 4a b3 00    	mov    0xb34a24(%ebx),%ecx
  809053:	39 08                	cmp    %ecx,(%eax)
  809055:	75 4c                	jne    8090a3 <find_entry+0x7b>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809057:	89 d0                	mov    %edx,%eax
  809059:	e9 22 02 00 00       	jmp    809280 <find_entry+0x258>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80905e:	80 f9 0a             	cmp    $0xa,%cl
  809061:	75 78                	jne    8090db <find_entry+0xb3>
  809063:	eb 5b                	jmp    8090c0 <find_entry+0x98>
  809065:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809069:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  80906d:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809071:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809075:	ba 00 00 00 00       	mov    $0x0,%edx
  80907a:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80907e:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809082:	eb 3c                	jmp    8090c0 <find_entry+0x98>
  809084:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809088:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  80908c:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809090:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809094:	ba 00 00 00 00       	mov    $0x0,%edx
  809099:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80909d:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8090a1:	eb 1d                	jmp    8090c0 <find_entry+0x98>
  8090a3:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8090a7:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  8090ab:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8090af:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  8090b3:	ba 00 00 00 00       	mov    $0x0,%edx
  8090b8:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8090bc:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8090c0:	0f b6 ca             	movzbl %dl,%ecx
  8090c3:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8090c6:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  8090cd:	75 07                	jne    8090d6 <find_entry+0xae>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8090cf:	89 d1                	mov    %edx,%ecx
  8090d1:	e9 a3 00 00 00       	jmp    809179 <find_entry+0x151>
  8090d6:	b9 0a 00 00 00       	mov    $0xa,%ecx
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8090db:	0f b6 da             	movzbl %dl,%ebx
  8090de:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090e1:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  8090e7:	83 fe 01             	cmp    $0x1,%esi
  8090ea:	75 55                	jne    809141 <find_entry+0x119>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8090ec:	85 c0                	test   %eax,%eax
  8090ee:	74 1a                	je     80910a <find_entry+0xe2>
  8090f0:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090f3:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  8090f9:	39 30                	cmp    %esi,(%eax)
  8090fb:	75 0d                	jne    80910a <find_entry+0xe2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8090fd:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809103:	89 d0                	mov    %edx,%eax
  809105:	e9 76 01 00 00       	jmp    809280 <find_entry+0x258>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80910a:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80910d:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  809114:	74 14                	je     80912a <find_entry+0x102>
        if (arp_table[i].ctime >= age_queue) {
  809116:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  80911d:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  809120:	72 57                	jb     809179 <find_entry+0x151>
          old_queue = i;
  809122:	88 55 e4             	mov    %dl,-0x1c(%ebp)
          age_queue = arp_table[i].ctime;
  809125:	88 5d e7             	mov    %bl,-0x19(%ebp)
  809128:	eb 4f                	jmp    809179 <find_entry+0x151>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80912a:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80912d:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  809134:	3a 5d e3             	cmp    -0x1d(%ebp),%bl
  809137:	72 40                	jb     809179 <find_entry+0x151>
          old_pending = i;
  809139:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  80913c:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  80913f:	eb 38                	jmp    809179 <find_entry+0x151>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809141:	83 fe 02             	cmp    $0x2,%esi
  809144:	75 33                	jne    809179 <find_entry+0x151>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809146:	85 c0                	test   %eax,%eax
  809148:	74 1a                	je     809164 <find_entry+0x13c>
  80914a:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80914d:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  809153:	39 30                	cmp    %esi,(%eax)
  809155:	75 0d                	jne    809164 <find_entry+0x13c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809157:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80915d:	89 d0                	mov    %edx,%eax
  80915f:	e9 1c 01 00 00       	jmp    809280 <find_entry+0x258>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809164:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809167:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  80916e:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  809171:	72 06                	jb     809179 <find_entry+0x151>
        old_stable = i;
  809173:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809176:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809179:	83 c2 01             	add    $0x1,%edx
  80917c:	80 fa 09             	cmp    $0x9,%dl
  80917f:	0f 86 d9 fe ff ff    	jbe    80905e <find_entry+0x36>
  809185:	89 fa                	mov    %edi,%edx
  809187:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809189:	80 f9 0a             	cmp    $0xa,%cl
  80918c:	75 0e                	jne    80919c <find_entry+0x174>
  80918e:	f6 c2 01             	test   $0x1,%dl
  809191:	0f 85 de 00 00 00    	jne    809275 <find_entry+0x24d>
  809197:	e9 bd 00 00 00       	jmp    809259 <find_entry+0x231>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80919c:	f6 c2 02             	test   $0x2,%dl
  80919f:	0f 85 bb 00 00 00    	jne    809260 <find_entry+0x238>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8091a5:	89 ce                	mov    %ecx,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8091a7:	80 f9 09             	cmp    $0x9,%cl
  8091aa:	7e 5f                	jle    80920b <find_entry+0x1e3>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  8091ac:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  8091b0:	3c 09                	cmp    $0x9,%al
  8091b2:	7f 28                	jg     8091dc <find_entry+0x1b4>
    /* recycle oldest stable*/
    i = old_stable;
  8091b4:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  8091b6:	0f b6 c0             	movzbl %al,%eax
  8091b9:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8091bc:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  8091c3:	74 46                	je     80920b <find_entry+0x1e3>
  8091c5:	83 ec 04             	sub    $0x4,%esp
  8091c8:	68 c8 21 81 00       	push   $0x8121c8
  8091cd:	68 75 01 00 00       	push   $0x175
  8091d2:	68 96 21 81 00       	push   $0x812196
  8091d7:	e8 6e 52 00 00       	call   80e44a <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8091dc:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    /* recycle oldest pending */
    i = old_pending;
  8091e0:	89 c6                	mov    %eax,%esi
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8091e2:	3c 09                	cmp    $0x9,%al
  8091e4:	7e 25                	jle    80920b <find_entry+0x1e3>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  8091e6:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8091ea:	3c 09                	cmp    $0x9,%al
  8091ec:	7f 79                	jg     809267 <find_entry+0x23f>
    /* recycle oldest pending */
    i = old_queue;
  8091ee:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8091f0:	0f b6 f8             	movzbl %al,%edi
  8091f3:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8091f6:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  8091fc:	e8 a4 fd ff ff       	call   808fa5 <free_etharp_q>
    arp_table[i].q = NULL;
  809201:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  809208:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80920b:	89 f0                	mov    %esi,%eax
  80920d:	3c 09                	cmp    $0x9,%al
  80920f:	76 17                	jbe    809228 <find_entry+0x200>
  809211:	83 ec 04             	sub    $0x4,%esp
  809214:	68 df 21 81 00       	push   $0x8121df
  809219:	68 8b 01 00 00       	push   $0x18b
  80921e:	68 96 21 81 00       	push   $0x812196
  809223:	e8 22 52 00 00       	call   80e44a <_panic>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809228:	89 f0                	mov    %esi,%eax
  80922a:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80922d:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809230:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809237:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80923a:	85 db                	test   %ebx,%ebx
  80923c:	74 08                	je     809246 <find_entry+0x21e>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80923e:	8b 0b                	mov    (%ebx),%ecx
  809240:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809246:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809249:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809250:	89 f0                	mov    %esi,%eax
  809252:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809257:	eb 27                	jmp    809280 <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809259:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80925e:	eb 20                	jmp    809280 <find_entry+0x258>
  809260:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809265:	eb 19                	jmp    809280 <find_entry+0x258>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809267:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80926c:	eb 12                	jmp    809280 <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  80926e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809273:	eb 0b                	jmp    809280 <find_entry+0x258>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809275:	f6 c2 02             	test   $0x2,%dl
  809278:	0f 84 2e ff ff ff    	je     8091ac <find_entry+0x184>
  80927e:	eb ee                	jmp    80926e <find_entry+0x246>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809280:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809283:	5b                   	pop    %ebx
  809284:	5e                   	pop    %esi
  809285:	5f                   	pop    %edi
  809286:	5d                   	pop    %ebp
  809287:	c3                   	ret    

00809288 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809288:	55                   	push   %ebp
  809289:	89 e5                	mov    %esp,%ebp
  80928b:	57                   	push   %edi
  80928c:	56                   	push   %esi
  80928d:	53                   	push   %ebx
  80928e:	83 ec 1c             	sub    $0x1c,%esp
  809291:	89 c6                	mov    %eax,%esi
  809293:	89 55 e0             	mov    %edx,-0x20(%ebp)
  809296:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809299:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80929c:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8092a0:	74 17                	je     8092b9 <etharp_send_ip+0x31>
  8092a2:	83 ec 04             	sub    $0x4,%esp
  8092a5:	68 0c 22 81 00       	push   $0x81220c
  8092aa:	68 b3 01 00 00       	push   $0x1b3
  8092af:	68 96 21 81 00       	push   $0x812196
  8092b4:	e8 91 51 00 00       	call   80e44a <_panic>
  8092b9:	ba 06 00 00 00       	mov    $0x6,%edx
  8092be:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  8092c1:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  8092c4:	0f b6 c2             	movzbl %dl,%eax
  8092c7:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  8092cb:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8092ce:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8092d1:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8092d5:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  8092d9:	84 d2                	test   %dl,%dl
  8092db:	75 e4                	jne    8092c1 <etharp_send_ip+0x39>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8092dd:	83 ec 0c             	sub    $0xc,%esp
  8092e0:	68 00 08 00 00       	push   $0x800
  8092e5:	e8 f1 e3 ff ff       	call   8076db <htons>
  8092ea:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8092ee:	83 c4 08             	add    $0x8,%esp
  8092f1:	ff 75 e0             	pushl  -0x20(%ebp)
  8092f4:	56                   	push   %esi
  8092f5:	ff 56 18             	call   *0x18(%esi)
}
  8092f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8092fb:	5b                   	pop    %ebx
  8092fc:	5e                   	pop    %esi
  8092fd:	5f                   	pop    %edi
  8092fe:	5d                   	pop    %ebp
  8092ff:	c3                   	ret    

00809300 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809300:	55                   	push   %ebp
  809301:	89 e5                	mov    %esp,%ebp
  809303:	57                   	push   %edi
  809304:	56                   	push   %esi
  809305:	53                   	push   %ebx
  809306:	83 ec 1c             	sub    $0x1c,%esp
  809309:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80930c:	89 cb                	mov    %ecx,%ebx
  80930e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809311:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809314:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809318:	74 17                	je     809331 <update_arp_entry+0x31>
  80931a:	83 ec 04             	sub    $0x4,%esp
  80931d:	68 50 22 81 00       	push   $0x812250
  809322:	68 d9 01 00 00       	push   $0x1d9
  809327:	68 96 21 81 00       	push   $0x812196
  80932c:	e8 19 51 00 00       	call   80e44a <_panic>
  809331:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809333:	85 d2                	test   %edx,%edx
  809335:	0f 84 ed 00 00 00    	je     809428 <update_arp_entry+0x128>
  80933b:	83 3a 00             	cmpl   $0x0,(%edx)
  80933e:	0f 84 eb 00 00 00    	je     80942f <update_arp_entry+0x12f>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809344:	83 ec 08             	sub    $0x8,%esp
  809347:	ff 75 e4             	pushl  -0x1c(%ebp)
  80934a:	52                   	push   %edx
  80934b:	e8 83 d1 ff ff       	call   8064d3 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809350:	83 c4 10             	add    $0x10,%esp
  809353:	84 c0                	test   %al,%al
  809355:	0f 85 db 00 00 00    	jne    809436 <update_arp_entry+0x136>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80935b:	8b 3e                	mov    (%esi),%edi
  80935d:	83 ec 0c             	sub    $0xc,%esp
  809360:	68 00 00 00 f0       	push   $0xf0000000
  809365:	e8 ac e5 ff ff       	call   807916 <ntohl>
  80936a:	21 c7                	and    %eax,%edi
  80936c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809373:	e8 9e e5 ff ff       	call   807916 <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809378:	83 c4 10             	add    $0x10,%esp
  80937b:	39 c7                	cmp    %eax,%edi
  80937d:	0f 84 ba 00 00 00    	je     80943d <update_arp_entry+0x13d>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809383:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809387:	89 f0                	mov    %esi,%eax
  809389:	e8 9a fc ff ff       	call   809028 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80938e:	84 c0                	test   %al,%al
  809390:	0f 88 ac 00 00 00    	js     809442 <update_arp_entry+0x142>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809396:	0f be f0             	movsbl %al,%esi
  809399:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80939c:	c7 80 30 4a b3 00 02 	movl   $0x2,0xb34a30(%eax)
  8093a3:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8093a6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8093a9:	89 88 38 4a b3 00    	mov    %ecx,0xb34a38(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8093af:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8093b4:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8093b7:	05 20 4a b3 00       	add    $0xb34a20,%eax
  8093bc:	89 d7                	mov    %edx,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  8093be:	83 ef 01             	sub    $0x1,%edi
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8093c1:	89 f9                	mov    %edi,%ecx
  8093c3:	0f b6 c9             	movzbl %cl,%ecx
  8093c6:	0f b6 14 0b          	movzbl (%ebx,%ecx,1),%edx
  8093ca:	88 54 01 08          	mov    %dl,0x8(%ecx,%eax,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  8093ce:	89 f9                	mov    %edi,%ecx
  8093d0:	84 c9                	test   %cl,%cl
  8093d2:	75 ea                	jne    8093be <update_arp_entry+0xbe>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  8093d4:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8093d7:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8093de:	89 c6                	mov    %eax,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8093e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8093e3:	83 c0 25             	add    $0x25,%eax
  8093e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8093e9:	eb 31                	jmp    80941c <update_arp_entry+0x11c>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8093eb:	8b 10                	mov    (%eax),%edx
  8093ed:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    /* get the packet pointer */
    p = q->p;
  8093f3:	8b 78 04             	mov    0x4(%eax),%edi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8093f6:	83 ec 08             	sub    $0x8,%esp
  8093f9:	50                   	push   %eax
  8093fa:	6a 0a                	push   $0xa
  8093fc:	e8 b6 b0 ff ff       	call   8044b7 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809401:	89 1c 24             	mov    %ebx,(%esp)
  809404:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809407:	89 fa                	mov    %edi,%edx
  809409:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80940c:	e8 77 fe ff ff       	call   809288 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809411:	89 3c 24             	mov    %edi,(%esp)
  809414:	e8 11 b4 ff ff       	call   80482a <pbuf_free>
  809419:	83 c4 10             	add    $0x10,%esp
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80941c:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  809422:	85 c0                	test   %eax,%eax
  809424:	75 c5                	jne    8093eb <update_arp_entry+0xeb>
  809426:	eb 1a                	jmp    809442 <update_arp_entry+0x142>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809428:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80942d:	eb 13                	jmp    809442 <update_arp_entry+0x142>
  80942f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809434:	eb 0c                	jmp    809442 <update_arp_entry+0x142>
  809436:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80943b:	eb 05                	jmp    809442 <update_arp_entry+0x142>
  80943d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  809442:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809445:	5b                   	pop    %ebx
  809446:	5e                   	pop    %esi
  809447:	5f                   	pop    %edi
  809448:	5d                   	pop    %ebp
  809449:	c3                   	ret    

0080944a <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80944a:	55                   	push   %ebp
  80944b:	89 e5                	mov    %esp,%ebp
  80944d:	57                   	push   %edi
  80944e:	56                   	push   %esi
  80944f:	53                   	push   %ebx
  809450:	83 ec 0c             	sub    $0xc,%esp
  809453:	bb 34 4a b3 00       	mov    $0xb34a34,%ebx
  809458:	bf 4c 4b b3 00       	mov    $0xb34b4c,%edi
  80945d:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80945f:	0f b6 03             	movzbl (%ebx),%eax
  809462:	83 c0 01             	add    $0x1,%eax
  809465:	88 03                	mov    %al,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809467:	8b 53 fc             	mov    -0x4(%ebx),%edx
  80946a:	3c ef                	cmp    $0xef,%al
  80946c:	76 05                	jbe    809473 <etharp_tmr+0x29>
  80946e:	83 fa 02             	cmp    $0x2,%edx
  809471:	74 09                	je     80947c <etharp_tmr+0x32>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809473:	3c 01                	cmp    $0x1,%al
  809475:	76 1f                	jbe    809496 <etharp_tmr+0x4c>
  809477:	83 fa 01             	cmp    $0x1,%edx
  80947a:	75 1a                	jne    809496 <etharp_tmr+0x4c>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80947c:	8b 46 ec             	mov    -0x14(%esi),%eax
  80947f:	85 c0                	test   %eax,%eax
  809481:	74 0c                	je     80948f <etharp_tmr+0x45>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809483:	e8 1d fb ff ff       	call   808fa5 <free_etharp_q>
        arp_table[i].q = NULL;
  809488:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80948f:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809496:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809499:	39 fb                	cmp    %edi,%ebx
  80949b:	75 c0                	jne    80945d <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80949d:	83 c4 0c             	add    $0xc,%esp
  8094a0:	5b                   	pop    %ebx
  8094a1:	5e                   	pop    %esi
  8094a2:	5f                   	pop    %edi
  8094a3:	5d                   	pop    %ebp
  8094a4:	c3                   	ret    

008094a5 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8094a5:	55                   	push   %ebp
  8094a6:	89 e5                	mov    %esp,%ebp
  8094a8:	53                   	push   %ebx
  8094a9:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8094ac:	ba 02 00 00 00       	mov    $0x2,%edx
  8094b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8094b4:	e8 6f fb ff ff       	call   809028 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8094b9:	84 c0                	test   %al,%al
  8094bb:	78 29                	js     8094e6 <etharp_find_addr+0x41>
  8094bd:	0f be d0             	movsbl %al,%edx
  8094c0:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  8094c3:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  8094ca:	75 21                	jne    8094ed <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  8094cc:	89 ca                	mov    %ecx,%edx
  8094ce:	8d 99 28 4a b3 00    	lea    0xb34a28(%ecx),%ebx
  8094d4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8094d7:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  8094d9:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  8094df:	8b 4d 14             	mov    0x14(%ebp),%ecx
  8094e2:	89 11                	mov    %edx,(%ecx)
      return i;
  8094e4:	eb 0c                	jmp    8094f2 <etharp_find_addr+0x4d>
  }
  return -1;
  8094e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094eb:	eb 05                	jmp    8094f2 <etharp_find_addr+0x4d>
  8094ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8094f2:	83 c4 04             	add    $0x4,%esp
  8094f5:	5b                   	pop    %ebx
  8094f6:	5d                   	pop    %ebp
  8094f7:	c3                   	ret    

008094f8 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  8094f8:	55                   	push   %ebp
  8094f9:	89 e5                	mov    %esp,%ebp
  8094fb:	83 ec 08             	sub    $0x8,%esp
  8094fe:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809501:	85 c0                	test   %eax,%eax
  809503:	75 17                	jne    80951c <etharp_ip_input+0x24>
  809505:	83 ec 04             	sub    $0x4,%esp
  809508:	68 02 15 81 00       	push   $0x811502
  80950d:	68 48 02 00 00       	push   $0x248
  809512:	68 96 21 81 00       	push   $0x812196
  809517:	e8 2e 4f 00 00       	call   80e44a <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80951c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80951f:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809522:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809525:	33 48 04             	xor    0x4(%eax),%ecx
  809528:	85 48 08             	test   %ecx,0x8(%eax)
  80952b:	75 13                	jne    809540 <etharp_ip_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80952d:	8d 4a 06             	lea    0x6(%edx),%ecx
  809530:	83 c2 1c             	add    $0x1c,%edx
  809533:	83 ec 0c             	sub    $0xc,%esp
  809536:	6a 00                	push   $0x0
  809538:	e8 c3 fd ff ff       	call   809300 <update_arp_entry>
  80953d:	83 c4 10             	add    $0x10,%esp
}
  809540:	c9                   	leave  
  809541:	c3                   	ret    

00809542 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809542:	55                   	push   %ebp
  809543:	89 e5                	mov    %esp,%ebp
  809545:	57                   	push   %edi
  809546:	56                   	push   %esi
  809547:	53                   	push   %ebx
  809548:	83 ec 1c             	sub    $0x1c,%esp
  80954b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80954e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809552:	75 17                	jne    80956b <etharp_arp_input+0x29>
  809554:	83 ec 04             	sub    $0x4,%esp
  809557:	68 02 15 81 00       	push   $0x811502
  80955c:	68 75 02 00 00       	push   $0x275
  809561:	68 96 21 81 00       	push   $0x812196
  809566:	e8 df 4e 00 00       	call   80e44a <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80956b:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809570:	77 11                	ja     809583 <etharp_arp_input+0x41>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809572:	83 ec 0c             	sub    $0xc,%esp
  809575:	53                   	push   %ebx
  809576:	e8 af b2 ff ff       	call   80482a <pbuf_free>
    return;
  80957b:	83 c4 10             	add    $0x10,%esp
  80957e:	e9 b4 01 00 00       	jmp    809737 <etharp_arp_input+0x1f5>
  }

  hdr = p->payload;
  809583:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809586:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80958a:	83 ec 0c             	sub    $0xc,%esp
  80958d:	6a 01                	push   $0x1
  80958f:	e8 47 e1 ff ff       	call   8076db <htons>
  809594:	83 c4 10             	add    $0x10,%esp
  809597:	66 39 c7             	cmp    %ax,%di
  80959a:	75 4b                	jne    8095e7 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80959c:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8095a0:	83 ec 0c             	sub    $0xc,%esp
  8095a3:	68 04 06 00 00       	push   $0x604
  8095a8:	e8 2e e1 ff ff       	call   8076db <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8095ad:	83 c4 10             	add    $0x10,%esp
  8095b0:	66 39 c7             	cmp    %ax,%di
  8095b3:	75 32                	jne    8095e7 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8095b5:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  8095b9:	83 ec 0c             	sub    $0xc,%esp
  8095bc:	68 00 08 00 00       	push   $0x800
  8095c1:	e8 15 e1 ff ff       	call   8076db <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8095c6:	83 c4 10             	add    $0x10,%esp
  8095c9:	66 39 c7             	cmp    %ax,%di
  8095cc:	75 19                	jne    8095e7 <etharp_arp_input+0xa5>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8095ce:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  8095d2:	83 ec 0c             	sub    $0xc,%esp
  8095d5:	68 06 08 00 00       	push   $0x806
  8095da:	e8 fc e0 ff ff       	call   8076db <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8095df:	83 c4 10             	add    $0x10,%esp
  8095e2:	66 39 c7             	cmp    %ax,%di
  8095e5:	74 11                	je     8095f8 <etharp_arp_input+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8095e7:	83 ec 0c             	sub    $0xc,%esp
  8095ea:	53                   	push   %ebx
  8095eb:	e8 3a b2 ff ff       	call   80482a <pbuf_free>
    return;
  8095f0:	83 c4 10             	add    $0x10,%esp
  8095f3:	e9 3f 01 00 00       	jmp    809737 <etharp_arp_input+0x1f5>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8095f8:	83 ec 04             	sub    $0x4,%esp
  8095fb:	6a 04                	push   $0x4
  8095fd:	8d 46 1c             	lea    0x1c(%esi),%eax
  809600:	50                   	push   %eax
  809601:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809604:	50                   	push   %eax
  809605:	e8 98 56 00 00       	call   80eca2 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80960a:	83 c4 0c             	add    $0xc,%esp
  80960d:	6a 04                	push   $0x4
  80960f:	8d 46 26             	lea    0x26(%esi),%eax
  809612:	50                   	push   %eax
  809613:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809616:	50                   	push   %eax
  809617:	e8 86 56 00 00       	call   80eca2 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80961c:	8b 45 08             	mov    0x8(%ebp),%eax
  80961f:	8b 40 04             	mov    0x4(%eax),%eax
  809622:	83 c4 10             	add    $0x10,%esp
  809625:	85 c0                	test   %eax,%eax
  809627:	74 3c                	je     809665 <etharp_arp_input+0x123>
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  }

  /* ARP message directed to us? */
  if (for_us) {
  809629:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80962c:	75 37                	jne    809665 <etharp_arp_input+0x123>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80962e:	8d 4e 16             	lea    0x16(%esi),%ecx
  809631:	83 ec 0c             	sub    $0xc,%esp
  809634:	6a 01                	push   $0x1
  809636:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809639:	8b 45 08             	mov    0x8(%ebp),%eax
  80963c:	e8 bf fc ff ff       	call   809300 <update_arp_entry>
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809641:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809645:	89 04 24             	mov    %eax,(%esp)
  809648:	e8 8e e0 ff ff       	call   8076db <htons>
  80964d:	83 c4 10             	add    $0x10,%esp
  809650:	66 83 f8 01          	cmp    $0x1,%ax
  809654:	74 40                	je     809696 <etharp_arp_input+0x154>
  809656:	66 83 f8 02          	cmp    $0x2,%ax
  80965a:	0f 84 b9 00 00 00    	je     809719 <etharp_arp_input+0x1d7>
  809660:	e9 c6 00 00 00       	jmp    80972b <etharp_arp_input+0x1e9>
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809665:	8d 4e 16             	lea    0x16(%esi),%ecx
  809668:	83 ec 0c             	sub    $0xc,%esp
  80966b:	6a 00                	push   $0x0
  80966d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809670:	8b 45 08             	mov    0x8(%ebp),%eax
  809673:	e8 88 fc ff ff       	call   809300 <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809678:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80967c:	89 04 24             	mov    %eax,(%esp)
  80967f:	e8 57 e0 ff ff       	call   8076db <htons>
  809684:	83 c4 10             	add    $0x10,%esp
  809687:	66 83 f8 02          	cmp    $0x2,%ax
  80968b:	0f 85 9a 00 00 00    	jne    80972b <etharp_arp_input+0x1e9>
  809691:	e9 83 00 00 00       	jmp    809719 <etharp_arp_input+0x1d7>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809696:	83 ec 0c             	sub    $0xc,%esp
  809699:	6a 02                	push   $0x2
  80969b:	e8 3b e0 ff ff       	call   8076db <htons>
  8096a0:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  8096a4:	8b 46 1c             	mov    0x1c(%esi),%eax
  8096a7:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8096aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8096ad:	8b 40 04             	mov    0x4(%eax),%eax
  8096b0:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8096b3:	83 c4 10             	add    $0x10,%esp
  8096b6:	ba 06 00 00 00       	mov    $0x6,%edx
  8096bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8096be:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8096c2:	74 17                	je     8096db <etharp_arp_input+0x199>
  8096c4:	83 ec 04             	sub    $0x4,%esp
  8096c7:	68 0c 22 81 00       	push   $0x81220c
  8096cc:	68 c7 02 00 00       	push   $0x2c7
  8096d1:	68 96 21 81 00       	push   $0x812196
  8096d6:	e8 6f 4d 00 00       	call   80e44a <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  8096db:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  8096de:	0f b6 c2             	movzbl %dl,%eax
  8096e1:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  8096e6:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  8096ea:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  8096ed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8096f0:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8096f4:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8096f8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8096fb:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8096ff:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809703:	84 d2                	test   %dl,%dl
  809705:	75 d4                	jne    8096db <etharp_arp_input+0x199>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809707:	83 ec 08             	sub    $0x8,%esp
  80970a:	53                   	push   %ebx
  80970b:	ff 75 08             	pushl  0x8(%ebp)
  80970e:	8b 45 08             	mov    0x8(%ebp),%eax
  809711:	ff 50 18             	call   *0x18(%eax)
  809714:	83 c4 10             	add    $0x10,%esp
  809717:	eb 12                	jmp    80972b <etharp_arp_input+0x1e9>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809719:	83 ec 08             	sub    $0x8,%esp
  80971c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80971f:	50                   	push   %eax
  809720:	ff 75 08             	pushl  0x8(%ebp)
  809723:	e8 d6 a1 ff ff       	call   8038fe <dhcp_arp_reply>
#endif
    break;
  809728:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80972b:	83 ec 0c             	sub    $0xc,%esp
  80972e:	53                   	push   %ebx
  80972f:	e8 f6 b0 ff ff       	call   80482a <pbuf_free>
  809734:	83 c4 10             	add    $0x10,%esp
}
  809737:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80973a:	5b                   	pop    %ebx
  80973b:	5e                   	pop    %esi
  80973c:	5f                   	pop    %edi
  80973d:	5d                   	pop    %ebp
  80973e:	c3                   	ret    

0080973f <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80973f:	55                   	push   %ebp
  809740:	89 e5                	mov    %esp,%ebp
  809742:	57                   	push   %edi
  809743:	56                   	push   %esi
  809744:	53                   	push   %ebx
  809745:	83 ec 10             	sub    $0x10,%esp
  809748:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80974b:	6a 00                	push   $0x0
  80974d:	6a 2a                	push   $0x2a
  80974f:	6a 02                	push   $0x2
  809751:	e8 9a b1 ff ff       	call   8048f0 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809756:	83 c4 10             	add    $0x10,%esp
  809759:	85 c0                	test   %eax,%eax
  80975b:	0f 84 ec 00 00 00    	je     80984d <etharp_request+0x10e>
  809761:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809763:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809768:	77 17                	ja     809781 <etharp_request+0x42>
  80976a:	83 ec 04             	sub    $0x4,%esp
  80976d:	68 78 22 81 00       	push   $0x812278
  809772:	68 1c 04 00 00       	push   $0x41c
  809777:	68 96 21 81 00       	push   $0x812196
  80977c:	e8 c9 4c 00 00       	call   80e44a <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  809781:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  809784:	83 ec 0c             	sub    $0xc,%esp
  809787:	6a 01                	push   $0x1
  809789:	e8 4d df ff ff       	call   8076db <htons>
  80978e:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809792:	83 c4 10             	add    $0x10,%esp
  809795:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809799:	74 17                	je     8097b2 <etharp_request+0x73>
  80979b:	83 ec 04             	sub    $0x4,%esp
  80979e:	68 0c 22 81 00       	push   $0x81220c
  8097a3:	68 23 04 00 00       	push   $0x423
  8097a8:	68 96 21 81 00       	push   $0x812196
  8097ad:	e8 98 4c 00 00       	call   80e44a <_panic>
  8097b2:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  8097b7:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8097ba:	0f b6 c2             	movzbl %dl,%eax
  8097bd:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8097c2:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8097c6:	0f b6 88 f8 22 81 00 	movzbl 0x8122f8(%eax),%ecx
  8097cd:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8097d1:	0f b6 88 00 23 81 00 	movzbl 0x812300(%eax),%ecx
  8097d8:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8097db:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8097e0:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  8097e4:	84 d2                	test   %dl,%dl
  8097e6:	75 cf                	jne    8097b7 <etharp_request+0x78>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8097e8:	8b 46 04             	mov    0x4(%esi),%eax
  8097eb:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8097ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  8097f1:	8b 00                	mov    (%eax),%eax
  8097f3:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8097f6:	83 ec 0c             	sub    $0xc,%esp
  8097f9:	6a 01                	push   $0x1
  8097fb:	e8 db de ff ff       	call   8076db <htons>
  809800:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809804:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80980b:	e8 cb de ff ff       	call   8076db <htons>
  809810:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809814:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80981b:	e8 bb de ff ff       	call   8076db <htons>
  809820:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809824:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80982b:	e8 ab de ff ff       	call   8076db <htons>
  809830:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  809834:	83 c4 08             	add    $0x8,%esp
  809837:	57                   	push   %edi
  809838:	56                   	push   %esi
  809839:	ff 56 18             	call   *0x18(%esi)
  80983c:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80983e:	89 3c 24             	mov    %edi,(%esp)
  809841:	e8 e4 af ff ff       	call   80482a <pbuf_free>
  809846:	83 c4 10             	add    $0x10,%esp
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  809849:	89 d8                	mov    %ebx,%eax
  80984b:	eb 05                	jmp    809852 <etharp_request+0x113>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80984d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809852:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809855:	5b                   	pop    %ebx
  809856:	5e                   	pop    %esi
  809857:	5f                   	pop    %edi
  809858:	5d                   	pop    %ebp
  809859:	c3                   	ret    

0080985a <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80985a:	55                   	push   %ebp
  80985b:	89 e5                	mov    %esp,%ebp
  80985d:	57                   	push   %edi
  80985e:	56                   	push   %esi
  80985f:	53                   	push   %ebx
  809860:	83 ec 24             	sub    $0x24,%esp
  809863:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  809866:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809869:	ff 75 08             	pushl  0x8(%ebp)
  80986c:	53                   	push   %ebx
  80986d:	e8 61 cc ff ff       	call   8064d3 <ip_addr_isbroadcast>
  809872:	83 c4 10             	add    $0x10,%esp
  809875:	84 c0                	test   %al,%al
  809877:	0f 85 a9 01 00 00    	jne    809a26 <etharp_query+0x1cc>
      ip_addr_ismulticast(ipaddr) ||
  80987d:	8b 33                	mov    (%ebx),%esi
  80987f:	83 ec 0c             	sub    $0xc,%esp
  809882:	68 00 00 00 f0       	push   $0xf0000000
  809887:	e8 8a e0 ff ff       	call   807916 <ntohl>
  80988c:	21 c6                	and    %eax,%esi
  80988e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809895:	e8 7c e0 ff ff       	call   807916 <ntohl>
  80989a:	83 c4 10             	add    $0x10,%esp
  80989d:	85 db                	test   %ebx,%ebx
  80989f:	0f 84 88 01 00 00    	je     809a2d <etharp_query+0x1d3>
  8098a5:	39 c6                	cmp    %eax,%esi
  8098a7:	0f 84 80 01 00 00    	je     809a2d <etharp_query+0x1d3>
      ip_addr_isany(ipaddr)) {
  8098ad:	83 3b 00             	cmpl   $0x0,(%ebx)
  8098b0:	0f 84 7e 01 00 00    	je     809a34 <etharp_query+0x1da>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8098b6:	ba 01 00 00 00       	mov    $0x1,%edx
  8098bb:	89 d8                	mov    %ebx,%eax
  8098bd:	e8 66 f7 ff ff       	call   809028 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  8098c2:	84 c0                	test   %al,%al
  8098c4:	0f 88 c4 01 00 00    	js     809a8e <etharp_query+0x234>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  8098ca:	0f be f0             	movsbl %al,%esi
  8098cd:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8098d0:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  8098d6:	85 c0                	test   %eax,%eax
  8098d8:	75 0f                	jne    8098e9 <etharp_query+0x8f>
    arp_table[i].state = ETHARP_STATE_PENDING;
  8098da:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8098dd:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  8098e4:	00 00 00 
  8098e7:	eb 28                	jmp    809911 <etharp_query+0xb7>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  8098e9:	8d 50 ff             	lea    -0x1(%eax),%edx
  8098ec:	83 fa 01             	cmp    $0x1,%edx
  8098ef:	76 17                	jbe    809908 <etharp_query+0xae>
  8098f1:	83 ec 04             	sub    $0x4,%esp
  8098f4:	68 ac 22 81 00       	push   $0x8122ac
  8098f9:	68 92 03 00 00       	push   $0x392
  8098fe:	68 96 21 81 00       	push   $0x812196
  809903:	e8 42 4b 00 00       	call   80e44a <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809908:	85 ff                	test   %edi,%edi
  80990a:	74 05                	je     809911 <etharp_query+0xb7>
  80990c:	83 f8 01             	cmp    $0x1,%eax
  80990f:	75 13                	jne    809924 <etharp_query+0xca>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  809911:	83 ec 08             	sub    $0x8,%esp
  809914:	53                   	push   %ebx
  809915:	ff 75 08             	pushl  0x8(%ebp)
  809918:	e8 22 fe ff ff       	call   80973f <etharp_request>
  80991d:	89 c3                	mov    %eax,%ebx
  80991f:	83 c4 10             	add    $0x10,%esp
  809922:	eb 05                	jmp    809929 <etharp_query+0xcf>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  809924:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  809929:	85 ff                	test   %edi,%edi
  80992b:	0f 84 0a 01 00 00    	je     809a3b <etharp_query+0x1e1>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809931:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809934:	8b 90 30 4a b3 00    	mov    0xb34a30(%eax),%edx
  80993a:	83 fa 02             	cmp    $0x2,%edx
  80993d:	75 24                	jne    809963 <etharp_query+0x109>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80993f:	8b 45 08             	mov    0x8(%ebp),%eax
  809942:	8d 48 25             	lea    0x25(%eax),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809945:	83 ec 0c             	sub    $0xc,%esp
  809948:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80994b:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809950:	50                   	push   %eax
  809951:	89 fa                	mov    %edi,%edx
  809953:	8b 45 08             	mov    0x8(%ebp),%eax
  809956:	e8 2d f9 ff ff       	call   809288 <etharp_send_ip>
  80995b:	83 c4 10             	add    $0x10,%esp
  80995e:	e9 2b 01 00 00       	jmp    809a8e <etharp_query+0x234>
  809963:	89 d8                	mov    %ebx,%eax
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809965:	83 fa 01             	cmp    $0x1,%edx
  809968:	0f 85 20 01 00 00    	jne    809a8e <etharp_query+0x234>
  80996e:	89 f8                	mov    %edi,%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809970:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809974:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809978:	75 20                	jne    80999a <etharp_query+0x140>
  80997a:	83 38 00             	cmpl   $0x0,(%eax)
  80997d:	0f 84 03 01 00 00    	je     809a86 <etharp_query+0x22c>
  809983:	83 ec 04             	sub    $0x4,%esp
  809986:	68 f2 21 81 00       	push   $0x8121f2
  80998b:	68 b1 03 00 00       	push   $0x3b1
  809990:	68 96 21 81 00       	push   $0x812196
  809995:	e8 b0 4a 00 00       	call   80e44a <_panic>
        if(p->type != PBUF_ROM) {
  80999a:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80999e:	0f 85 9b 00 00 00    	jne    809a3f <etharp_query+0x1e5>
          copy_needed = 1;
          break;
        }
        p = p->next;
  8099a4:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  8099a6:	85 c0                	test   %eax,%eax
  8099a8:	75 c6                	jne    809970 <etharp_query+0x116>
  8099aa:	e9 b0 00 00 00       	jmp    809a5f <etharp_query+0x205>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  8099af:	83 ec 08             	sub    $0x8,%esp
  8099b2:	57                   	push   %edi
  8099b3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8099b6:	57                   	push   %edi
  8099b7:	e8 32 b4 ff ff       	call   804dee <pbuf_copy>
  8099bc:	83 c4 10             	add    $0x10,%esp
  8099bf:	84 c0                	test   %al,%al
  8099c1:	0f 84 a4 00 00 00    	je     809a6b <etharp_query+0x211>
            pbuf_free(p);
  8099c7:	83 ec 0c             	sub    $0xc,%esp
  8099ca:	ff 75 e4             	pushl  -0x1c(%ebp)
  8099cd:	e8 58 ae ff ff       	call   80482a <pbuf_free>
  8099d2:	83 c4 10             	add    $0x10,%esp
  8099d5:	e9 a8 00 00 00       	jmp    809a82 <etharp_query+0x228>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  8099da:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  8099e0:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  8099e3:	6b d6 1c             	imul   $0x1c,%esi,%edx
  8099e6:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  8099ec:	85 c9                	test   %ecx,%ecx
  8099ee:	75 04                	jne    8099f4 <etharp_query+0x19a>
  8099f0:	eb 14                	jmp    809a06 <etharp_query+0x1ac>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  8099f2:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  8099f4:	8b 11                	mov    (%ecx),%edx
  8099f6:	85 d2                	test   %edx,%edx
  8099f8:	75 f8                	jne    8099f2 <etharp_query+0x198>
              r = r->next;
            }
            r->next = new_entry;
  8099fa:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8099fc:	b8 00 00 00 00       	mov    $0x0,%eax
  809a01:	e9 88 00 00 00       	jmp    809a8e <etharp_query+0x234>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  809a06:	6b f6 1c             	imul   $0x1c,%esi,%esi
  809a09:	89 86 20 4a b3 00    	mov    %eax,0xb34a20(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809a0f:	b8 00 00 00 00       	mov    $0x0,%eax
  809a14:	eb 78                	jmp    809a8e <etharp_query+0x234>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  809a16:	83 ec 0c             	sub    $0xc,%esp
  809a19:	57                   	push   %edi
  809a1a:	e8 0b ae ff ff       	call   80482a <pbuf_free>
  809a1f:	83 c4 10             	add    $0x10,%esp
  809a22:	89 d8                	mov    %ebx,%eax
  809a24:	eb 68                	jmp    809a8e <etharp_query+0x234>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809a26:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809a2b:	eb 61                	jmp    809a8e <etharp_query+0x234>
  809a2d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809a32:	eb 5a                	jmp    809a8e <etharp_query+0x234>
  809a34:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809a39:	eb 53                	jmp    809a8e <etharp_query+0x234>
  809a3b:	89 d8                	mov    %ebx,%eax
  809a3d:	eb 4f                	jmp    809a8e <etharp_query+0x234>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a3f:	83 ec 04             	sub    $0x4,%esp
  809a42:	6a 00                	push   $0x0
  809a44:	0f b7 d2             	movzwl %dx,%edx
  809a47:	52                   	push   %edx
  809a48:	6a 03                	push   $0x3
  809a4a:	e8 a1 ae ff ff       	call   8048f0 <pbuf_alloc>
  809a4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(p != NULL) {
  809a52:	83 c4 10             	add    $0x10,%esp
  809a55:	85 c0                	test   %eax,%eax
  809a57:	0f 85 52 ff ff ff    	jne    8099af <etharp_query+0x155>
  809a5d:	eb 23                	jmp    809a82 <etharp_query+0x228>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  809a5f:	83 ec 0c             	sub    $0xc,%esp
  809a62:	57                   	push   %edi
  809a63:	e8 39 b2 ff ff       	call   804ca1 <pbuf_ref>
  809a68:	83 c4 10             	add    $0x10,%esp
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809a6b:	83 ec 0c             	sub    $0xc,%esp
  809a6e:	6a 0a                	push   $0xa
  809a70:	e8 ec a9 ff ff       	call   804461 <memp_malloc>
        if (new_entry != NULL) {
  809a75:	83 c4 10             	add    $0x10,%esp
  809a78:	85 c0                	test   %eax,%eax
  809a7a:	0f 85 5a ff ff ff    	jne    8099da <etharp_query+0x180>
  809a80:	eb 94                	jmp    809a16 <etharp_query+0x1bc>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809a82:	89 d8                	mov    %ebx,%eax
  809a84:	eb 08                	jmp    809a8e <etharp_query+0x234>
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
  809a86:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a8a:	75 b3                	jne    809a3f <etharp_query+0x1e5>
  809a8c:	eb d1                	jmp    809a5f <etharp_query+0x205>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  809a8e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a91:	5b                   	pop    %ebx
  809a92:	5e                   	pop    %esi
  809a93:	5f                   	pop    %edi
  809a94:	5d                   	pop    %ebp
  809a95:	c3                   	ret    

00809a96 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  809a96:	55                   	push   %ebp
  809a97:	89 e5                	mov    %esp,%ebp
  809a99:	57                   	push   %edi
  809a9a:	56                   	push   %esi
  809a9b:	53                   	push   %ebx
  809a9c:	83 ec 24             	sub    $0x24,%esp
  809a9f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809aa2:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809aa5:	6a 0e                	push   $0xe
  809aa7:	ff 75 0c             	pushl  0xc(%ebp)
  809aaa:	e8 a9 ac ff ff       	call   804758 <pbuf_header>
  809aaf:	83 c4 10             	add    $0x10,%esp
  809ab2:	84 c0                	test   %al,%al
  809ab4:	0f 85 bd 00 00 00    	jne    809b77 <etharp_output+0xe1>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809aba:	83 ec 08             	sub    $0x8,%esp
  809abd:	53                   	push   %ebx
  809abe:	56                   	push   %esi
  809abf:	e8 0f ca ff ff       	call   8064d3 <ip_addr_isbroadcast>
  809ac4:	83 c4 10             	add    $0x10,%esp
  809ac7:	84 c0                	test   %al,%al
  809ac9:	0f 85 8d 00 00 00    	jne    809b5c <etharp_output+0xc6>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  809acf:	8b 3e                	mov    (%esi),%edi
  809ad1:	83 ec 0c             	sub    $0xc,%esp
  809ad4:	68 00 00 00 f0       	push   $0xf0000000
  809ad9:	e8 38 de ff ff       	call   807916 <ntohl>
  809ade:	21 c7                	and    %eax,%edi
  809ae0:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809ae7:	e8 2a de ff ff       	call   807916 <ntohl>
  809aec:	83 c4 10             	add    $0x10,%esp
  809aef:	39 c7                	cmp    %eax,%edi
  809af1:	75 44                	jne    809b37 <etharp_output+0xa1>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  809af3:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809af7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809afb:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809aff:	83 ec 0c             	sub    $0xc,%esp
  809b02:	ff 36                	pushl  (%esi)
  809b04:	e8 0d de ff ff       	call   807916 <ntohl>
  809b09:	c1 e8 10             	shr    $0x10,%eax
  809b0c:	83 e0 7f             	and    $0x7f,%eax
  809b0f:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809b12:	83 c4 04             	add    $0x4,%esp
  809b15:	ff 36                	pushl  (%esi)
  809b17:	e8 fa dd ff ff       	call   807916 <ntohl>
  809b1c:	c1 e8 08             	shr    $0x8,%eax
  809b1f:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809b22:	83 c4 04             	add    $0x4,%esp
  809b25:	ff 36                	pushl  (%esi)
  809b27:	e8 ea dd ff ff       	call   807916 <ntohl>
  809b2c:	88 45 e7             	mov    %al,-0x19(%ebp)
  809b2f:	83 c4 10             	add    $0x10,%esp
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  809b32:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809b35:	eb 2a                	jmp    809b61 <etharp_output+0xcb>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809b37:	8b 06                	mov    (%esi),%eax
  809b39:	33 43 04             	xor    0x4(%ebx),%eax
  809b3c:	85 43 08             	test   %eax,0x8(%ebx)
  809b3f:	74 09                	je     809b4a <etharp_output+0xb4>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  809b41:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809b45:	74 37                	je     809b7e <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  809b47:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  809b4a:	83 ec 04             	sub    $0x4,%esp
  809b4d:	ff 75 0c             	pushl  0xc(%ebp)
  809b50:	56                   	push   %esi
  809b51:	53                   	push   %ebx
  809b52:	e8 03 fd ff ff       	call   80985a <etharp_query>
  809b57:	83 c4 10             	add    $0x10,%esp
  809b5a:	eb 27                	jmp    809b83 <etharp_output+0xed>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  809b5c:	b8 00 23 81 00       	mov    $0x812300,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809b61:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809b64:	83 ec 0c             	sub    $0xc,%esp
  809b67:	50                   	push   %eax
  809b68:	8b 55 0c             	mov    0xc(%ebp),%edx
  809b6b:	89 d8                	mov    %ebx,%eax
  809b6d:	e8 16 f7 ff ff       	call   809288 <etharp_send_ip>
  809b72:	83 c4 10             	add    $0x10,%esp
  809b75:	eb 0c                	jmp    809b83 <etharp_output+0xed>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  809b77:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809b7c:	eb 05                	jmp    809b83 <etharp_output+0xed>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  809b7e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  809b83:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b86:	5b                   	pop    %ebx
  809b87:	5e                   	pop    %esi
  809b88:	5f                   	pop    %edi
  809b89:	5d                   	pop    %ebp
  809b8a:	c3                   	ret    

00809b8b <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809b8b:	55                   	push   %ebp
  809b8c:	89 e5                	mov    %esp,%ebp
  809b8e:	56                   	push   %esi
  809b8f:	53                   	push   %ebx
  809b90:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809b93:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809b96:	83 ec 0c             	sub    $0xc,%esp
  809b99:	8b 43 04             	mov    0x4(%ebx),%eax
  809b9c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809ba0:	50                   	push   %eax
  809ba1:	e8 35 db ff ff       	call   8076db <htons>
  809ba6:	83 c4 10             	add    $0x10,%esp
  809ba9:	66 3d 00 08          	cmp    $0x800,%ax
  809bad:	74 08                	je     809bb7 <ethernet_input+0x2c>
  809baf:	66 3d 06 08          	cmp    $0x806,%ax
  809bb3:	74 44                	je     809bf9 <ethernet_input+0x6e>
  809bb5:	eb 55                	jmp    809c0c <ethernet_input+0x81>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  809bb7:	83 ec 08             	sub    $0x8,%esp
  809bba:	53                   	push   %ebx
  809bbb:	56                   	push   %esi
  809bbc:	e8 37 f9 ff ff       	call   8094f8 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809bc1:	83 c4 08             	add    $0x8,%esp
  809bc4:	6a f2                	push   $0xfffffff2
  809bc6:	53                   	push   %ebx
  809bc7:	e8 8c ab ff ff       	call   804758 <pbuf_header>
  809bcc:	83 c4 10             	add    $0x10,%esp
  809bcf:	84 c0                	test   %al,%al
  809bd1:	74 17                	je     809bea <ethernet_input+0x5f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809bd3:	83 ec 04             	sub    $0x4,%esp
  809bd6:	68 d4 22 81 00       	push   $0x8122d4
  809bdb:	68 7e 04 00 00       	push   $0x47e
  809be0:	68 96 21 81 00       	push   $0x812196
  809be5:	e8 60 48 00 00       	call   80e44a <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  809bea:	83 ec 08             	sub    $0x8,%esp
  809bed:	56                   	push   %esi
  809bee:	53                   	push   %ebx
  809bef:	e8 89 c9 ff ff       	call   80657d <ip_input>
      }
      break;
  809bf4:	83 c4 10             	add    $0x10,%esp
  809bf7:	eb 1f                	jmp    809c18 <ethernet_input+0x8d>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809bf9:	83 ec 04             	sub    $0x4,%esp
  809bfc:	53                   	push   %ebx
  809bfd:	8d 46 25             	lea    0x25(%esi),%eax
  809c00:	50                   	push   %eax
  809c01:	56                   	push   %esi
  809c02:	e8 3b f9 ff ff       	call   809542 <etharp_arp_input>
      break;
  809c07:	83 c4 10             	add    $0x10,%esp
  809c0a:	eb 0c                	jmp    809c18 <ethernet_input+0x8d>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809c0c:	83 ec 0c             	sub    $0xc,%esp
  809c0f:	53                   	push   %ebx
  809c10:	e8 15 ac ff ff       	call   80482a <pbuf_free>
      p = NULL;
      break;
  809c15:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809c18:	b8 00 00 00 00       	mov    $0x0,%eax
  809c1d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809c20:	5b                   	pop    %ebx
  809c21:	5e                   	pop    %esi
  809c22:	5d                   	pop    %ebp
  809c23:	c3                   	ret    

00809c24 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809c24:	55                   	push   %ebp
  809c25:	89 e5                	mov    %esp,%ebp
  809c27:	53                   	push   %ebx
  809c28:	83 ec 10             	sub    $0x10,%esp
  809c2b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809c2e:	ff 73 04             	pushl  0x4(%ebx)
  809c31:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809c33:	89 1c 24             	mov    %ebx,(%esp)
  809c36:	e8 8b 65 00 00       	call   8101c6 <free>
}
  809c3b:	83 c4 10             	add    $0x10,%esp
  809c3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809c41:	c9                   	leave  
  809c42:	c3                   	ret    

00809c43 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809c43:	55                   	push   %ebp
  809c44:	89 e5                	mov    %esp,%ebp
  809c46:	83 ec 08             	sub    $0x8,%esp
  809c49:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c4c:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809c51:	89 c8                	mov    %ecx,%eax
  809c53:	f7 e2                	mul    %edx
  809c55:	c1 ea 08             	shr    $0x8,%edx
  809c58:	89 d0                	mov    %edx,%eax
  809c5a:	c1 e0 08             	shl    $0x8,%eax
  809c5d:	01 c2                	add    %eax,%edx
  809c5f:	89 c8                	mov    %ecx,%eax
  809c61:	29 d0                	sub    %edx,%eax
  809c63:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809c6a:	eb 2a                	jmp    809c96 <timeout_cleanup+0x53>
	if (t->tid == tid) {
  809c6c:	3b 08                	cmp    (%eax),%ecx
  809c6e:	75 23                	jne    809c93 <timeout_cleanup+0x50>
	    LIST_REMOVE(t, link);
  809c70:	8b 50 08             	mov    0x8(%eax),%edx
  809c73:	85 d2                	test   %edx,%edx
  809c75:	74 06                	je     809c7d <timeout_cleanup+0x3a>
  809c77:	8b 48 0c             	mov    0xc(%eax),%ecx
  809c7a:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809c7d:	8b 50 0c             	mov    0xc(%eax),%edx
  809c80:	8b 48 08             	mov    0x8(%eax),%ecx
  809c83:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809c85:	83 ec 0c             	sub    $0xc,%esp
  809c88:	50                   	push   %eax
  809c89:	e8 38 65 00 00       	call   8101c6 <free>
	    goto done;
  809c8e:	83 c4 10             	add    $0x10,%esp
  809c91:	eb 07                	jmp    809c9a <timeout_cleanup+0x57>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c93:	8b 40 08             	mov    0x8(%eax),%eax
  809c96:	85 c0                	test   %eax,%eax
  809c98:	75 d2                	jne    809c6c <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809c9a:	c9                   	leave  
  809c9b:	c3                   	ret    

00809c9c <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  809c9c:	55                   	push   %ebp
  809c9d:	89 e5                	mov    %esp,%ebp
  809c9f:	56                   	push   %esi
  809ca0:	53                   	push   %ebx
  809ca1:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809ca7:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809cac:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809cb1:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  809cb3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809cb9:	89 50 0c             	mov    %edx,0xc(%eax)
  809cbc:	85 d2                	test   %edx,%edx
  809cbe:	74 06                	je     809cc6 <sys_init+0x2a>
  809cc0:	8d 58 0c             	lea    0xc(%eax),%ebx
  809cc3:	89 5a 10             	mov    %ebx,0x10(%edx)
  809cc6:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809ccd:	83 c0 14             	add    $0x14,%eax
  809cd0:	89 ca                	mov    %ecx,%edx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  809cd2:	39 f0                	cmp    %esi,%eax
  809cd4:	75 db                	jne    809cb1 <sys_init+0x15>
  809cd6:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809cdd:	b1 b3 00 
  809ce0:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809ce6:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809ceb:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809cf0:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  809cf2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809cf8:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809cfe:	85 d2                	test   %edx,%edx
  809d00:	74 0c                	je     809d0e <sys_init+0x72>
  809d02:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809d08:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809d0e:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809d15:	4f b3 00 
  809d18:	05 9c 00 00 00       	add    $0x9c,%eax
  809d1d:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  809d1f:	39 f0                	cmp    %esi,%eax
  809d21:	75 cd                	jne    809cf0 <sys_init+0x54>
  809d23:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809d2a:	9c b3 00 
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  809d2d:	5b                   	pop    %ebx
  809d2e:	5e                   	pop    %esi
  809d2f:	5d                   	pop    %ebp
  809d30:	c3                   	ret    

00809d31 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  809d31:	55                   	push   %ebp
  809d32:	89 e5                	mov    %esp,%ebp
  809d34:	53                   	push   %ebx
  809d35:	83 ec 04             	sub    $0x4,%esp
  809d38:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809d3b:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809d40:	85 c0                	test   %eax,%eax
  809d42:	75 17                	jne    809d5b <sys_sem_new+0x2a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809d44:	83 ec 0c             	sub    $0xc,%esp
  809d47:	68 08 23 81 00       	push   $0x812308
  809d4c:	e8 d2 47 00 00       	call   80e523 <cprintf>
	return SYS_SEM_NULL;
  809d51:	83 c4 10             	add    $0x10,%esp
  809d54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809d59:	eb 52                	jmp    809dad <sys_sem_new+0x7c>
    }
    LIST_REMOVE(se, link);
  809d5b:	8b 48 0c             	mov    0xc(%eax),%ecx
  809d5e:	85 c9                	test   %ecx,%ecx
  809d60:	74 06                	je     809d68 <sys_sem_new+0x37>
  809d62:	8b 58 10             	mov    0x10(%eax),%ebx
  809d65:	89 59 10             	mov    %ebx,0x10(%ecx)
  809d68:	8b 48 10             	mov    0x10(%eax),%ecx
  809d6b:	8b 58 0c             	mov    0xc(%eax),%ebx
  809d6e:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809d70:	83 38 00             	cmpl   $0x0,(%eax)
  809d73:	75 19                	jne    809d8e <sys_sem_new+0x5d>
  809d75:	68 7d 24 81 00       	push   $0x81247d
  809d7a:	68 87 24 81 00       	push   $0x812487
  809d7f:	68 8d 00 00 00       	push   $0x8d
  809d84:	68 9c 24 81 00       	push   $0x81249c
  809d89:	e8 bc 46 00 00       	call   80e44a <_panic>
    se->freed = 0;
  809d8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  809d94:	0f b6 d2             	movzbl %dl,%edx
  809d97:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809d9b:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809d9f:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809da4:	c1 f8 02             	sar    $0x2,%eax
  809da7:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809dad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809db0:	c9                   	leave  
  809db1:	c3                   	ret    

00809db2 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  809db2:	55                   	push   %ebp
  809db3:	89 e5                	mov    %esp,%ebp
  809db5:	83 ec 08             	sub    $0x8,%esp
  809db8:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809dbb:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809dbe:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809dc5:	00 
  809dc6:	74 19                	je     809de1 <sys_sem_free+0x2f>
  809dc8:	68 b9 24 81 00       	push   $0x8124b9
  809dcd:	68 87 24 81 00       	push   $0x812487
  809dd2:	68 98 00 00 00       	push   $0x98
  809dd7:	68 9c 24 81 00       	push   $0x81249c
  809ddc:	e8 69 46 00 00       	call   80e44a <_panic>
    sems[sem].freed = 1;
  809de1:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809de4:	c1 e2 02             	shl    $0x2,%edx
  809de7:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809ded:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809df4:	00 00 00 
    sems[sem].gen++;
  809df7:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809dfb:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809e01:	89 51 0c             	mov    %edx,0xc(%ecx)
  809e04:	85 d2                	test   %edx,%edx
  809e06:	74 0d                	je     809e15 <sys_sem_free+0x63>
  809e08:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809e0b:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809e12:	89 4a 10             	mov    %ecx,0x10(%edx)
  809e15:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809e1c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809e1f:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809e26:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809e2c:	01 d0                	add    %edx,%eax
  809e2e:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809e35:	60 9d b3 00 
}
  809e39:	c9                   	leave  
  809e3a:	c3                   	ret    

00809e3b <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  809e3b:	55                   	push   %ebp
  809e3c:	89 e5                	mov    %esp,%ebp
  809e3e:	56                   	push   %esi
  809e3f:	53                   	push   %ebx
  809e40:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809e43:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809e49:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809e50:	74 16                	je     809e68 <sys_mbox_free+0x2d>
  809e52:	68 ca 24 81 00       	push   $0x8124ca
  809e57:	68 87 24 81 00       	push   $0x812487
  809e5c:	6a 62                	push   $0x62
  809e5e:	68 9c 24 81 00       	push   $0x81249c
  809e63:	e8 e2 45 00 00       	call   80e44a <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  809e68:	83 ec 0c             	sub    $0xc,%esp
  809e6b:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809e71:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809e77:	e8 36 ff ff ff       	call   809db2 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809e7c:	83 c4 04             	add    $0x4,%esp
  809e7f:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809e85:	e8 28 ff ff ff       	call   809db2 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809e8a:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809e8f:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809e95:	83 c4 10             	add    $0x10,%esp
  809e98:	85 c0                	test   %eax,%eax
  809e9a:	74 12                	je     809eae <sys_mbox_free+0x73>
  809e9c:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809ea2:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809ea8:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809eae:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809eb4:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809eba:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809ebf:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809ec6:	4f b3 00 
    mboxes[mbox].freed = 1;
  809ec9:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809ed0:	00 00 00 
}
  809ed3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809ed6:	5b                   	pop    %ebx
  809ed7:	5e                   	pop    %esi
  809ed8:	5d                   	pop    %ebp
  809ed9:	c3                   	ret    

00809eda <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  809eda:	55                   	push   %ebp
  809edb:	89 e5                	mov    %esp,%ebp
  809edd:	56                   	push   %esi
  809ede:	53                   	push   %ebx
    assert(size < MBOXSLOTS);
  809edf:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809ee3:	7e 16                	jle    809efb <sys_mbox_new+0x21>
  809ee5:	68 de 24 81 00       	push   $0x8124de
  809eea:	68 87 24 81 00       	push   $0x812487
  809eef:	6a 45                	push   $0x45
  809ef1:	68 9c 24 81 00       	push   $0x81249c
  809ef6:	e8 4f 45 00 00       	call   80e44a <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809efb:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809f01:	85 db                	test   %ebx,%ebx
  809f03:	75 1a                	jne    809f1f <sys_mbox_new+0x45>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  809f05:	83 ec 0c             	sub    $0xc,%esp
  809f08:	68 30 23 81 00       	push   $0x812330
  809f0d:	e8 11 46 00 00       	call   80e523 <cprintf>
	return SYS_MBOX_NULL;
  809f12:	83 c4 10             	add    $0x10,%esp
  809f15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f1a:	e9 b7 00 00 00       	jmp    809fd6 <sys_mbox_new+0xfc>
    }
    LIST_REMOVE(mbe, link);
  809f1f:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809f25:	85 c0                	test   %eax,%eax
  809f27:	74 0c                	je     809f35 <sys_mbox_new+0x5b>
  809f29:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809f2f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809f35:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809f3b:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809f41:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809f43:	83 3b 00             	cmpl   $0x0,(%ebx)
  809f46:	75 16                	jne    809f5e <sys_mbox_new+0x84>
  809f48:	68 ef 24 81 00       	push   $0x8124ef
  809f4d:	68 87 24 81 00       	push   $0x812487
  809f52:	6a 4c                	push   $0x4c
  809f54:	68 9c 24 81 00       	push   $0x81249c
  809f59:	e8 ec 44 00 00       	call   80e44a <_panic>
    mbe->freed = 0;
  809f5e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  809f64:	89 d8                	mov    %ebx,%eax
  809f66:	2d 60 4f b3 00       	sub    $0xb34f60,%eax
  809f6b:	c1 f8 02             	sar    $0x2,%eax
  809f6e:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  809f74:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809f7b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809f82:	83 ec 0c             	sub    $0xc,%esp
  809f85:	6a 00                	push   $0x0
  809f87:	e8 a5 fd ff ff       	call   809d31 <sys_sem_new>
  809f8c:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809f92:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809f99:	e8 93 fd ff ff       	call   809d31 <sys_sem_new>
  809f9e:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  809fa4:	83 c4 10             	add    $0x10,%esp
  809fa7:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809fae:	74 05                	je     809fb5 <sys_mbox_new+0xdb>
  809fb0:	83 f8 ff             	cmp    $0xffffffff,%eax
  809fb3:	75 1f                	jne    809fd4 <sys_mbox_new+0xfa>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  809fb5:	83 ec 0c             	sub    $0xc,%esp
  809fb8:	56                   	push   %esi
  809fb9:	e8 7d fe ff ff       	call   809e3b <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  809fbe:	c7 04 24 58 23 81 00 	movl   $0x812358,(%esp)
  809fc5:	e8 59 45 00 00       	call   80e523 <cprintf>
	return SYS_MBOX_NULL;
  809fca:	83 c4 10             	add    $0x10,%esp
  809fcd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809fd2:	eb 02                	jmp    809fd6 <sys_mbox_new+0xfc>
    }
    return i;
  809fd4:	89 f0                	mov    %esi,%eax
}
  809fd6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809fd9:	5b                   	pop    %ebx
  809fda:	5e                   	pop    %esi
  809fdb:	5d                   	pop    %ebp
  809fdc:	c3                   	ret    

00809fdd <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  809fdd:	55                   	push   %ebp
  809fde:	89 e5                	mov    %esp,%ebp
  809fe0:	83 ec 08             	sub    $0x8,%esp
  809fe3:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809fe6:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809fe9:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809ff0:	00 
  809ff1:	74 19                	je     80a00c <sys_sem_signal+0x2f>
  809ff3:	68 b9 24 81 00       	push   $0x8124b9
  809ff8:	68 87 24 81 00       	push   $0x812487
  809ffd:	68 a1 00 00 00       	push   $0xa1
  80a002:	68 9c 24 81 00       	push   $0x81249c
  80a007:	e8 3e 44 00 00       	call   80e44a <_panic>
    sems[sem].counter++;
  80a00c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a00f:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a016:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a01b:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a020:	74 27                	je     80a049 <sys_sem_signal+0x6c>
	sems[sem].waiters = 0;
  80a022:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a029:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a02c:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a033:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a036:	83 ec 0c             	sub    $0xc,%esp
  80a039:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a040:	50                   	push   %eax
  80a041:	e8 b9 04 00 00       	call   80a4ff <thread_wakeup>
  80a046:	83 c4 10             	add    $0x10,%esp
    }
}
  80a049:	c9                   	leave  
  80a04a:	c3                   	ret    

0080a04b <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a04b:	55                   	push   %ebp
  80a04c:	89 e5                	mov    %esp,%ebp
  80a04e:	57                   	push   %edi
  80a04f:	56                   	push   %esi
  80a050:	53                   	push   %ebx
  80a051:	83 ec 1c             	sub    $0x1c,%esp
  80a054:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a057:	8b 45 08             	mov    0x8(%ebp),%eax
  80a05a:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a05d:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a064:	00 
  80a065:	74 19                	je     80a080 <sys_arch_sem_wait+0x35>
  80a067:	68 b9 24 81 00       	push   $0x8124b9
  80a06c:	68 87 24 81 00       	push   $0x812487
  80a071:	68 ac 00 00 00       	push   $0xac
  80a076:	68 9c 24 81 00       	push   $0x81249c
  80a07b:	e8 ca 43 00 00       	call   80e44a <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a080:	8b 45 08             	mov    0x8(%ebp),%eax
  80a083:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a086:	8b 04 85 84 9d b3 00 	mov    0xb39d84(,%eax,4),%eax
  80a08d:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a090:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a095:	8b 45 08             	mov    0x8(%ebp),%eax
  80a098:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a09b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a09e:	e9 92 00 00 00       	jmp    80a135 <sys_arch_sem_wait+0xea>
	if (sems[sem].counter > 0) {
  80a0a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a0a6:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a0ad:	00 
  80a0ae:	66 85 c0             	test   %ax,%ax
  80a0b1:	74 18                	je     80a0cb <sys_arch_sem_wait+0x80>
	    sems[sem].counter--;
  80a0b3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a0b6:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80a0b9:	83 e8 01             	sub    $0x1,%eax
  80a0bc:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a0c3:	00 
	    return waited;
  80a0c4:	89 f8                	mov    %edi,%eax
  80a0c6:	e9 86 00 00 00       	jmp    80a151 <sys_arch_sem_wait+0x106>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a0cb:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a0ce:	74 7c                	je     80a14c <sys_arch_sem_wait+0x101>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a0d0:	e8 c7 4f 00 00       	call   80f09c <sys_time_msec>
  80a0d5:	89 c1                	mov    %eax,%ecx
  80a0d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a0da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a0df:	85 f6                	test   %esi,%esi
  80a0e1:	74 06                	je     80a0e9 <sys_arch_sem_wait+0x9e>
  80a0e3:	89 f0                	mov    %esi,%eax
  80a0e5:	29 f8                	sub    %edi,%eax
  80a0e7:	01 c8                	add    %ecx,%eax
	    sems[sem].waiters = 1;
  80a0e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a0ec:	8d 1c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%ebx
  80a0f3:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0f9:	83 ec 04             	sub    $0x4,%esp
  80a0fc:	50                   	push   %eax
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
  80a0fd:	8d 43 08             	lea    0x8(%ebx),%eax
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a100:	ff 73 08             	pushl  0x8(%ebx)
  80a103:	50                   	push   %eax
  80a104:	e8 0d 06 00 00       	call   80a716 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a109:	83 c4 10             	add    $0x10,%esp
  80a10c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a10f:	3b 43 04             	cmp    0x4(%ebx),%eax
  80a112:	74 17                	je     80a12b <sys_arch_sem_wait+0xe0>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a114:	83 ec 0c             	sub    $0xc,%esp
  80a117:	68 84 23 81 00       	push   $0x812384
  80a11c:	e8 02 44 00 00       	call   80e523 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a121:	83 c4 10             	add    $0x10,%esp
  80a124:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a129:	eb 26                	jmp    80a151 <sys_arch_sem_wait+0x106>
	    }
	    uint32_t b = sys_time_msec();
  80a12b:	e8 6c 4f 00 00       	call   80f09c <sys_time_msec>
	    waited += (b - a);
  80a130:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a133:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a135:	85 f6                	test   %esi,%esi
  80a137:	0f 84 66 ff ff ff    	je     80a0a3 <sys_arch_sem_wait+0x58>
  80a13d:	39 f7                	cmp    %esi,%edi
  80a13f:	0f 82 5e ff ff ff    	jb     80a0a3 <sys_arch_sem_wait+0x58>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a145:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a14a:	eb 05                	jmp    80a151 <sys_arch_sem_wait+0x106>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a14c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a151:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a154:	5b                   	pop    %ebx
  80a155:	5e                   	pop    %esi
  80a156:	5f                   	pop    %edi
  80a157:	5d                   	pop    %ebp
  80a158:	c3                   	ret    

0080a159 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a159:	55                   	push   %ebp
  80a15a:	89 e5                	mov    %esp,%ebp
  80a15c:	57                   	push   %edi
  80a15d:	56                   	push   %esi
  80a15e:	53                   	push   %ebx
  80a15f:	83 ec 0c             	sub    $0xc,%esp
  80a162:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a165:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a16b:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a172:	74 16                	je     80a18a <sys_mbox_trypost+0x31>
  80a174:	68 ca 24 81 00       	push   $0x8124ca
  80a179:	68 87 24 81 00       	push   $0x812487
  80a17e:	6a 72                	push   $0x72
  80a180:	68 9c 24 81 00       	push   $0x81249c
  80a185:	e8 c0 42 00 00       	call   80e44a <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a18a:	83 ec 08             	sub    $0x8,%esp
  80a18d:	6a 00                	push   $0x0
  80a18f:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a195:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a19b:	e8 ab fe ff ff       	call   80a04b <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a1a0:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a1a6:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a1ac:	83 c4 10             	add    $0x10,%esp
  80a1af:	39 ca                	cmp    %ecx,%edx
  80a1b1:	74 5c                	je     80a20f <sys_mbox_trypost+0xb6>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a1b3:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a1b9:	8d 42 01             	lea    0x1(%edx),%eax
  80a1bc:	89 c7                	mov    %eax,%edi
  80a1be:	c1 ff 1f             	sar    $0x1f,%edi
  80a1c1:	c1 ef 1b             	shr    $0x1b,%edi
  80a1c4:	01 f8                	add    %edi,%eax
  80a1c6:	83 e0 1f             	and    $0x1f,%eax
  80a1c9:	29 f8                	sub    %edi,%eax
  80a1cb:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a1d1:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a1d4:	01 d0                	add    %edx,%eax
  80a1d6:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a1d9:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)

    if (mboxes[mbox].head == -1)
  80a1e0:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a1e3:	75 0c                	jne    80a1f1 <sys_mbox_trypost+0x98>
	mboxes[mbox].head = slot;
  80a1e5:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1eb:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80a1f1:	83 ec 0c             	sub    $0xc,%esp
  80a1f4:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a1fa:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a200:	e8 d8 fd ff ff       	call   809fdd <sys_sem_signal>

    return ERR_OK;
  80a205:	83 c4 10             	add    $0x10,%esp
  80a208:	b8 00 00 00 00       	mov    $0x0,%eax
  80a20d:	eb 05                	jmp    80a214 <sys_mbox_trypost+0xbb>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80a20f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80a214:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a217:	5b                   	pop    %ebx
  80a218:	5e                   	pop    %esi
  80a219:	5f                   	pop    %edi
  80a21a:	5d                   	pop    %ebp
  80a21b:	c3                   	ret    

0080a21c <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80a21c:	55                   	push   %ebp
  80a21d:	89 e5                	mov    %esp,%ebp
  80a21f:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a222:	ff 75 0c             	pushl  0xc(%ebp)
  80a225:	ff 75 08             	pushl  0x8(%ebp)
  80a228:	e8 2c ff ff ff       	call   80a159 <sys_mbox_trypost>
  80a22d:	83 c4 10             	add    $0x10,%esp
  80a230:	84 c0                	test   %al,%al
  80a232:	74 16                	je     80a24a <sys_mbox_post+0x2e>
  80a234:	68 b0 23 81 00       	push   $0x8123b0
  80a239:	68 87 24 81 00       	push   $0x812487
  80a23e:	6a 6c                	push   $0x6c
  80a240:	68 9c 24 81 00       	push   $0x81249c
  80a245:	e8 00 42 00 00       	call   80e44a <_panic>
}
  80a24a:	c9                   	leave  
  80a24b:	c3                   	ret    

0080a24c <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80a24c:	55                   	push   %ebp
  80a24d:	89 e5                	mov    %esp,%ebp
  80a24f:	57                   	push   %edi
  80a250:	56                   	push   %esi
  80a251:	53                   	push   %ebx
  80a252:	83 ec 0c             	sub    $0xc,%esp
  80a255:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a258:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a25b:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a261:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a268:	74 19                	je     80a283 <sys_arch_mbox_fetch+0x37>
  80a26a:	68 ca 24 81 00       	push   $0x8124ca
  80a26f:	68 87 24 81 00       	push   $0x812487
  80a274:	68 ce 00 00 00       	push   $0xce
  80a279:	68 9c 24 81 00       	push   $0x81249c
  80a27e:	e8 c7 41 00 00       	call   80e44a <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a283:	83 ec 08             	sub    $0x8,%esp
  80a286:	ff 75 10             	pushl  0x10(%ebp)
  80a289:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a28f:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a295:	e8 b1 fd ff ff       	call   80a04b <sys_arch_sem_wait>
  80a29a:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a29c:	83 c4 10             	add    $0x10,%esp
  80a29f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a2a2:	0f 84 86 00 00 00    	je     80a32e <sys_arch_mbox_fetch+0xe2>
	return waited;

    int slot = mboxes[mbox].head;
  80a2a8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2ae:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a2b4:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a2b7:	75 17                	jne    80a2d0 <sys_arch_mbox_fetch+0x84>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a2b9:	83 ec 04             	sub    $0x4,%esp
  80a2bc:	68 d8 23 81 00       	push   $0x8123d8
  80a2c1:	68 d6 00 00 00       	push   $0xd6
  80a2c6:	68 9c 24 81 00       	push   $0x81249c
  80a2cb:	e8 7a 41 00 00       	call   80e44a <_panic>
    if (msg)
  80a2d0:	85 ff                	test   %edi,%edi
  80a2d2:	74 0e                	je     80a2e2 <sys_arch_mbox_fetch+0x96>
	*msg = mboxes[mbox].msg[slot];
  80a2d4:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a2d7:	01 c2                	add    %eax,%edx
  80a2d9:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a2e0:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a2e2:	83 c0 01             	add    $0x1,%eax
  80a2e5:	99                   	cltd   
  80a2e6:	c1 ea 1b             	shr    $0x1b,%edx
  80a2e9:	01 d0                	add    %edx,%eax
  80a2eb:	83 e0 1f             	and    $0x1f,%eax
  80a2ee:	29 d0                	sub    %edx,%eax
  80a2f0:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a2f6:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a2fc:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a302:	3b 42 08             	cmp    0x8(%edx),%eax
  80a305:	75 10                	jne    80a317 <sys_arch_mbox_fetch+0xcb>
	mboxes[mbox].head = -1;
  80a307:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a30d:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a314:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80a317:	83 ec 0c             	sub    $0xc,%esp
  80a31a:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a320:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a326:	e8 b2 fc ff ff       	call   809fdd <sys_sem_signal>
    return waited;
  80a32b:	83 c4 10             	add    $0x10,%esp
}
  80a32e:	89 f0                	mov    %esi,%eax
  80a330:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a333:	5b                   	pop    %ebx
  80a334:	5e                   	pop    %esi
  80a335:	5f                   	pop    %edi
  80a336:	5d                   	pop    %ebp
  80a337:	c3                   	ret    

0080a338 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80a338:	55                   	push   %ebp
  80a339:	89 e5                	mov    %esp,%ebp
  80a33b:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a33e:	6a fe                	push   $0xfffffffe
  80a340:	ff 75 0c             	pushl  0xc(%ebp)
  80a343:	ff 75 08             	pushl  0x8(%ebp)
  80a346:	e8 01 ff ff ff       	call   80a24c <sys_arch_mbox_fetch>
}
  80a34b:	c9                   	leave  
  80a34c:	c3                   	ret    

0080a34d <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80a34d:	55                   	push   %ebp
  80a34e:	89 e5                	mov    %esp,%ebp
  80a350:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a353:	6a 08                	push   $0x8
  80a355:	e8 1a 5f 00 00       	call   810274 <malloc>
    if (lt == 0)
  80a35a:	83 c4 10             	add    $0x10,%esp
  80a35d:	85 c0                	test   %eax,%eax
  80a35f:	75 17                	jne    80a378 <sys_thread_new+0x2b>
	panic("sys_thread_new: cannot allocate thread struct");
  80a361:	83 ec 04             	sub    $0x4,%esp
  80a364:	68 00 24 81 00       	push   $0x812400
  80a369:	68 fd 00 00 00       	push   $0xfd
  80a36e:	68 9c 24 81 00       	push   $0x81249c
  80a373:	e8 d2 40 00 00       	call   80e44a <_panic>

    if (stacksize > PGSIZE)
  80a378:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a37f:	7e 17                	jle    80a398 <sys_thread_new+0x4b>
	panic("large stack %d", stacksize);
  80a381:	ff 75 14             	pushl  0x14(%ebp)
  80a384:	68 fa 24 81 00       	push   $0x8124fa
  80a389:	68 00 01 00 00       	push   $0x100
  80a38e:	68 9c 24 81 00       	push   $0x81249c
  80a393:	e8 b2 40 00 00       	call   80e44a <_panic>

    lt->func = thread;
  80a398:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a39b:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a39d:	8b 55 10             	mov    0x10(%ebp),%edx
  80a3a0:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a3a3:	50                   	push   %eax
  80a3a4:	68 24 9c 80 00       	push   $0x809c24
  80a3a9:	ff 75 08             	pushl  0x8(%ebp)
  80a3ac:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a3af:	50                   	push   %eax
  80a3b0:	e8 b8 01 00 00       	call   80a56d <thread_create>

    if (r < 0)
  80a3b5:	83 c4 10             	add    $0x10,%esp
  80a3b8:	85 c0                	test   %eax,%eax
  80a3ba:	79 1e                	jns    80a3da <sys_thread_new+0x8d>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a3bc:	83 ec 0c             	sub    $0xc,%esp
  80a3bf:	50                   	push   %eax
  80a3c0:	e8 e4 04 00 00       	call   80a8a9 <e2s>
  80a3c5:	50                   	push   %eax
  80a3c6:	68 30 24 81 00       	push   $0x812430
  80a3cb:	68 09 01 00 00       	push   $0x109
  80a3d0:	68 9c 24 81 00       	push   $0x81249c
  80a3d5:	e8 70 40 00 00       	call   80e44a <_panic>

    return tid;
}
  80a3da:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a3dd:	c9                   	leave  
  80a3de:	c3                   	ret    

0080a3df <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a3df:	55                   	push   %ebp
  80a3e0:	89 e5                	mov    %esp,%ebp
  80a3e2:	57                   	push   %edi
  80a3e3:	56                   	push   %esi
  80a3e4:	53                   	push   %ebx
  80a3e5:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a3e8:	e8 06 01 00 00       	call   80a4f3 <thread_id>
  80a3ed:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3ef:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a3f4:	f7 e2                	mul    %edx
  80a3f6:	c1 ea 08             	shr    $0x8,%edx
  80a3f9:	89 d7                	mov    %edx,%edi
  80a3fb:	c1 e2 08             	shl    $0x8,%edx
  80a3fe:	01 d7                	add    %edx,%edi
  80a400:	89 f0                	mov    %esi,%eax
  80a402:	29 f8                	sub    %edi,%eax
  80a404:	89 c7                	mov    %eax,%edi
  80a406:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a40d:	eb 0b                	jmp    80a41a <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a40f:	3b 33                	cmp    (%ebx),%esi
  80a411:	0f 84 a4 00 00 00    	je     80a4bb <sys_arch_timeouts+0xdc>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a417:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a41a:	85 db                	test   %ebx,%ebx
  80a41c:	75 f1                	jne    80a40f <sys_arch_timeouts+0x30>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80a41e:	83 ec 0c             	sub    $0xc,%esp
  80a421:	6a 10                	push   $0x10
  80a423:	e8 4c 5e 00 00       	call   810274 <malloc>
  80a428:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a42a:	83 c4 10             	add    $0x10,%esp
  80a42d:	85 c0                	test   %eax,%eax
  80a42f:	75 17                	jne    80a448 <sys_arch_timeouts+0x69>
	panic("sys_arch_timeouts: cannot malloc");
  80a431:	83 ec 04             	sub    $0x4,%esp
  80a434:	68 5c 24 81 00       	push   $0x81245c
  80a439:	68 2c 01 00 00       	push   $0x12c
  80a43e:	68 9c 24 81 00       	push   $0x81249c
  80a443:	e8 02 40 00 00       	call   80e44a <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80a448:	83 ec 0c             	sub    $0xc,%esp
  80a44b:	68 43 9c 80 00       	push   $0x809c43
  80a450:	e8 ec 00 00 00       	call   80a541 <thread_onhalt>
    if (r < 0)
  80a455:	83 c4 10             	add    $0x10,%esp
  80a458:	85 c0                	test   %eax,%eax
  80a45a:	79 1e                	jns    80a47a <sys_arch_timeouts+0x9b>
	panic("thread_onhalt failed: %s", e2s(r));
  80a45c:	83 ec 0c             	sub    $0xc,%esp
  80a45f:	50                   	push   %eax
  80a460:	e8 44 04 00 00       	call   80a8a9 <e2s>
  80a465:	50                   	push   %eax
  80a466:	68 09 25 81 00       	push   $0x812509
  80a46b:	68 30 01 00 00       	push   $0x130
  80a470:	68 9c 24 81 00       	push   $0x81249c
  80a475:	e8 d0 3f 00 00       	call   80e44a <_panic>

    t->tid = tid;
  80a47a:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a47c:	83 ec 04             	sub    $0x4,%esp
  80a47f:	6a 04                	push   $0x4
  80a481:	6a 00                	push   $0x0
  80a483:	8d 43 04             	lea    0x4(%ebx),%eax
  80a486:	50                   	push   %eax
  80a487:	e8 61 47 00 00       	call   80ebed <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a48c:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a493:	89 43 08             	mov    %eax,0x8(%ebx)
  80a496:	83 c4 10             	add    $0x10,%esp
  80a499:	85 c0                	test   %eax,%eax
  80a49b:	74 0d                	je     80a4aa <sys_arch_timeouts+0xcb>
  80a49d:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a4a4:	8d 53 08             	lea    0x8(%ebx),%edx
  80a4a7:	89 50 0c             	mov    %edx,0xc(%eax)
  80a4aa:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a4b1:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a4b8:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a4bb:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a4be:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a4c1:	5b                   	pop    %ebx
  80a4c2:	5e                   	pop    %esi
  80a4c3:	5f                   	pop    %edi
  80a4c4:	5d                   	pop    %ebp
  80a4c5:	c3                   	ret    

0080a4c6 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a4c6:	55                   	push   %ebp
  80a4c7:	89 e5                	mov    %esp,%ebp
}
  80a4c9:	5d                   	pop    %ebp
  80a4ca:	c3                   	ret    

0080a4cb <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a4cb:	55                   	push   %ebp
  80a4cc:	89 e5                	mov    %esp,%ebp
}
  80a4ce:	5d                   	pop    %ebp
  80a4cf:	c3                   	ret    

0080a4d0 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a4d0:	55                   	push   %ebp
  80a4d1:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a4d3:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a4da:	00 00 00 
    tq->tq_last = 0;
  80a4dd:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a4e4:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a4e7:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a4ee:	00 00 00 
}
  80a4f1:	5d                   	pop    %ebp
  80a4f2:	c3                   	ret    

0080a4f3 <thread_id>:

uint32_t
thread_id(void) {
  80a4f3:	55                   	push   %ebp
  80a4f4:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80a4f6:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a4fb:	8b 00                	mov    (%eax),%eax
}
  80a4fd:	5d                   	pop    %ebp
  80a4fe:	c3                   	ret    

0080a4ff <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a4ff:	55                   	push   %ebp
  80a500:	89 e5                	mov    %esp,%ebp
  80a502:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a505:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a50a:	eb 0c                	jmp    80a518 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80a50c:	39 50 48             	cmp    %edx,0x48(%eax)
  80a50f:	75 04                	jne    80a515 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80a511:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a515:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80a518:	85 c0                	test   %eax,%eax
  80a51a:	75 f0                	jne    80a50c <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80a51c:	5d                   	pop    %ebp
  80a51d:	c3                   	ret    

0080a51e <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a51e:	55                   	push   %ebp
  80a51f:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80a521:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a527:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a52c:	eb 0d                	jmp    80a53b <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80a52e:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a532:	80 f9 01             	cmp    $0x1,%cl
  80a535:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a538:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80a53b:	85 d2                	test   %edx,%edx
  80a53d:	75 ef                	jne    80a52e <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80a53f:	5d                   	pop    %ebp
  80a540:	c3                   	ret    

0080a541 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a541:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a546:	8b 50 60             	mov    0x60(%eax),%edx
  80a549:	83 fa 03             	cmp    $0x3,%edx
  80a54c:	7f 17                	jg     80a565 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a54e:	55                   	push   %ebp
  80a54f:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a551:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a554:	89 48 60             	mov    %ecx,0x60(%eax)
  80a557:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a55a:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a55e:	b8 00 00 00 00       	mov    $0x0,%eax
  80a563:	eb 06                	jmp    80a56b <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80a565:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a56a:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80a56b:	5d                   	pop    %ebp
  80a56c:	c3                   	ret    

0080a56d <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a56d:	55                   	push   %ebp
  80a56e:	89 e5                	mov    %esp,%ebp
  80a570:	57                   	push   %edi
  80a571:	56                   	push   %esi
  80a572:	53                   	push   %ebx
  80a573:	83 ec 18             	sub    $0x18,%esp
  80a576:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a579:	6a 68                	push   $0x68
  80a57b:	e8 f4 5c 00 00       	call   810274 <malloc>
    if (!tc)
  80a580:	83 c4 10             	add    $0x10,%esp
  80a583:	85 c0                	test   %eax,%eax
  80a585:	0f 84 f4 00 00 00    	je     80a67f <thread_create+0x112>
  80a58b:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a58d:	83 ec 04             	sub    $0x4,%esp
  80a590:	6a 68                	push   $0x68
  80a592:	6a 00                	push   $0x0
  80a594:	50                   	push   %eax
  80a595:	e8 53 46 00 00       	call   80ebed <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80a59a:	83 c4 0c             	add    $0xc,%esp
  80a59d:	6a 1f                	push   $0x1f
  80a59f:	ff 75 0c             	pushl  0xc(%ebp)
  80a5a2:	8d 43 08             	lea    0x8(%ebx),%eax
  80a5a5:	50                   	push   %eax
  80a5a6:	e8 3f 45 00 00       	call   80eaea <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a5ab:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80a5af:	8b 15 94 b1 b3 00    	mov    0xb3b194,%edx
  80a5b5:	8d 42 01             	lea    0x1(%edx),%eax
  80a5b8:	a3 94 b1 b3 00       	mov    %eax,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a5bd:	83 c4 10             	add    $0x10,%esp
  80a5c0:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a5c3:	75 14                	jne    80a5d9 <thread_create+0x6c>
	panic("alloc_tid: no more thread ids");
  80a5c5:	83 ec 04             	sub    $0x4,%esp
  80a5c8:	68 22 25 81 00       	push   $0x812522
  80a5cd:	6a 54                	push   $0x54
  80a5cf:	68 40 25 81 00       	push   $0x812540
  80a5d4:	e8 71 3e 00 00       	call   80e44a <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a5d9:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a5db:	83 ec 0c             	sub    $0xc,%esp
  80a5de:	68 00 10 00 00       	push   $0x1000
  80a5e3:	e8 8c 5c 00 00       	call   810274 <malloc>
  80a5e8:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a5eb:	83 c4 10             	add    $0x10,%esp
  80a5ee:	85 c0                	test   %eax,%eax
  80a5f0:	75 16                	jne    80a608 <thread_create+0x9b>
	free(tc);
  80a5f2:	83 ec 0c             	sub    $0xc,%esp
  80a5f5:	53                   	push   %ebx
  80a5f6:	e8 cb 5b 00 00       	call   8101c6 <free>
	return -E_NO_MEM;
  80a5fb:	83 c4 10             	add    $0x10,%esp
  80a5fe:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a603:	e9 83 00 00 00       	jmp    80a68b <thread_create+0x11e>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a608:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a60e:	83 ec 04             	sub    $0x4,%esp
  80a611:	6a 04                	push   $0x4
  80a613:	6a 00                	push   $0x0
  80a615:	57                   	push   %edi
  80a616:	e8 d2 45 00 00       	call   80ebed <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a61b:	83 c4 0c             	add    $0xc,%esp
  80a61e:	6a 18                	push   $0x18
  80a620:	6a 00                	push   $0x0
  80a622:	8d 43 30             	lea    0x30(%ebx),%eax
  80a625:	50                   	push   %eax
  80a626:	e8 c2 45 00 00       	call   80ebed <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a62b:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a62e:	c7 43 30 17 a8 80 00 	movl   $0x80a817,0x30(%ebx)
    tc->tc_entry = entry;
  80a635:	8b 45 10             	mov    0x10(%ebp),%eax
  80a638:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a63b:	8b 45 14             	mov    0x14(%ebp),%eax
  80a63e:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a641:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a648:	83 c4 10             	add    $0x10,%esp
  80a64b:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a652:	75 0e                	jne    80a662 <thread_create+0xf5>
	tq->tq_first = tc;
  80a654:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a65a:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a660:	eb 0e                	jmp    80a670 <thread_create+0x103>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a662:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a667:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a66a:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
  80a670:	85 f6                	test   %esi,%esi
  80a672:	74 12                	je     80a686 <thread_create+0x119>
	*tid = tc->tc_tid;
  80a674:	8b 03                	mov    (%ebx),%eax
  80a676:	89 06                	mov    %eax,(%esi)
    return 0;
  80a678:	b8 00 00 00 00       	mov    $0x0,%eax
  80a67d:	eb 0c                	jmp    80a68b <thread_create+0x11e>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80a67f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a684:	eb 05                	jmp    80a68b <thread_create+0x11e>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a686:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a68b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a68e:	5b                   	pop    %ebx
  80a68f:	5e                   	pop    %esi
  80a690:	5f                   	pop    %edi
  80a691:	5d                   	pop    %ebp
  80a692:	c3                   	ret    

0080a693 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a693:	55                   	push   %ebp
  80a694:	89 e5                	mov    %esp,%ebp
  80a696:	53                   	push   %ebx
  80a697:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a69a:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a6a0:	85 db                	test   %ebx,%ebx
  80a6a2:	74 6d                	je     80a711 <thread_yield+0x7e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a6a4:	8b 43 64             	mov    0x64(%ebx),%eax
  80a6a7:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a6ac:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a6b3:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a6b8:	85 c0                	test   %eax,%eax
  80a6ba:	74 42                	je     80a6fe <thread_yield+0x6b>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a6bc:	83 ec 0c             	sub    $0xc,%esp
  80a6bf:	83 c0 30             	add    $0x30,%eax
  80a6c2:	50                   	push   %eax
  80a6c3:	e8 78 01 00 00       	call   80a840 <jos_setjmp>
  80a6c8:	83 c4 10             	add    $0x10,%esp
  80a6cb:	85 c0                	test   %eax,%eax
  80a6cd:	75 42                	jne    80a711 <thread_yield+0x7e>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80a6cf:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a6d4:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a6db:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a6e2:	75 0c                	jne    80a6f0 <thread_yield+0x5d>
	tq->tq_first = tc;
  80a6e4:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a6e9:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a6ee:	eb 0e                	jmp    80a6fe <thread_yield+0x6b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a6f0:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a6f6:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a6f9:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    }

    cur_tc = next_tc;
  80a6fe:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a704:	8d 43 30             	lea    0x30(%ebx),%eax
  80a707:	ba 01 00 00 00       	mov    $0x1,%edx
  80a70c:	e8 5f 01 00 00       	call   80a870 <jos_longjmp>
}
  80a711:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a714:	c9                   	leave  
  80a715:	c3                   	ret    

0080a716 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a716:	55                   	push   %ebp
  80a717:	89 e5                	mov    %esp,%ebp
  80a719:	57                   	push   %edi
  80a71a:	56                   	push   %esi
  80a71b:	53                   	push   %ebx
  80a71c:	83 ec 0c             	sub    $0xc,%esp
  80a71f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a722:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a725:	e8 72 49 00 00       	call   80f09c <sys_time_msec>
  80a72a:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80a72c:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a731:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a734:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80a738:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80a73a:	eb 22                	jmp    80a75e <thread_wait+0x48>
	if (p < s)
	    break;
	if (addr && *addr != val)
  80a73c:	85 db                	test   %ebx,%ebx
  80a73e:	74 07                	je     80a747 <thread_wait+0x31>
  80a740:	8b 03                	mov    (%ebx),%eax
  80a742:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a745:	75 1f                	jne    80a766 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80a747:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a74c:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a750:	84 c0                	test   %al,%al
  80a752:	75 12                	jne    80a766 <thread_wait+0x50>
	    break;

	thread_yield();
  80a754:	e8 3a ff ff ff       	call   80a693 <thread_yield>
	p = sys_time_msec();
  80a759:	e8 3e 49 00 00       	call   80f09c <sys_time_msec>

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
	if (p < s)
  80a75e:	39 f0                	cmp    %esi,%eax
  80a760:	72 04                	jb     80a766 <thread_wait+0x50>
  80a762:	39 f8                	cmp    %edi,%eax
  80a764:	72 d6                	jb     80a73c <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80a766:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a76b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a772:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a776:	83 c4 0c             	add    $0xc,%esp
  80a779:	5b                   	pop    %ebx
  80a77a:	5e                   	pop    %esi
  80a77b:	5f                   	pop    %edi
  80a77c:	5d                   	pop    %ebp
  80a77d:	c3                   	ret    

0080a77e <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80a77e:	55                   	push   %ebp
  80a77f:	89 e5                	mov    %esp,%ebp
  80a781:	56                   	push   %esi
  80a782:	53                   	push   %ebx
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a783:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a789:	85 db                	test   %ebx,%ebx
  80a78b:	74 40                	je     80a7cd <thread_halt+0x4f>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a78d:	8b 43 64             	mov    0x64(%ebx),%eax
  80a790:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a795:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80a79c:	be 00 00 00 00       	mov    $0x0,%esi
  80a7a1:	eb 0f                	jmp    80a7b2 <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80a7a3:	83 ec 0c             	sub    $0xc,%esp
  80a7a6:	ff 33                	pushl  (%ebx)
  80a7a8:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a7ac:	83 c6 01             	add    $0x1,%esi
  80a7af:	83 c4 10             	add    $0x10,%esp
  80a7b2:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a7b5:	7c ec                	jl     80a7a3 <thread_halt+0x25>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80a7b7:	83 ec 0c             	sub    $0xc,%esp
  80a7ba:	ff 73 04             	pushl  0x4(%ebx)
  80a7bd:	e8 04 5a 00 00       	call   8101c6 <free>
    free(tc);
  80a7c2:	89 1c 24             	mov    %ebx,(%esp)
  80a7c5:	e8 fc 59 00 00       	call   8101c6 <free>
  80a7ca:	83 c4 10             	add    $0x10,%esp
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80a7cd:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a7d2:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a7d9:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a7e0:	75 0c                	jne    80a7ee <thread_halt+0x70>
	tq->tq_first = tc;
  80a7e2:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a7e7:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a7ec:	eb 0e                	jmp    80a7fc <thread_halt+0x7e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a7ee:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a7f4:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a7f7:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a7fc:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a803:	00 00 00 
    thread_yield();
  80a806:	e8 88 fe ff ff       	call   80a693 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80a80b:	e8 20 3c 00 00       	call   80e430 <exit>
}
  80a810:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a813:	5b                   	pop    %ebx
  80a814:	5e                   	pop    %esi
  80a815:	5d                   	pop    %ebp
  80a816:	c3                   	ret    

0080a817 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80a817:	55                   	push   %ebp
  80a818:	89 e5                	mov    %esp,%ebp
  80a81a:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a81d:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a822:	ff 70 2c             	pushl  0x2c(%eax)
  80a825:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a828:	e8 51 ff ff ff       	call   80a77e <thread_halt>
}
  80a82d:	83 c4 10             	add    $0x10,%esp
  80a830:	c9                   	leave  
  80a831:	c3                   	ret    
  80a832:	66 90                	xchg   %ax,%ax
  80a834:	66 90                	xchg   %ax,%ax
  80a836:	66 90                	xchg   %ax,%ax
  80a838:	66 90                	xchg   %ax,%ax
  80a83a:	66 90                	xchg   %ax,%ax
  80a83c:	66 90                	xchg   %ax,%ax
  80a83e:	66 90                	xchg   %ax,%ax

0080a840 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a840:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a844:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a847:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a849:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a84d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a850:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a853:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a856:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a859:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a85c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a861:	c3                   	ret    
  80a862:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a869:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080a870 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a870:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a872:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a875:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a878:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a87b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a87e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a881:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a883:	ff e1                	jmp    *%ecx

0080a885 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a885:	55                   	push   %ebp
  80a886:	89 e5                	mov    %esp,%ebp
  80a888:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a88b:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80a890:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a897:	ff 75 08             	pushl  0x8(%ebp)
  80a89a:	68 5b 25 81 00       	push   $0x81255b
  80a89f:	e8 7f 3c 00 00       	call   80e523 <cprintf>
}
  80a8a4:	83 c4 10             	add    $0x10,%esp
  80a8a7:	c9                   	leave  
  80a8a8:	c3                   	ret    

0080a8a9 <e2s>:

const char *
e2s(int err) {
  80a8a9:	55                   	push   %ebp
  80a8aa:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a8ac:	8b 45 08             	mov    0x8(%ebp),%eax
  80a8af:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a8b6:	5d                   	pop    %ebp
  80a8b7:	c3                   	ret    

0080a8b8 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a8b8:	55                   	push   %ebp
  80a8b9:	89 e5                	mov    %esp,%ebp
  80a8bb:	57                   	push   %edi
  80a8bc:	56                   	push   %esi
  80a8bd:	53                   	push   %ebx
  80a8be:	83 ec 20             	sub    $0x20,%esp
  80a8c1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a8c4:	6a 07                	push   $0x7
  80a8c6:	68 00 00 00 10       	push   $0x10000000
  80a8cb:	6a 00                	push   $0x0
  80a8cd:	e8 d9 45 00 00       	call   80eeab <sys_page_alloc>
    if (r < 0)
  80a8d2:	83 c4 10             	add    $0x10,%esp
  80a8d5:	85 c0                	test   %eax,%eax
  80a8d7:	79 14                	jns    80a8ed <low_level_output+0x35>
	panic("jif: could not allocate page of memory");
  80a8d9:	83 ec 04             	sub    $0x4,%esp
  80a8dc:	68 40 2a 81 00       	push   $0x812a40
  80a8e1:	6a 50                	push   $0x50
  80a8e3:	68 91 2a 81 00       	push   $0x812a91
  80a8e8:	e8 5d 3b 00 00       	call   80e44a <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a8ed:	8b 45 08             	mov    0x8(%ebp),%eax
  80a8f0:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a8f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a8f6:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a8fb:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a900:	eb 46                	jmp    80a948 <low_level_output+0x90>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a902:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a906:	0f b7 d0             	movzwl %ax,%edx
  80a909:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80a90c:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a912:	7e 16                	jle    80a92a <low_level_output+0x72>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a914:	83 ec 0c             	sub    $0xc,%esp
  80a917:	56                   	push   %esi
  80a918:	52                   	push   %edx
  80a919:	68 68 2a 81 00       	push   $0x812a68
  80a91e:	6a 5f                	push   $0x5f
  80a920:	68 91 2a 81 00       	push   $0x812a91
  80a925:	e8 20 3b 00 00       	call   80e44a <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a92a:	83 ec 04             	sub    $0x4,%esp
  80a92d:	0f b7 c0             	movzwl %ax,%eax
  80a930:	50                   	push   %eax
  80a931:	ff 73 04             	pushl  0x4(%ebx)
  80a934:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a937:	50                   	push   %eax
  80a938:	e8 65 43 00 00       	call   80eca2 <memcpy>
	txsize += q->len;
  80a93d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a941:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a943:	8b 1b                	mov    (%ebx),%ebx
  80a945:	83 c4 10             	add    $0x10,%esp
  80a948:	85 db                	test   %ebx,%ebx
  80a94a:	75 b6                	jne    80a902 <low_level_output+0x4a>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80a94c:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a952:	6a 07                	push   $0x7
  80a954:	68 00 00 00 10       	push   $0x10000000
  80a959:	6a 0b                	push   $0xb
  80a95b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a95e:	ff 70 04             	pushl  0x4(%eax)
  80a961:	e8 38 4b 00 00       	call   80f49e <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a966:	83 c4 08             	add    $0x8,%esp
  80a969:	68 00 00 00 10       	push   $0x10000000
  80a96e:	6a 00                	push   $0x0
  80a970:	e8 bb 45 00 00       	call   80ef30 <sys_page_unmap>

    return ERR_OK;
}
  80a975:	b8 00 00 00 00       	mov    $0x0,%eax
  80a97a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a97d:	5b                   	pop    %ebx
  80a97e:	5e                   	pop    %esi
  80a97f:	5f                   	pop    %edi
  80a980:	5d                   	pop    %ebp
  80a981:	c3                   	ret    

0080a982 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a982:	55                   	push   %ebp
  80a983:	89 e5                	mov    %esp,%ebp
  80a985:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a988:	ff 75 10             	pushl  0x10(%ebp)
  80a98b:	ff 75 0c             	pushl  0xc(%ebp)
  80a98e:	ff 75 08             	pushl  0x8(%ebp)
  80a991:	e8 00 f1 ff ff       	call   809a96 <etharp_output>
}
  80a996:	c9                   	leave  
  80a997:	c3                   	ret    

0080a998 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a998:	55                   	push   %ebp
  80a999:	89 e5                	mov    %esp,%ebp
  80a99b:	57                   	push   %edi
  80a99c:	56                   	push   %esi
  80a99d:	53                   	push   %ebx
  80a99e:	83 ec 20             	sub    $0x20,%esp
  80a9a1:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80a9a4:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9a7:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a9aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80a9ad:	8b 06                	mov    (%esi),%eax
  80a9af:	89 c3                	mov    %eax,%ebx

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80a9b1:	6a 03                	push   $0x3
  80a9b3:	0f b7 c0             	movzwl %ax,%eax
  80a9b6:	50                   	push   %eax
  80a9b7:	6a 03                	push   $0x3
  80a9b9:	e8 32 9f ff ff       	call   8048f0 <pbuf_alloc>
  80a9be:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80a9c1:	83 c4 10             	add    $0x10,%esp
  80a9c4:	85 c0                	test   %eax,%eax
  80a9c6:	0f 84 b8 00 00 00    	je     80aa84 <jif_input+0xec>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80a9cc:	8d 56 04             	lea    0x4(%esi),%edx
  80a9cf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a9d2:	89 c6                	mov    %eax,%esi
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80a9d4:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80a9d9:	0f bf c3             	movswl %bx,%eax
  80a9dc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80a9df:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
	if (bytes > (len - copied))
  80a9e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a9e6:	29 f8                	sub    %edi,%eax
  80a9e8:	39 c3                	cmp    %eax,%ebx
  80a9ea:	0f 4f d8             	cmovg  %eax,%ebx
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80a9ed:	83 ec 04             	sub    $0x4,%esp
  80a9f0:	53                   	push   %ebx
  80a9f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a9f4:	01 f8                	add    %edi,%eax
  80a9f6:	50                   	push   %eax
  80a9f7:	ff 76 04             	pushl  0x4(%esi)
  80a9fa:	e8 a3 42 00 00       	call   80eca2 <memcpy>
	copied += bytes;
  80a9ff:	01 df                	add    %ebx,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80aa01:	8b 36                	mov    (%esi),%esi
  80aa03:	83 c4 10             	add    $0x10,%esp
  80aa06:	85 f6                	test   %esi,%esi
  80aa08:	75 d5                	jne    80a9df <jif_input+0x47>
  80aa0a:	eb 54                	jmp    80aa60 <jif_input+0xc8>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80aa0c:	83 ec 08             	sub    $0x8,%esp
  80aa0f:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80aa12:	57                   	push   %edi
  80aa13:	ff 75 08             	pushl  0x8(%ebp)
  80aa16:	e8 dd ea ff ff       	call   8094f8 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80aa1b:	83 c4 08             	add    $0x8,%esp
  80aa1e:	6a f2                	push   $0xfffffff2
  80aa20:	57                   	push   %edi
  80aa21:	e8 32 9d ff ff       	call   804758 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80aa26:	83 c4 08             	add    $0x8,%esp
  80aa29:	ff 75 08             	pushl  0x8(%ebp)
  80aa2c:	57                   	push   %edi
  80aa2d:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa30:	ff 50 10             	call   *0x10(%eax)
	break;
  80aa33:	83 c4 10             	add    $0x10,%esp
  80aa36:	eb 4c                	jmp    80aa84 <jif_input+0xec>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80aa38:	83 ec 04             	sub    $0x4,%esp
  80aa3b:	ff 75 dc             	pushl  -0x24(%ebp)
  80aa3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aa41:	ff 30                	pushl  (%eax)
  80aa43:	ff 75 08             	pushl  0x8(%ebp)
  80aa46:	e8 f7 ea ff ff       	call   809542 <etharp_arp_input>
	break;
  80aa4b:	83 c4 10             	add    $0x10,%esp
  80aa4e:	eb 34                	jmp    80aa84 <jif_input+0xec>

    default:
	pbuf_free(p);
  80aa50:	83 ec 0c             	sub    $0xc,%esp
  80aa53:	ff 75 dc             	pushl  -0x24(%ebp)
  80aa56:	e8 cf 9d ff ff       	call   80482a <pbuf_free>
  80aa5b:	83 c4 10             	add    $0x10,%esp
  80aa5e:	eb 24                	jmp    80aa84 <jif_input+0xec>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80aa60:	83 ec 0c             	sub    $0xc,%esp
  80aa63:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa66:	8b 40 04             	mov    0x4(%eax),%eax
  80aa69:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aa6d:	50                   	push   %eax
  80aa6e:	e8 68 cc ff ff       	call   8076db <htons>
  80aa73:	83 c4 10             	add    $0x10,%esp
  80aa76:	66 3d 00 08          	cmp    $0x800,%ax
  80aa7a:	74 90                	je     80aa0c <jif_input+0x74>
  80aa7c:	66 3d 06 08          	cmp    $0x806,%ax
  80aa80:	74 b6                	je     80aa38 <jif_input+0xa0>
  80aa82:	eb cc                	jmp    80aa50 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80aa84:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa87:	5b                   	pop    %ebx
  80aa88:	5e                   	pop    %esi
  80aa89:	5f                   	pop    %edi
  80aa8a:	5d                   	pop    %ebp
  80aa8b:	c3                   	ret    

0080aa8c <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80aa8c:	55                   	push   %ebp
  80aa8d:	89 e5                	mov    %esp,%ebp
  80aa8f:	57                   	push   %edi
  80aa90:	56                   	push   %esi
  80aa91:	53                   	push   %ebx
  80aa92:	83 ec 28             	sub    $0x28,%esp
  80aa95:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80aa98:	6a 08                	push   $0x8
  80aa9a:	e8 9b 97 ff ff       	call   80423a <mem_malloc>

    if (jif == NULL) {
  80aa9f:	83 c4 10             	add    $0x10,%esp
  80aaa2:	85 c0                	test   %eax,%eax
  80aaa4:	74 71                	je     80ab17 <jif_init+0x8b>
  80aaa6:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80aaa8:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80aaab:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80aaae:	c7 43 14 82 a9 80 00 	movl   $0x80a982,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80aab5:	c7 43 18 b8 a8 80 00 	movl   $0x80a8b8,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80aabc:	83 ec 04             	sub    $0x4,%esp
  80aabf:	6a 02                	push   $0x2
  80aac1:	68 8c 37 81 00       	push   $0x81378c
  80aac6:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80aac9:	50                   	push   %eax
  80aaca:	e8 d3 41 00 00       	call   80eca2 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80aacf:	8d 43 25             	lea    0x25(%ebx),%eax
  80aad2:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80aad4:	8b 17                	mov    (%edi),%edx
  80aad6:	89 56 04             	mov    %edx,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80aad9:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80aadd:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80aae3:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // Lab 6 challenge - MAC address is not hardcoded anymore
    sys_get_mac_address(netif->hwaddr);
  80aae7:	89 04 24             	mov    %eax,(%esp)
  80aaea:	e8 50 46 00 00       	call   80f13f <sys_get_mac_address>
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80aaef:	c7 04 24 2b 0e 81 00 	movl   $0x810e2b,(%esp)
  80aaf6:	e8 f9 cd ff ff       	call   8078f4 <inet_addr>
  80aafb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80aafe:	83 c4 0c             	add    $0xc,%esp
  80ab01:	6a 00                	push   $0x0
  80ab03:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab06:	50                   	push   %eax
  80ab07:	53                   	push   %ebx
  80ab08:	e8 4d ed ff ff       	call   80985a <etharp_query>

    return ERR_OK;
  80ab0d:	83 c4 10             	add    $0x10,%esp
  80ab10:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab15:	eb 05                	jmp    80ab1c <jif_init+0x90>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80ab17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80ab1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ab1f:	5b                   	pop    %ebx
  80ab20:	5e                   	pop    %esi
  80ab21:	5f                   	pop    %edi
  80ab22:	5d                   	pop    %ebp
  80ab23:	c3                   	ret    

0080ab24 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ab24:	55                   	push   %ebp
  80ab25:	89 e5                	mov    %esp,%ebp
  80ab27:	56                   	push   %esi
  80ab28:	53                   	push   %ebx
  80ab29:	83 ec 28             	sub    $0x28,%esp
  80ab2c:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ab2f:	ff 75 10             	pushl  0x10(%ebp)
  80ab32:	ff 75 08             	pushl  0x8(%ebp)
  80ab35:	e8 02 0f 00 00       	call   80ba3c <netconn_alloc>
  
  if (conn != NULL ) {
  80ab3a:	83 c4 10             	add    $0x10,%esp
  80ab3d:	85 c0                	test   %eax,%eax
  80ab3f:	0f 84 bd 00 00 00    	je     80ac02 <netconn_new_with_proto_and_callback+0xde>
  80ab45:	89 c3                	mov    %eax,%ebx
    msg.function = do_newconn;
  80ab47:	c7 45 e4 43 b9 80 00 	movl   $0x80b943,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ab4e:	89 f0                	mov    %esi,%eax
  80ab50:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ab53:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ab56:	83 ec 0c             	sub    $0xc,%esp
  80ab59:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab5c:	50                   	push   %eax
  80ab5d:	e8 a6 78 ff ff       	call   802408 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ab62:	83 c4 10             	add    $0x10,%esp
  80ab65:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ab69:	0f 84 9a 00 00 00    	je     80ac09 <netconn_new_with_proto_and_callback+0xe5>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ab6f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ab73:	74 14                	je     80ab89 <netconn_new_with_proto_and_callback+0x65>
  80ab75:	83 ec 04             	sub    $0x4,%esp
  80ab78:	68 a8 2a 81 00       	push   $0x812aa8
  80ab7d:	6a 52                	push   $0x52
  80ab7f:	68 5a 2b 81 00       	push   $0x812b5a
  80ab84:	e8 c1 38 00 00       	call   80e44a <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ab89:	8b 43 10             	mov    0x10(%ebx),%eax
  80ab8c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ab8f:	75 14                	jne    80aba5 <netconn_new_with_proto_and_callback+0x81>
  80ab91:	83 ec 04             	sub    $0x4,%esp
  80ab94:	68 71 2b 81 00       	push   $0x812b71
  80ab99:	6a 53                	push   $0x53
  80ab9b:	68 5a 2b 81 00       	push   $0x812b5a
  80aba0:	e8 a5 38 00 00       	call   80e44a <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80aba5:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80aba9:	75 14                	jne    80abbf <netconn_new_with_proto_and_callback+0x9b>
  80abab:	83 ec 04             	sub    $0x4,%esp
  80abae:	68 8a 2b 81 00       	push   $0x812b8a
  80abb3:	6a 54                	push   $0x54
  80abb5:	68 5a 2b 81 00       	push   $0x812b5a
  80abba:	e8 8b 38 00 00       	call   80e44a <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80abbf:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80abc3:	74 14                	je     80abd9 <netconn_new_with_proto_and_callback+0xb5>
  80abc5:	83 ec 04             	sub    $0x4,%esp
  80abc8:	68 cc 2a 81 00       	push   $0x812acc
  80abcd:	6a 55                	push   $0x55
  80abcf:	68 5a 2b 81 00       	push   $0x812b5a
  80abd4:	e8 71 38 00 00       	call   80e44a <_panic>
      sys_sem_free(conn->op_completed);
  80abd9:	83 ec 0c             	sub    $0xc,%esp
  80abdc:	50                   	push   %eax
  80abdd:	e8 d0 f1 ff ff       	call   809db2 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80abe2:	83 c4 04             	add    $0x4,%esp
  80abe5:	ff 73 14             	pushl  0x14(%ebx)
  80abe8:	e8 4e f2 ff ff       	call   809e3b <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80abed:	83 c4 08             	add    $0x8,%esp
  80abf0:	53                   	push   %ebx
  80abf1:	6a 07                	push   $0x7
  80abf3:	e8 bf 98 ff ff       	call   8044b7 <memp_free>
      return NULL;
  80abf8:	83 c4 10             	add    $0x10,%esp
  80abfb:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac00:	eb 09                	jmp    80ac0b <netconn_new_with_proto_and_callback+0xe7>
    }
  }
  return conn;
  80ac02:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac07:	eb 02                	jmp    80ac0b <netconn_new_with_proto_and_callback+0xe7>
  80ac09:	89 d8                	mov    %ebx,%eax
}
  80ac0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ac0e:	5b                   	pop    %ebx
  80ac0f:	5e                   	pop    %esi
  80ac10:	5d                   	pop    %ebp
  80ac11:	c3                   	ret    

0080ac12 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ac12:	55                   	push   %ebp
  80ac13:	89 e5                	mov    %esp,%ebp
  80ac15:	53                   	push   %ebx
  80ac16:	83 ec 24             	sub    $0x24,%esp
  80ac19:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ac1c:	85 db                	test   %ebx,%ebx
  80ac1e:	74 28                	je     80ac48 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ac20:	c7 45 e4 84 bc 80 00 	movl   $0x80bc84,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac27:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ac2a:	83 ec 0c             	sub    $0xc,%esp
  80ac2d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac30:	50                   	push   %eax
  80ac31:	e8 d2 77 ff ff       	call   802408 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ac36:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ac3d:	89 1c 24             	mov    %ebx,(%esp)
  80ac40:	e8 b0 0e 00 00       	call   80baf5 <netconn_free>

  return ERR_OK;
  80ac45:	83 c4 10             	add    $0x10,%esp
}
  80ac48:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac4d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac50:	c9                   	leave  
  80ac51:	c3                   	ret    

0080ac52 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ac52:	55                   	push   %ebp
  80ac53:	89 e5                	mov    %esp,%ebp
  80ac55:	83 ec 08             	sub    $0x8,%esp
  80ac58:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ac5b:	85 c0                	test   %eax,%eax
  80ac5d:	75 17                	jne    80ac76 <netconn_type+0x24>
  80ac5f:	83 ec 04             	sub    $0x4,%esp
  80ac62:	68 9f 2b 81 00       	push   $0x812b9f
  80ac67:	68 84 00 00 00       	push   $0x84
  80ac6c:	68 5a 2b 81 00       	push   $0x812b5a
  80ac71:	e8 d4 37 00 00       	call   80e44a <_panic>
  80ac76:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ac78:	c9                   	leave  
  80ac79:	c3                   	ret    

0080ac7a <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80ac7a:	55                   	push   %ebp
  80ac7b:	89 e5                	mov    %esp,%ebp
  80ac7d:	53                   	push   %ebx
  80ac7e:	83 ec 24             	sub    $0x24,%esp
  80ac81:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ac84:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac87:	8b 45 10             	mov    0x10(%ebp),%eax
  80ac8a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ac8d:	85 db                	test   %ebx,%ebx
  80ac8f:	75 17                	jne    80aca8 <netconn_getaddr+0x2e>
  80ac91:	83 ec 04             	sub    $0x4,%esp
  80ac94:	68 ba 2b 81 00       	push   $0x812bba
  80ac99:	68 98 00 00 00       	push   $0x98
  80ac9e:	68 5a 2b 81 00       	push   $0x812b5a
  80aca3:	e8 a2 37 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80aca8:	85 d2                	test   %edx,%edx
  80acaa:	75 17                	jne    80acc3 <netconn_getaddr+0x49>
  80acac:	83 ec 04             	sub    $0x4,%esp
  80acaf:	68 d8 2b 81 00       	push   $0x812bd8
  80acb4:	68 99 00 00 00       	push   $0x99
  80acb9:	68 5a 2b 81 00       	push   $0x812b5a
  80acbe:	e8 87 37 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80acc3:	85 c0                	test   %eax,%eax
  80acc5:	75 17                	jne    80acde <netconn_getaddr+0x64>
  80acc7:	83 ec 04             	sub    $0x4,%esp
  80acca:	68 f6 2b 81 00       	push   $0x812bf6
  80accf:	68 9a 00 00 00       	push   $0x9a
  80acd4:	68 5a 2b 81 00       	push   $0x812b5a
  80acd9:	e8 6c 37 00 00       	call   80e44a <_panic>

  msg.function = do_getaddr;
  80acde:	c7 45 e4 d3 c0 80 00 	movl   $0x80c0d3,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ace5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80ace8:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80aceb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80acee:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80acf1:	83 ec 0c             	sub    $0xc,%esp
  80acf4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80acf7:	50                   	push   %eax
  80acf8:	e8 0b 77 ff ff       	call   802408 <tcpip_apimsg>

  return conn->err;
  80acfd:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad04:	c9                   	leave  
  80ad05:	c3                   	ret    

0080ad06 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad06:	55                   	push   %ebp
  80ad07:	89 e5                	mov    %esp,%ebp
  80ad09:	53                   	push   %ebx
  80ad0a:	83 ec 24             	sub    $0x24,%esp
  80ad0d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad10:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad13:	85 db                	test   %ebx,%ebx
  80ad15:	75 17                	jne    80ad2e <netconn_bind+0x28>
  80ad17:	83 ec 04             	sub    $0x4,%esp
  80ad1a:	68 14 2c 81 00       	push   $0x812c14
  80ad1f:	68 b5 00 00 00       	push   $0xb5
  80ad24:	68 5a 2b 81 00       	push   $0x812b5a
  80ad29:	e8 1c 37 00 00       	call   80e44a <_panic>

  msg.function = do_bind;
  80ad2e:	c7 45 e4 2d bd 80 00 	movl   $0x80bd2d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad35:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad38:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad3b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad3e:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ad42:	83 ec 0c             	sub    $0xc,%esp
  80ad45:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad48:	50                   	push   %eax
  80ad49:	e8 ba 76 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80ad4e:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad52:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad55:	c9                   	leave  
  80ad56:	c3                   	ret    

0080ad57 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad57:	55                   	push   %ebp
  80ad58:	89 e5                	mov    %esp,%ebp
  80ad5a:	53                   	push   %ebx
  80ad5b:	83 ec 24             	sub    $0x24,%esp
  80ad5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad61:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad64:	85 db                	test   %ebx,%ebx
  80ad66:	75 17                	jne    80ad7f <netconn_connect+0x28>
  80ad68:	83 ec 04             	sub    $0x4,%esp
  80ad6b:	68 2f 2c 81 00       	push   $0x812c2f
  80ad70:	68 cc 00 00 00       	push   $0xcc
  80ad75:	68 5a 2b 81 00       	push   $0x812b5a
  80ad7a:	e8 cb 36 00 00       	call   80e44a <_panic>

  msg.function = do_connect;
  80ad7f:	c7 45 e4 bd bd 80 00 	movl   $0x80bdbd,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad86:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad89:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad8c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad8f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80ad93:	83 ec 0c             	sub    $0xc,%esp
  80ad96:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad99:	50                   	push   %eax
  80ad9a:	e8 69 76 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80ad9f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ada3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ada6:	c9                   	leave  
  80ada7:	c3                   	ret    

0080ada8 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80ada8:	55                   	push   %ebp
  80ada9:	89 e5                	mov    %esp,%ebp
  80adab:	53                   	push   %ebx
  80adac:	83 ec 24             	sub    $0x24,%esp
  80adaf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80adb2:	85 db                	test   %ebx,%ebx
  80adb4:	75 17                	jne    80adcd <netconn_disconnect+0x25>
  80adb6:	83 ec 04             	sub    $0x4,%esp
  80adb9:	68 f0 2a 81 00       	push   $0x812af0
  80adbe:	68 e2 00 00 00       	push   $0xe2
  80adc3:	68 5a 2b 81 00       	push   $0x812b5a
  80adc8:	e8 7d 36 00 00       	call   80e44a <_panic>

  msg.function = do_disconnect;
  80adcd:	c7 45 e4 72 be 80 00 	movl   $0x80be72,-0x1c(%ebp)
  msg.msg.conn = conn;
  80add4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80add7:	83 ec 0c             	sub    $0xc,%esp
  80adda:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80addd:	50                   	push   %eax
  80adde:	e8 25 76 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80ade3:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ade7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adea:	c9                   	leave  
  80adeb:	c3                   	ret    

0080adec <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80adec:	55                   	push   %ebp
  80aded:	89 e5                	mov    %esp,%ebp
  80adef:	53                   	push   %ebx
  80adf0:	83 ec 24             	sub    $0x24,%esp
  80adf3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80adf6:	85 db                	test   %ebx,%ebx
  80adf8:	75 17                	jne    80ae11 <netconn_listen_with_backlog+0x25>
  80adfa:	83 ec 04             	sub    $0x4,%esp
  80adfd:	68 4d 2c 81 00       	push   $0x812c4d
  80ae02:	68 fa 00 00 00       	push   $0xfa
  80ae07:	68 5a 2b 81 00       	push   $0x812b5a
  80ae0c:	e8 39 36 00 00       	call   80e44a <_panic>

  msg.function = do_listen;
  80ae11:	c7 45 e4 ad be 80 00 	movl   $0x80bead,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae18:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ae1b:	83 ec 0c             	sub    $0xc,%esp
  80ae1e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae21:	50                   	push   %eax
  80ae22:	e8 e1 75 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80ae27:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae2e:	c9                   	leave  
  80ae2f:	c3                   	ret    

0080ae30 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ae30:	55                   	push   %ebp
  80ae31:	89 e5                	mov    %esp,%ebp
  80ae33:	53                   	push   %ebx
  80ae34:	83 ec 14             	sub    $0x14,%esp
  80ae37:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ae3a:	85 db                	test   %ebx,%ebx
  80ae3c:	75 17                	jne    80ae55 <netconn_accept+0x25>
  80ae3e:	83 ec 04             	sub    $0x4,%esp
  80ae41:	68 6a 2c 81 00       	push   $0x812c6a
  80ae46:	68 10 01 00 00       	push   $0x110
  80ae4b:	68 5a 2b 81 00       	push   $0x812b5a
  80ae50:	e8 f5 35 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ae55:	8b 43 18             	mov    0x18(%ebx),%eax
  80ae58:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae5b:	75 17                	jne    80ae74 <netconn_accept+0x44>
  80ae5d:	83 ec 04             	sub    $0x4,%esp
  80ae60:	68 14 2b 81 00       	push   $0x812b14
  80ae65:	68 11 01 00 00       	push   $0x111
  80ae6a:	68 5a 2b 81 00       	push   $0x812b5a
  80ae6f:	e8 d6 35 00 00       	call   80e44a <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80ae74:	83 ec 04             	sub    $0x4,%esp
  80ae77:	6a 00                	push   $0x0
  80ae79:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80ae7c:	52                   	push   %edx
  80ae7d:	50                   	push   %eax
  80ae7e:	e8 c9 f3 ff ff       	call   80a24c <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80ae83:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ae86:	83 c4 10             	add    $0x10,%esp
  80ae89:	85 c0                	test   %eax,%eax
  80ae8b:	74 0d                	je     80ae9a <netconn_accept+0x6a>
  80ae8d:	83 ec 04             	sub    $0x4,%esp
  80ae90:	6a 00                	push   $0x0
  80ae92:	6a 01                	push   $0x1
  80ae94:	53                   	push   %ebx
  80ae95:	ff d0                	call   *%eax
  80ae97:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80ae9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ae9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aea0:	c9                   	leave  
  80aea1:	c3                   	ret    

0080aea2 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80aea2:	55                   	push   %ebp
  80aea3:	89 e5                	mov    %esp,%ebp
  80aea5:	53                   	push   %ebx
  80aea6:	83 ec 24             	sub    $0x24,%esp
  80aea9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80aeac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80aeb3:	85 db                	test   %ebx,%ebx
  80aeb5:	75 17                	jne    80aece <netconn_recv+0x2c>
  80aeb7:	83 ec 04             	sub    $0x4,%esp
  80aeba:	68 87 2c 81 00       	push   $0x812c87
  80aebf:	68 3a 01 00 00       	push   $0x13a
  80aec4:	68 5a 2b 81 00       	push   $0x812b5a
  80aec9:	e8 7c 35 00 00       	call   80e44a <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80aece:	8b 43 14             	mov    0x14(%ebx),%eax
  80aed1:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aed4:	75 0e                	jne    80aee4 <netconn_recv+0x42>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80aed6:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80aeda:	b8 00 00 00 00       	mov    $0x0,%eax
  80aedf:	e9 5b 01 00 00       	jmp    80b03f <netconn_recv+0x19d>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80aee4:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80aee8:	0f 8c 3a 01 00 00    	jl     80b028 <netconn_recv+0x186>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80aeee:	83 3b 10             	cmpl   $0x10,(%ebx)
  80aef1:	0f 85 f0 00 00 00    	jne    80afe7 <netconn_recv+0x145>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80aef7:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80aefb:	75 0e                	jne    80af0b <netconn_recv+0x69>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80aefd:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80af01:	b8 00 00 00 00       	mov    $0x0,%eax
  80af06:	e9 34 01 00 00       	jmp    80b03f <netconn_recv+0x19d>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80af0b:	83 ec 0c             	sub    $0xc,%esp
  80af0e:	6a 06                	push   $0x6
  80af10:	e8 4c 95 ff ff       	call   804461 <memp_malloc>
  80af15:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80af18:	83 c4 10             	add    $0x10,%esp
  80af1b:	85 c0                	test   %eax,%eax
  80af1d:	75 09                	jne    80af28 <netconn_recv+0x86>
      conn->err = ERR_MEM;
  80af1f:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80af23:	e9 17 01 00 00       	jmp    80b03f <netconn_recv+0x19d>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80af28:	83 ec 04             	sub    $0x4,%esp
  80af2b:	6a 00                	push   $0x0
  80af2d:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80af30:	50                   	push   %eax
  80af31:	ff 73 14             	pushl  0x14(%ebx)
  80af34:	e8 13 f3 ff ff       	call   80a24c <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80af39:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af3c:	83 c4 10             	add    $0x10,%esp
  80af3f:	85 c0                	test   %eax,%eax
  80af41:	0f 84 e8 00 00 00    	je     80b02f <netconn_recv+0x18d>
      len = p->tot_len;
  80af47:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80af4b:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af4f:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af52:	85 c9                	test   %ecx,%ecx
  80af54:	75 07                	jne    80af5d <netconn_recv+0xbb>
  80af56:	eb 43                	jmp    80af9b <netconn_recv+0xf9>

    if (p != NULL) {
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  80af58:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af5d:	83 ec 04             	sub    $0x4,%esp
  80af60:	0f b7 d2             	movzwl %dx,%edx
  80af63:	52                   	push   %edx
  80af64:	6a 01                	push   $0x1
  80af66:	53                   	push   %ebx
  80af67:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80af69:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af6c:	83 c4 10             	add    $0x10,%esp
  80af6f:	85 c0                	test   %eax,%eax
  80af71:	75 28                	jne    80af9b <netconn_recv+0xf9>
      memp_free(MEMP_NETBUF, buf);
  80af73:	83 ec 08             	sub    $0x8,%esp
  80af76:	ff 75 e0             	pushl  -0x20(%ebp)
  80af79:	6a 06                	push   $0x6
  80af7b:	e8 37 95 ff ff       	call   8044b7 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80af80:	83 c4 10             	add    $0x10,%esp
        conn->err = ERR_CLSD;
      }
      return NULL;
  80af83:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80af88:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80af8c:	0f 85 ad 00 00 00    	jne    80b03f <netconn_recv+0x19d>
        conn->err = ERR_CLSD;
  80af92:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80af96:	e9 a4 00 00 00       	jmp    80b03f <netconn_recv+0x19d>
      }
      return NULL;
    }

    buf->p = p;
  80af9b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80af9e:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80afa0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80afa3:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80afa6:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80afa9:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80afaf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80afb6:	c7 45 e4 3f c0 80 00 	movl   $0x80c03f,-0x1c(%ebp)
    msg.msg.conn = conn;
  80afbd:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80afc0:	85 c0                	test   %eax,%eax
  80afc2:	74 0c                	je     80afd0 <netconn_recv+0x12e>
      msg.msg.msg.r.len = buf->p->tot_len;
  80afc4:	8b 00                	mov    (%eax),%eax
  80afc6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80afca:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80afce:	eb 06                	jmp    80afd6 <netconn_recv+0x134>
    } else {
      msg.msg.msg.r.len = 1;
  80afd0:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80afd6:	83 ec 0c             	sub    $0xc,%esp
  80afd9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afdc:	50                   	push   %eax
  80afdd:	e8 26 74 ff ff       	call   802408 <tcpip_apimsg>
  80afe2:	83 c4 10             	add    $0x10,%esp
  80afe5:	eb 3c                	jmp    80b023 <netconn_recv+0x181>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80afe7:	83 ec 04             	sub    $0x4,%esp
  80afea:	6a 00                	push   $0x0
  80afec:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80afef:	52                   	push   %edx
  80aff0:	50                   	push   %eax
  80aff1:	e8 56 f2 ff ff       	call   80a24c <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80aff6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80aff9:	83 c4 10             	add    $0x10,%esp
  80affc:	85 c0                	test   %eax,%eax
  80affe:	74 23                	je     80b023 <netconn_recv+0x181>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b000:	8b 10                	mov    (%eax),%edx
  80b002:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b006:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b00a:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b00d:	85 d2                	test   %edx,%edx
  80b00f:	74 12                	je     80b023 <netconn_recv+0x181>
  80b011:	83 ec 04             	sub    $0x4,%esp
  80b014:	8b 00                	mov    (%eax),%eax
  80b016:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b01a:	50                   	push   %eax
  80b01b:	6a 01                	push   $0x1
  80b01d:	53                   	push   %ebx
  80b01e:	ff d2                	call   *%edx
  80b020:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b023:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b026:	eb 17                	jmp    80b03f <netconn_recv+0x19d>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80b028:	b8 00 00 00 00       	mov    $0x0,%eax
  80b02d:	eb 10                	jmp    80b03f <netconn_recv+0x19d>
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b02f:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b032:	85 c9                	test   %ecx,%ecx
  80b034:	0f 85 1e ff ff ff    	jne    80af58 <netconn_recv+0xb6>
  80b03a:	e9 34 ff ff ff       	jmp    80af73 <netconn_recv+0xd1>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80b03f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b042:	c9                   	leave  
  80b043:	c3                   	ret    

0080b044 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b044:	55                   	push   %ebp
  80b045:	89 e5                	mov    %esp,%ebp
  80b047:	53                   	push   %ebx
  80b048:	83 ec 24             	sub    $0x24,%esp
  80b04b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b04e:	85 db                	test   %ebx,%ebx
  80b050:	75 17                	jne    80b069 <netconn_send+0x25>
  80b052:	83 ec 04             	sub    $0x4,%esp
  80b055:	68 a2 2c 81 00       	push   $0x812ca2
  80b05a:	68 b9 01 00 00       	push   $0x1b9
  80b05f:	68 5a 2b 81 00       	push   $0x812b5a
  80b064:	e8 e1 33 00 00       	call   80e44a <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b069:	c7 45 e4 99 bf 80 00 	movl   $0x80bf99,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b070:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b073:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b076:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b079:	83 ec 0c             	sub    $0xc,%esp
  80b07c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b07f:	50                   	push   %eax
  80b080:	e8 83 73 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80b085:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b089:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b08c:	c9                   	leave  
  80b08d:	c3                   	ret    

0080b08e <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80b08e:	55                   	push   %ebp
  80b08f:	89 e5                	mov    %esp,%ebp
  80b091:	83 ec 08             	sub    $0x8,%esp
  80b094:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b097:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b09a:	85 c0                	test   %eax,%eax
  80b09c:	74 1b                	je     80b0b9 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b09e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b0a1:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b0a4:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b0a8:	83 ec 08             	sub    $0x8,%esp
  80b0ab:	50                   	push   %eax
  80b0ac:	ff 75 08             	pushl  0x8(%ebp)
  80b0af:	e8 90 ff ff ff       	call   80b044 <netconn_send>
  80b0b4:	83 c4 10             	add    $0x10,%esp
  80b0b7:	eb 05                	jmp    80b0be <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80b0b9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80b0be:	c9                   	leave  
  80b0bf:	c3                   	ret    

0080b0c0 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b0c0:	55                   	push   %ebp
  80b0c1:	89 e5                	mov    %esp,%ebp
  80b0c3:	53                   	push   %ebx
  80b0c4:	83 ec 24             	sub    $0x24,%esp
  80b0c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b0ca:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b0cd:	85 db                	test   %ebx,%ebx
  80b0cf:	75 17                	jne    80b0e8 <netconn_write+0x28>
  80b0d1:	83 ec 04             	sub    $0x4,%esp
  80b0d4:	68 bd 2c 81 00       	push   $0x812cbd
  80b0d9:	68 d3 01 00 00       	push   $0x1d3
  80b0de:	68 5a 2b 81 00       	push   $0x812b5a
  80b0e3:	e8 62 33 00 00       	call   80e44a <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b0e8:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b0eb:	74 17                	je     80b104 <netconn_write+0x44>
  80b0ed:	83 ec 04             	sub    $0x4,%esp
  80b0f0:	68 38 2b 81 00       	push   $0x812b38
  80b0f5:	68 d4 01 00 00       	push   $0x1d4
  80b0fa:	68 5a 2b 81 00       	push   $0x812b5a
  80b0ff:	e8 46 33 00 00       	call   80e44a <_panic>

  msg.function = do_write;
  80b104:	c7 45 e4 83 c0 80 00 	movl   $0x80c083,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b10b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b10e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b111:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b114:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b117:	8b 45 10             	mov    0x10(%ebp),%eax
  80b11a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b11d:	83 ec 0c             	sub    $0xc,%esp
  80b120:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b123:	50                   	push   %eax
  80b124:	e8 df 72 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80b129:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b12d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b130:	c9                   	leave  
  80b131:	c3                   	ret    

0080b132 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b132:	55                   	push   %ebp
  80b133:	89 e5                	mov    %esp,%ebp
  80b135:	53                   	push   %ebx
  80b136:	83 ec 24             	sub    $0x24,%esp
  80b139:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b13c:	85 db                	test   %ebx,%ebx
  80b13e:	75 17                	jne    80b157 <netconn_close+0x25>
  80b140:	83 ec 04             	sub    $0x4,%esp
  80b143:	68 d9 2c 81 00       	push   $0x812cd9
  80b148:	68 ed 01 00 00       	push   $0x1ed
  80b14d:	68 5a 2b 81 00       	push   $0x812b5a
  80b152:	e8 f3 32 00 00       	call   80e44a <_panic>

  msg.function = do_close;
  80b157:	c7 45 e4 97 c1 80 00 	movl   $0x80c197,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b15e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b161:	83 ec 0c             	sub    $0xc,%esp
  80b164:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b167:	50                   	push   %eax
  80b168:	e8 9b 72 ff ff       	call   802408 <tcpip_apimsg>
  return conn->err;
  80b16d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b171:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b174:	c9                   	leave  
  80b175:	c3                   	ret    

0080b176 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b176:	55                   	push   %ebp
  80b177:	89 e5                	mov    %esp,%ebp
  80b179:	56                   	push   %esi
  80b17a:	53                   	push   %ebx
  80b17b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b17e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b181:	8b 75 10             	mov    0x10(%ebp),%esi
  80b184:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b187:	85 c0                	test   %eax,%eax
  80b189:	75 17                	jne    80b1a2 <recv_tcp+0x2c>
  80b18b:	83 ec 04             	sub    $0x4,%esp
  80b18e:	68 f8 2c 81 00       	push   $0x812cf8
  80b193:	68 c1 00 00 00       	push   $0xc1
  80b198:	68 42 2e 81 00       	push   $0x812e42
  80b19d:	e8 a8 32 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b1a2:	85 db                	test   %ebx,%ebx
  80b1a4:	75 17                	jne    80b1bd <recv_tcp+0x47>
  80b1a6:	83 ec 04             	sub    $0x4,%esp
  80b1a9:	68 1c 2d 81 00       	push   $0x812d1c
  80b1ae:	68 c2 00 00 00       	push   $0xc2
  80b1b3:	68 42 2e 81 00       	push   $0x812e42
  80b1b8:	e8 8d 32 00 00       	call   80e44a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b1bd:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b1c0:	74 17                	je     80b1d9 <recv_tcp+0x63>
  80b1c2:	83 ec 04             	sub    $0x4,%esp
  80b1c5:	68 59 2e 81 00       	push   $0x812e59
  80b1ca:	68 c4 00 00 00       	push   $0xc4
  80b1cf:	68 42 2e 81 00       	push   $0x812e42
  80b1d4:	e8 71 32 00 00       	call   80e44a <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b1d9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1dd:	74 44                	je     80b223 <recv_tcp+0xad>
    return ERR_VAL;
  }

  conn->err = err;
  80b1df:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80b1e2:	85 f6                	test   %esi,%esi
  80b1e4:	74 0a                	je     80b1f0 <recv_tcp+0x7a>
    len = p->tot_len;
  80b1e6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b1ea:	66 01 43 20          	add    %ax,0x20(%ebx)
  80b1ee:	eb 05                	jmp    80b1f5 <recv_tcp+0x7f>
  } else {
    len = 0;
  80b1f0:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b1f5:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b1f8:	85 d2                	test   %edx,%edx
  80b1fa:	74 0f                	je     80b20b <recv_tcp+0x95>
  80b1fc:	83 ec 04             	sub    $0x4,%esp
  80b1ff:	0f b7 c0             	movzwl %ax,%eax
  80b202:	50                   	push   %eax
  80b203:	6a 00                	push   $0x0
  80b205:	53                   	push   %ebx
  80b206:	ff d2                	call   *%edx
  80b208:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b20b:	83 ec 08             	sub    $0x8,%esp
  80b20e:	56                   	push   %esi
  80b20f:	ff 73 14             	pushl  0x14(%ebx)
  80b212:	e8 42 ef ff ff       	call   80a159 <sys_mbox_trypost>
  80b217:	83 c4 10             	add    $0x10,%esp
  80b21a:	84 c0                	test   %al,%al
  80b21c:	0f 95 c0             	setne  %al
  80b21f:	f7 d8                	neg    %eax
  80b221:	eb 05                	jmp    80b228 <recv_tcp+0xb2>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80b223:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b228:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b22b:	5b                   	pop    %ebx
  80b22c:	5e                   	pop    %esi
  80b22d:	5d                   	pop    %ebp
  80b22e:	c3                   	ret    

0080b22f <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80b22f:	55                   	push   %ebp
  80b230:	89 e5                	mov    %esp,%ebp
  80b232:	57                   	push   %edi
  80b233:	56                   	push   %esi
  80b234:	53                   	push   %ebx
  80b235:	83 ec 1c             	sub    $0x1c,%esp
  80b238:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b23b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b23e:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b241:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b244:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b247:	85 c0                	test   %eax,%eax
  80b249:	75 17                	jne    80b262 <recv_udp+0x33>
  80b24b:	83 ec 04             	sub    $0x4,%esp
  80b24e:	68 3c 2d 81 00       	push   $0x812d3c
  80b253:	68 8e 00 00 00       	push   $0x8e
  80b258:	68 42 2e 81 00       	push   $0x812e42
  80b25d:	e8 e8 31 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b262:	85 db                	test   %ebx,%ebx
  80b264:	75 17                	jne    80b27d <recv_udp+0x4e>
  80b266:	83 ec 04             	sub    $0x4,%esp
  80b269:	68 60 2d 81 00       	push   $0x812d60
  80b26e:	68 8f 00 00 00       	push   $0x8f
  80b273:	68 42 2e 81 00       	push   $0x812e42
  80b278:	e8 cd 31 00 00       	call   80e44a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b27d:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b280:	74 17                	je     80b299 <recv_udp+0x6a>
  80b282:	83 ec 04             	sub    $0x4,%esp
  80b285:	68 77 2e 81 00       	push   $0x812e77
  80b28a:	68 91 00 00 00       	push   $0x91
  80b28f:	68 42 2e 81 00       	push   $0x812e42
  80b294:	e8 b1 31 00 00       	call   80e44a <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b299:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b29d:	75 0e                	jne    80b2ad <recv_udp+0x7e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80b29f:	83 ec 0c             	sub    $0xc,%esp
  80b2a2:	57                   	push   %edi
  80b2a3:	e8 82 95 ff ff       	call   80482a <pbuf_free>
    return;
  80b2a8:	83 c4 10             	add    $0x10,%esp
  80b2ab:	eb 72                	jmp    80b31f <recv_udp+0xf0>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80b2ad:	83 ec 0c             	sub    $0xc,%esp
  80b2b0:	6a 06                	push   $0x6
  80b2b2:	e8 aa 91 ff ff       	call   804461 <memp_malloc>
  80b2b7:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b2b9:	83 c4 10             	add    $0x10,%esp
  80b2bc:	85 c0                	test   %eax,%eax
  80b2be:	75 0e                	jne    80b2ce <recv_udp+0x9f>
    pbuf_free(p);
  80b2c0:	83 ec 0c             	sub    $0xc,%esp
  80b2c3:	57                   	push   %edi
  80b2c4:	e8 61 95 ff ff       	call   80482a <pbuf_free>
    return;
  80b2c9:	83 c4 10             	add    $0x10,%esp
  80b2cc:	eb 51                	jmp    80b31f <recv_udp+0xf0>
  } else {
    buf->p = p;
  80b2ce:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b2d0:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b2d3:	8b 45 14             	mov    0x14(%ebp),%eax
  80b2d6:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b2d9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b2dd:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b2e1:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b2e5:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b2e9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2ec:	85 c0                	test   %eax,%eax
  80b2ee:	74 10                	je     80b300 <recv_udp+0xd1>
  80b2f0:	83 ec 04             	sub    $0x4,%esp
  80b2f3:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b2f7:	52                   	push   %edx
  80b2f8:	6a 00                	push   $0x0
  80b2fa:	53                   	push   %ebx
  80b2fb:	ff d0                	call   *%eax
  80b2fd:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b300:	83 ec 08             	sub    $0x8,%esp
  80b303:	56                   	push   %esi
  80b304:	ff 73 14             	pushl  0x14(%ebx)
  80b307:	e8 4d ee ff ff       	call   80a159 <sys_mbox_trypost>
  80b30c:	83 c4 10             	add    $0x10,%esp
  80b30f:	84 c0                	test   %al,%al
  80b311:	74 0c                	je     80b31f <recv_udp+0xf0>
    netbuf_delete(buf);
  80b313:	83 ec 0c             	sub    $0xc,%esp
  80b316:	56                   	push   %esi
  80b317:	e8 dc 71 ff ff       	call   8024f8 <netbuf_delete>
    return;
  80b31c:	83 c4 10             	add    $0x10,%esp
  }
}
  80b31f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b322:	5b                   	pop    %ebx
  80b323:	5e                   	pop    %esi
  80b324:	5f                   	pop    %edi
  80b325:	5d                   	pop    %ebp
  80b326:	c3                   	ret    

0080b327 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80b327:	55                   	push   %ebp
  80b328:	89 e5                	mov    %esp,%ebp
  80b32a:	57                   	push   %edi
  80b32b:	56                   	push   %esi
  80b32c:	53                   	push   %ebx
  80b32d:	83 ec 0c             	sub    $0xc,%esp
  80b330:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b333:	85 db                	test   %ebx,%ebx
  80b335:	0f 84 c8 00 00 00    	je     80b403 <recv_raw+0xdc>
  80b33b:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b33f:	0f 84 be 00 00 00    	je     80b403 <recv_raw+0xdc>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b345:	83 ec 04             	sub    $0x4,%esp
  80b348:	6a 00                	push   $0x0
  80b34a:	8b 45 10             	mov    0x10(%ebp),%eax
  80b34d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b351:	50                   	push   %eax
  80b352:	6a 03                	push   $0x3
  80b354:	e8 97 95 ff ff       	call   8048f0 <pbuf_alloc>
  80b359:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b35b:	83 c4 10             	add    $0x10,%esp
  80b35e:	85 c0                	test   %eax,%eax
  80b360:	0f 84 9d 00 00 00    	je     80b403 <recv_raw+0xdc>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b366:	83 ec 08             	sub    $0x8,%esp
  80b369:	ff 75 10             	pushl  0x10(%ebp)
  80b36c:	50                   	push   %eax
  80b36d:	e8 7c 9a ff ff       	call   804dee <pbuf_copy>
  80b372:	83 c4 10             	add    $0x10,%esp
  80b375:	84 c0                	test   %al,%al
  80b377:	74 75                	je     80b3ee <recv_raw+0xc7>
        pbuf_free(q);
  80b379:	83 ec 0c             	sub    $0xc,%esp
  80b37c:	56                   	push   %esi
  80b37d:	e8 a8 94 ff ff       	call   80482a <pbuf_free>
  80b382:	83 c4 10             	add    $0x10,%esp
  80b385:	eb 7c                	jmp    80b403 <recv_raw+0xdc>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80b387:	83 ec 0c             	sub    $0xc,%esp
  80b38a:	56                   	push   %esi
  80b38b:	e8 9a 94 ff ff       	call   80482a <pbuf_free>
        return 0;
  80b390:	83 c4 10             	add    $0x10,%esp
  80b393:	eb 6e                	jmp    80b403 <recv_raw+0xdc>
      }

      buf->p = q;
  80b395:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b397:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b39a:	8b 46 04             	mov    0x4(%esi),%eax
  80b39d:	83 c0 0c             	add    $0xc,%eax
  80b3a0:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b3a3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3a6:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b3aa:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b3ae:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b3b2:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b3b6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b3b9:	85 c0                	test   %eax,%eax
  80b3bb:	74 10                	je     80b3cd <recv_raw+0xa6>
  80b3bd:	83 ec 04             	sub    $0x4,%esp
  80b3c0:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b3c4:	52                   	push   %edx
  80b3c5:	6a 00                	push   $0x0
  80b3c7:	53                   	push   %ebx
  80b3c8:	ff d0                	call   *%eax
  80b3ca:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b3cd:	83 ec 08             	sub    $0x8,%esp
  80b3d0:	57                   	push   %edi
  80b3d1:	ff 73 14             	pushl  0x14(%ebx)
  80b3d4:	e8 80 ed ff ff       	call   80a159 <sys_mbox_trypost>
  80b3d9:	83 c4 10             	add    $0x10,%esp
  80b3dc:	84 c0                	test   %al,%al
  80b3de:	74 23                	je     80b403 <recv_raw+0xdc>
        netbuf_delete(buf);
  80b3e0:	83 ec 0c             	sub    $0xc,%esp
  80b3e3:	57                   	push   %edi
  80b3e4:	e8 0f 71 ff ff       	call   8024f8 <netbuf_delete>
  80b3e9:	83 c4 10             	add    $0x10,%esp
  80b3ec:	eb 15                	jmp    80b403 <recv_raw+0xdc>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80b3ee:	83 ec 0c             	sub    $0xc,%esp
  80b3f1:	6a 06                	push   $0x6
  80b3f3:	e8 69 90 ff ff       	call   804461 <memp_malloc>
  80b3f8:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b3fa:	83 c4 10             	add    $0x10,%esp
  80b3fd:	85 c0                	test   %eax,%eax
  80b3ff:	75 94                	jne    80b395 <recv_raw+0x6e>
  80b401:	eb 84                	jmp    80b387 <recv_raw+0x60>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80b403:	b8 00 00 00 00       	mov    $0x0,%eax
  80b408:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b40b:	5b                   	pop    %ebx
  80b40c:	5e                   	pop    %esi
  80b40d:	5f                   	pop    %edi
  80b40e:	5d                   	pop    %ebp
  80b40f:	c3                   	ret    

0080b410 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b410:	55                   	push   %ebp
  80b411:	89 e5                	mov    %esp,%ebp
  80b413:	53                   	push   %ebx
  80b414:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b417:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b41a:	50                   	push   %eax
  80b41b:	53                   	push   %ebx
  80b41c:	e8 09 a4 ff ff       	call   80582a <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b421:	83 c4 08             	add    $0x8,%esp
  80b424:	68 76 b1 80 00       	push   $0x80b176
  80b429:	53                   	push   %ebx
  80b42a:	e8 09 a4 ff ff       	call   805838 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b42f:	83 c4 08             	add    $0x8,%esp
  80b432:	68 ae b8 80 00       	push   $0x80b8ae
  80b437:	53                   	push   %ebx
  80b438:	e8 0c a4 ff ff       	call   805849 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b43d:	83 c4 0c             	add    $0xc,%esp
  80b440:	6a 04                	push   $0x4
  80b442:	68 6a b8 80 00       	push   $0x80b86a
  80b447:	53                   	push   %ebx
  80b448:	e8 2c a4 ff ff       	call   805879 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b44d:	83 c4 08             	add    $0x8,%esp
  80b450:	68 ad b4 80 00       	push   $0x80b4ad
  80b455:	53                   	push   %ebx
  80b456:	e8 ff a3 ff ff       	call   80585a <tcp_err>
}
  80b45b:	83 c4 10             	add    $0x10,%esp
  80b45e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b461:	c9                   	leave  
  80b462:	c3                   	ret    

0080b463 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b463:	55                   	push   %ebp
  80b464:	89 e5                	mov    %esp,%ebp
  80b466:	53                   	push   %ebx
  80b467:	83 ec 04             	sub    $0x4,%esp
  80b46a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b46d:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b470:	85 db                	test   %ebx,%ebx
  80b472:	74 2f                	je     80b4a3 <do_connected+0x40>
    return ERR_VAL;
  }

  conn->err = err;
  80b474:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b477:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b47a:	75 0b                	jne    80b487 <do_connected+0x24>
  80b47c:	84 c0                	test   %al,%al
  80b47e:	75 07                	jne    80b487 <do_connected+0x24>
    setup_tcp(conn);
  80b480:	89 d8                	mov    %ebx,%eax
  80b482:	e8 89 ff ff ff       	call   80b410 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80b487:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b48e:	83 ec 0c             	sub    $0xc,%esp
  80b491:	ff 73 10             	pushl  0x10(%ebx)
  80b494:	e8 44 eb ff ff       	call   809fdd <sys_sem_signal>
  return ERR_OK;
  80b499:	83 c4 10             	add    $0x10,%esp
  80b49c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b4a1:	eb 05                	jmp    80b4a8 <do_connected+0x45>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80b4a3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80b4a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4ab:	c9                   	leave  
  80b4ac:	c3                   	ret    

0080b4ad <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80b4ad:	55                   	push   %ebp
  80b4ae:	89 e5                	mov    %esp,%ebp
  80b4b0:	53                   	push   %ebx
  80b4b1:	83 ec 04             	sub    $0x4,%esp
  80b4b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b4ba:	85 db                	test   %ebx,%ebx
  80b4bc:	75 17                	jne    80b4d5 <err_tcp+0x28>
  80b4be:	83 ec 04             	sub    $0x4,%esp
  80b4c1:	68 95 2e 81 00       	push   $0x812e95
  80b4c6:	68 22 01 00 00       	push   $0x122
  80b4cb:	68 42 2e 81 00       	push   $0x812e42
  80b4d0:	e8 75 2f 00 00       	call   80e44a <_panic>

  conn->pcb.tcp = NULL;
  80b4d5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80b4dc:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b4df:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4e3:	74 24                	je     80b509 <err_tcp+0x5c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b4e5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4e8:	85 c0                	test   %eax,%eax
  80b4ea:	74 0d                	je     80b4f9 <err_tcp+0x4c>
  80b4ec:	83 ec 04             	sub    $0x4,%esp
  80b4ef:	6a 00                	push   $0x0
  80b4f1:	6a 00                	push   $0x0
  80b4f3:	53                   	push   %ebx
  80b4f4:	ff d0                	call   *%eax
  80b4f6:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b4f9:	83 ec 08             	sub    $0x8,%esp
  80b4fc:	6a 00                	push   $0x0
  80b4fe:	ff 73 14             	pushl  0x14(%ebx)
  80b501:	e8 16 ed ff ff       	call   80a21c <sys_mbox_post>
  80b506:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b509:	8b 43 10             	mov    0x10(%ebx),%eax
  80b50c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b50f:	74 19                	je     80b52a <err_tcp+0x7d>
  80b511:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b515:	75 13                	jne    80b52a <err_tcp+0x7d>
    conn->state = NETCONN_NONE;
  80b517:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b51e:	83 ec 0c             	sub    $0xc,%esp
  80b521:	50                   	push   %eax
  80b522:	e8 b6 ea ff ff       	call   809fdd <sys_sem_signal>
  80b527:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b52a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b52e:	74 24                	je     80b554 <err_tcp+0xa7>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b530:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b533:	85 c0                	test   %eax,%eax
  80b535:	74 0d                	je     80b544 <err_tcp+0x97>
  80b537:	83 ec 04             	sub    $0x4,%esp
  80b53a:	6a 00                	push   $0x0
  80b53c:	6a 00                	push   $0x0
  80b53e:	53                   	push   %ebx
  80b53f:	ff d0                	call   *%eax
  80b541:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b544:	83 ec 08             	sub    $0x8,%esp
  80b547:	6a 00                	push   $0x0
  80b549:	ff 73 18             	pushl  0x18(%ebx)
  80b54c:	e8 cb ec ff ff       	call   80a21c <sys_mbox_post>
  80b551:	83 c4 10             	add    $0x10,%esp
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b554:	8b 43 04             	mov    0x4(%ebx),%eax
  80b557:	83 f8 01             	cmp    $0x1,%eax
  80b55a:	74 05                	je     80b561 <err_tcp+0xb4>
  80b55c:	83 f8 04             	cmp    $0x4,%eax
  80b55f:	75 15                	jne    80b576 <err_tcp+0xc9>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80b561:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80b568:	83 ec 0c             	sub    $0xc,%esp
  80b56b:	ff 73 10             	pushl  0x10(%ebx)
  80b56e:	e8 6a ea ff ff       	call   809fdd <sys_sem_signal>
  80b573:	83 c4 10             	add    $0x10,%esp
  }
}
  80b576:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b579:	c9                   	leave  
  80b57a:	c3                   	ret    

0080b57b <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b57b:	55                   	push   %ebp
  80b57c:	89 e5                	mov    %esp,%ebp
  80b57e:	57                   	push   %edi
  80b57f:	56                   	push   %esi
  80b580:	53                   	push   %ebx
  80b581:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b584:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b588:	74 17                	je     80b5a1 <do_writemore+0x26>
  80b58a:	83 ec 04             	sub    $0x4,%esp
  80b58d:	68 a2 2e 81 00       	push   $0x812ea2
  80b592:	68 b8 03 00 00       	push   $0x3b8
  80b597:	68 42 2e 81 00       	push   $0x812e42
  80b59c:	e8 a9 2e 00 00       	call   80e44a <_panic>
  80b5a1:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b5a3:	8b 50 24             	mov    0x24(%eax),%edx
  80b5a6:	8b 78 28             	mov    0x28(%eax),%edi
  80b5a9:	89 f9                	mov    %edi,%ecx
  80b5ab:	03 4a 04             	add    0x4(%edx),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b5ae:	8b 42 08             	mov    0x8(%edx),%eax
  80b5b1:	89 c3                	mov    %eax,%ebx
  80b5b3:	29 fb                	sub    %edi,%ebx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b5b5:	29 f8                	sub    %edi,%eax
  80b5b7:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80b5bd:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80b5c2:	0f 4f c3             	cmovg  %ebx,%eax
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b5c5:	8b 7e 08             	mov    0x8(%esi),%edi
  80b5c8:	0f b7 5f 6e          	movzwl 0x6e(%edi),%ebx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b5cc:	66 39 d8             	cmp    %bx,%ax
  80b5cf:	0f 46 d8             	cmovbe %eax,%ebx
  80b5d2:	0f b7 db             	movzwl %bx,%ebx
  80b5d5:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  80b5d9:	50                   	push   %eax
  80b5da:	53                   	push   %ebx
  80b5db:	51                   	push   %ecx
  80b5dc:	57                   	push   %edi
  80b5dd:	e8 ca c9 ff ff       	call   807fac <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b5e2:	89 da                	mov    %ebx,%edx
  80b5e4:	03 56 28             	add    0x28(%esi),%edx
  80b5e7:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b5ea:	83 c4 10             	add    $0x10,%esp
  80b5ed:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b5f0:	7e 17                	jle    80b609 <do_writemore+0x8e>
  80b5f2:	83 ec 04             	sub    $0x4,%esp
  80b5f5:	68 bf 2e 81 00       	push   $0x812ebf
  80b5fa:	68 cd 03 00 00       	push   $0x3cd
  80b5ff:	68 42 2e 81 00       	push   $0x812e42
  80b604:	e8 41 2e 00 00       	call   80e44a <_panic>
  if (err == ERR_OK) {
  80b609:	84 c0                	test   %al,%al
  80b60b:	75 6e                	jne    80b67b <do_writemore+0x100>
    conn->write_offset += len;
  80b60d:	89 56 28             	mov    %edx,0x28(%esi)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80b610:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b615:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b618:	75 13                	jne    80b62d <do_writemore+0xb2>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80b61a:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b621:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80b628:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b62d:	8b 46 08             	mov    0x8(%esi),%eax
  80b630:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b634:	74 12                	je     80b648 <do_writemore+0xcd>
  80b636:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b63a:	75 0c                	jne    80b648 <do_writemore+0xcd>
  80b63c:	8b 50 74             	mov    0x74(%eax),%edx
  80b63f:	85 d2                	test   %edx,%edx
  80b641:	74 6e                	je     80b6b1 <do_writemore+0x136>
  80b643:	83 3a 00             	cmpl   $0x0,(%edx)
  80b646:	74 69                	je     80b6b1 <do_writemore+0x136>
  80b648:	83 ec 0c             	sub    $0xc,%esp
  80b64b:	50                   	push   %eax
  80b64c:	e8 ae c9 ff ff       	call   807fff <tcp_output>
    conn->err = err;
  80b651:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b654:	83 c4 10             	add    $0x10,%esp
  80b657:	84 c0                	test   %al,%al
  80b659:	75 39                	jne    80b694 <do_writemore+0x119>
  80b65b:	8b 46 08             	mov    0x8(%esi),%eax
  80b65e:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b664:	77 2e                	ja     80b694 <do_writemore+0x119>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b666:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b669:	85 c0                	test   %eax,%eax
  80b66b:	74 27                	je     80b694 <do_writemore+0x119>
  80b66d:	83 ec 04             	sub    $0x4,%esp
  80b670:	53                   	push   %ebx
  80b671:	6a 03                	push   $0x3
  80b673:	56                   	push   %esi
  80b674:	ff d0                	call   *%eax
  80b676:	83 c4 10             	add    $0x10,%esp
  80b679:	eb 19                	jmp    80b694 <do_writemore+0x119>
    }
  } else if (err == ERR_MEM) {
  80b67b:	3c ff                	cmp    $0xff,%al
  80b67d:	75 10                	jne    80b68f <do_writemore+0x114>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80b67f:	83 ec 0c             	sub    $0xc,%esp
  80b682:	ff 76 08             	pushl  0x8(%esi)
  80b685:	e8 75 c9 ff ff       	call   807fff <tcp_output>
  80b68a:	83 c4 10             	add    $0x10,%esp
  80b68d:	eb 28                	jmp    80b6b7 <do_writemore+0x13c>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80b68f:	88 46 0c             	mov    %al,0xc(%esi)
  80b692:	eb 06                	jmp    80b69a <do_writemore+0x11f>
    write_finished = 1;
  }

  if (write_finished) {
  80b694:	89 f8                	mov    %edi,%eax
  80b696:	84 c0                	test   %al,%al
  80b698:	74 1d                	je     80b6b7 <do_writemore+0x13c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b69a:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b6a1:	83 ec 0c             	sub    $0xc,%esp
  80b6a4:	ff 76 10             	pushl  0x10(%esi)
  80b6a7:	e8 31 e9 ff ff       	call   809fdd <sys_sem_signal>
  80b6ac:	83 c4 10             	add    $0x10,%esp
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  80b6af:	eb 06                	jmp    80b6b7 <do_writemore+0x13c>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80b6b1:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b6b5:	eb a4                	jmp    80b65b <do_writemore+0xe0>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b6b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b6bf:	5b                   	pop    %ebx
  80b6c0:	5e                   	pop    %esi
  80b6c1:	5f                   	pop    %edi
  80b6c2:	5d                   	pop    %ebp
  80b6c3:	c3                   	ret    

0080b6c4 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80b6c4:	55                   	push   %ebp
  80b6c5:	89 e5                	mov    %esp,%ebp
  80b6c7:	53                   	push   %ebx
  80b6c8:	83 ec 04             	sub    $0x4,%esp
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b6cb:	85 c0                	test   %eax,%eax
  80b6cd:	75 17                	jne    80b6e6 <do_close_internal+0x22>
  80b6cf:	83 ec 04             	sub    $0x4,%esp
  80b6d2:	68 b0 2c 81 00       	push   $0x812cb0
  80b6d7:	68 53 02 00 00       	push   $0x253
  80b6dc:	68 42 2e 81 00       	push   $0x812e42
  80b6e1:	e8 64 2d 00 00       	call   80e44a <_panic>
  80b6e6:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b6e8:	83 38 10             	cmpl   $0x10,(%eax)
  80b6eb:	74 17                	je     80b704 <do_close_internal+0x40>
  80b6ed:	83 ec 04             	sub    $0x4,%esp
  80b6f0:	68 dd 2e 81 00       	push   $0x812edd
  80b6f5:	68 54 02 00 00       	push   $0x254
  80b6fa:	68 42 2e 81 00       	push   $0x812e42
  80b6ff:	e8 46 2d 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b704:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b708:	74 17                	je     80b721 <do_close_internal+0x5d>
  80b70a:	83 ec 04             	sub    $0x4,%esp
  80b70d:	68 80 2d 81 00       	push   $0x812d80
  80b712:	68 55 02 00 00       	push   $0x255
  80b717:	68 42 2e 81 00       	push   $0x812e42
  80b71c:	e8 29 2d 00 00       	call   80e44a <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b721:	8b 40 08             	mov    0x8(%eax),%eax
  80b724:	85 c0                	test   %eax,%eax
  80b726:	75 17                	jne    80b73f <do_close_internal+0x7b>
  80b728:	83 ec 04             	sub    $0x4,%esp
  80b72b:	68 fb 2e 81 00       	push   $0x812efb
  80b730:	68 56 02 00 00       	push   $0x256
  80b735:	68 42 2e 81 00       	push   $0x812e42
  80b73a:	e8 0b 2d 00 00       	call   80e44a <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80b73f:	83 ec 08             	sub    $0x8,%esp
  80b742:	6a 00                	push   $0x0
  80b744:	50                   	push   %eax
  80b745:	e8 e0 a0 ff ff       	call   80582a <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b74a:	8b 43 08             	mov    0x8(%ebx),%eax
  80b74d:	83 c4 10             	add    $0x10,%esp
  80b750:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b754:	75 10                	jne    80b766 <do_close_internal+0xa2>
    tcp_accept(conn->pcb.tcp, NULL);
  80b756:	83 ec 08             	sub    $0x8,%esp
  80b759:	6a 00                	push   $0x0
  80b75b:	50                   	push   %eax
  80b75c:	e8 0a a1 ff ff       	call   80586b <tcp_accept>
  80b761:	83 c4 10             	add    $0x10,%esp
  80b764:	eb 44                	jmp    80b7aa <do_close_internal+0xe6>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80b766:	83 ec 08             	sub    $0x8,%esp
  80b769:	6a 00                	push   $0x0
  80b76b:	50                   	push   %eax
  80b76c:	e8 c7 a0 ff ff       	call   805838 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b771:	83 c4 08             	add    $0x8,%esp
  80b774:	6a 00                	push   $0x0
  80b776:	ff 73 08             	pushl  0x8(%ebx)
  80b779:	e8 ed a0 ff ff       	call   80586b <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80b77e:	83 c4 08             	add    $0x8,%esp
  80b781:	6a 00                	push   $0x0
  80b783:	ff 73 08             	pushl  0x8(%ebx)
  80b786:	e8 be a0 ff ff       	call   805849 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b78b:	83 c4 0c             	add    $0xc,%esp
  80b78e:	6a 04                	push   $0x4
  80b790:	6a 00                	push   $0x0
  80b792:	ff 73 08             	pushl  0x8(%ebx)
  80b795:	e8 df a0 ff ff       	call   805879 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b79a:	83 c4 08             	add    $0x8,%esp
  80b79d:	6a 00                	push   $0x0
  80b79f:	ff 73 08             	pushl  0x8(%ebx)
  80b7a2:	e8 b3 a0 ff ff       	call   80585a <tcp_err>
  80b7a7:	83 c4 10             	add    $0x10,%esp
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80b7aa:	83 ec 0c             	sub    $0xc,%esp
  80b7ad:	ff 73 08             	pushl  0x8(%ebx)
  80b7b0:	e8 82 a2 ff ff       	call   805a37 <tcp_close>
  if (err == ERR_OK) {
  80b7b5:	83 c4 10             	add    $0x10,%esp
  80b7b8:	84 c0                	test   %al,%al
  80b7ba:	75 4a                	jne    80b806 <do_close_internal+0x142>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80b7bc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80b7c3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b7ca:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b7ce:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7d1:	85 c0                	test   %eax,%eax
  80b7d3:	74 21                	je     80b7f6 <do_close_internal+0x132>
  80b7d5:	83 ec 04             	sub    $0x4,%esp
  80b7d8:	6a 00                	push   $0x0
  80b7da:	6a 00                	push   $0x0
  80b7dc:	53                   	push   %ebx
  80b7dd:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b7df:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7e2:	83 c4 10             	add    $0x10,%esp
  80b7e5:	85 c0                	test   %eax,%eax
  80b7e7:	74 0d                	je     80b7f6 <do_close_internal+0x132>
  80b7e9:	83 ec 04             	sub    $0x4,%esp
  80b7ec:	6a 00                	push   $0x0
  80b7ee:	6a 02                	push   $0x2
  80b7f0:	53                   	push   %ebx
  80b7f1:	ff d0                	call   *%eax
  80b7f3:	83 c4 10             	add    $0x10,%esp
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80b7f6:	83 ec 0c             	sub    $0xc,%esp
  80b7f9:	ff 73 10             	pushl  0x10(%ebx)
  80b7fc:	e8 dc e7 ff ff       	call   809fdd <sys_sem_signal>
  80b801:	83 c4 10             	add    $0x10,%esp
  80b804:	eb 5f                	jmp    80b865 <do_close_internal+0x1a1>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b806:	8b 43 08             	mov    0x8(%ebx),%eax
  80b809:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b80d:	75 17                	jne    80b826 <do_close_internal+0x162>
  80b80f:	83 ec 04             	sub    $0x4,%esp
  80b812:	68 a4 2d 81 00       	push   $0x812da4
  80b817:	68 75 02 00 00       	push   $0x275
  80b81c:	68 42 2e 81 00       	push   $0x812e42
  80b821:	e8 24 2c 00 00       	call   80e44a <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b826:	83 ec 08             	sub    $0x8,%esp
  80b829:	68 ae b8 80 00       	push   $0x80b8ae
  80b82e:	50                   	push   %eax
  80b82f:	e8 15 a0 ff ff       	call   805849 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b834:	83 c4 0c             	add    $0xc,%esp
  80b837:	6a 04                	push   $0x4
  80b839:	68 6a b8 80 00       	push   $0x80b86a
  80b83e:	ff 73 08             	pushl  0x8(%ebx)
  80b841:	e8 33 a0 ff ff       	call   805879 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b846:	83 c4 08             	add    $0x8,%esp
  80b849:	68 ad b4 80 00       	push   $0x80b4ad
  80b84e:	ff 73 08             	pushl  0x8(%ebx)
  80b851:	e8 04 a0 ff ff       	call   80585a <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b856:	83 c4 08             	add    $0x8,%esp
  80b859:	53                   	push   %ebx
  80b85a:	ff 73 08             	pushl  0x8(%ebx)
  80b85d:	e8 c8 9f ff ff       	call   80582a <tcp_arg>
  80b862:	83 c4 10             	add    $0x10,%esp
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80b865:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b868:	c9                   	leave  
  80b869:	c3                   	ret    

0080b86a <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80b86a:	55                   	push   %ebp
  80b86b:	89 e5                	mov    %esp,%ebp
  80b86d:	83 ec 08             	sub    $0x8,%esp
  80b870:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b873:	85 c0                	test   %eax,%eax
  80b875:	75 17                	jne    80b88e <poll_tcp+0x24>
  80b877:	83 ec 04             	sub    $0x4,%esp
  80b87a:	68 95 2e 81 00       	push   $0x812e95
  80b87f:	68 eb 00 00 00       	push   $0xeb
  80b884:	68 42 2e 81 00       	push   $0x812e42
  80b889:	e8 bc 2b 00 00       	call   80e44a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b88e:	8b 50 04             	mov    0x4(%eax),%edx
  80b891:	83 fa 01             	cmp    $0x1,%edx
  80b894:	75 07                	jne    80b89d <poll_tcp+0x33>
    do_writemore(conn);
  80b896:	e8 e0 fc ff ff       	call   80b57b <do_writemore>
  80b89b:	eb 0a                	jmp    80b8a7 <poll_tcp+0x3d>
  } else if (conn->state == NETCONN_CLOSE) {
  80b89d:	83 fa 04             	cmp    $0x4,%edx
  80b8a0:	75 05                	jne    80b8a7 <poll_tcp+0x3d>
    do_close_internal(conn);
  80b8a2:	e8 1d fe ff ff       	call   80b6c4 <do_close_internal>
  }

  return ERR_OK;
}
  80b8a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8ac:	c9                   	leave  
  80b8ad:	c3                   	ret    

0080b8ae <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80b8ae:	55                   	push   %ebp
  80b8af:	89 e5                	mov    %esp,%ebp
  80b8b1:	56                   	push   %esi
  80b8b2:	53                   	push   %ebx
  80b8b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b8b6:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b8b9:	85 db                	test   %ebx,%ebx
  80b8bb:	75 17                	jne    80b8d4 <sent_tcp+0x26>
  80b8bd:	83 ec 04             	sub    $0x4,%esp
  80b8c0:	68 95 2e 81 00       	push   $0x812e95
  80b8c5:	68 03 01 00 00       	push   $0x103
  80b8ca:	68 42 2e 81 00       	push   $0x812e42
  80b8cf:	e8 76 2b 00 00       	call   80e44a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b8d4:	8b 43 04             	mov    0x4(%ebx),%eax
  80b8d7:	83 f8 01             	cmp    $0x1,%eax
  80b8da:	75 26                	jne    80b902 <sent_tcp+0x54>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b8dc:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b8e0:	75 17                	jne    80b8f9 <sent_tcp+0x4b>
  80b8e2:	83 ec 04             	sub    $0x4,%esp
  80b8e5:	68 0e 2f 81 00       	push   $0x812f0e
  80b8ea:	68 06 01 00 00       	push   $0x106
  80b8ef:	68 42 2e 81 00       	push   $0x812e42
  80b8f4:	e8 51 2b 00 00       	call   80e44a <_panic>
    do_writemore(conn);
  80b8f9:	89 d8                	mov    %ebx,%eax
  80b8fb:	e8 7b fc ff ff       	call   80b57b <do_writemore>
  80b900:	eb 2e                	jmp    80b930 <sent_tcp+0x82>
  } else if (conn->state == NETCONN_CLOSE) {
  80b902:	83 f8 04             	cmp    $0x4,%eax
  80b905:	75 29                	jne    80b930 <sent_tcp+0x82>
    do_close_internal(conn);
  80b907:	89 d8                	mov    %ebx,%eax
  80b909:	e8 b6 fd ff ff       	call   80b6c4 <do_close_internal>
  80b90e:	eb 20                	jmp    80b930 <sent_tcp+0x82>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b910:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b916:	76 1f                	jbe    80b937 <sent_tcp+0x89>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b918:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b91b:	85 c0                	test   %eax,%eax
  80b91d:	74 18                	je     80b937 <sent_tcp+0x89>
  80b91f:	83 ec 04             	sub    $0x4,%esp
  80b922:	0f b7 f6             	movzwl %si,%esi
  80b925:	56                   	push   %esi
  80b926:	6a 02                	push   $0x2
  80b928:	53                   	push   %ebx
  80b929:	ff d0                	call   *%eax
  80b92b:	83 c4 10             	add    $0x10,%esp
  80b92e:	eb 07                	jmp    80b937 <sent_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b930:	8b 43 08             	mov    0x8(%ebx),%eax
  80b933:	85 c0                	test   %eax,%eax
  80b935:	75 d9                	jne    80b910 <sent_tcp+0x62>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80b937:	b8 00 00 00 00       	mov    $0x0,%eax
  80b93c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b93f:	5b                   	pop    %ebx
  80b940:	5e                   	pop    %esi
  80b941:	5d                   	pop    %ebp
  80b942:	c3                   	ret    

0080b943 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80b943:	55                   	push   %ebp
  80b944:	89 e5                	mov    %esp,%ebp
  80b946:	56                   	push   %esi
  80b947:	53                   	push   %ebx
  80b948:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b94b:	8b 03                	mov    (%ebx),%eax
  80b94d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b951:	0f 85 ce 00 00 00    	jne    80ba25 <do_newconn+0xe2>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80b957:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80b95b:	8b 33                	mov    (%ebx),%esi
  80b95d:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80b961:	74 17                	je     80b97a <do_newconn+0x37>
  80b963:	83 ec 04             	sub    $0x4,%esp
  80b966:	68 c8 2d 81 00       	push   $0x812dc8
  80b96b:	68 8a 01 00 00       	push   $0x18a
  80b970:	68 42 2e 81 00       	push   $0x812e42
  80b975:	e8 d0 2a 00 00       	call   80e44a <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80b97a:	8b 06                	mov    (%esi),%eax
  80b97c:	25 f0 00 00 00       	and    $0xf0,%eax
  80b981:	83 f8 20             	cmp    $0x20,%eax
  80b984:	74 46                	je     80b9cc <do_newconn+0x89>
  80b986:	83 f8 40             	cmp    $0x40,%eax
  80b989:	74 0b                	je     80b996 <do_newconn+0x53>
  80b98b:	83 f8 10             	cmp    $0x10,%eax
  80b98e:	0f 85 8d 00 00 00    	jne    80ba21 <do_newconn+0xde>
  80b994:	eb 6e                	jmp    80ba04 <do_newconn+0xc1>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80b996:	83 ec 0c             	sub    $0xc,%esp
  80b999:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80b99d:	50                   	push   %eax
  80b99e:	e8 2c 25 00 00       	call   80decf <raw_new>
  80b9a3:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80b9a6:	8b 03                	mov    (%ebx),%eax
  80b9a8:	8b 50 08             	mov    0x8(%eax),%edx
  80b9ab:	83 c4 10             	add    $0x10,%esp
  80b9ae:	85 d2                	test   %edx,%edx
  80b9b0:	75 06                	jne    80b9b8 <do_newconn+0x75>
       msg->conn->err = ERR_MEM;
  80b9b2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b9b6:	eb 6d                	jmp    80ba25 <do_newconn+0xe2>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80b9b8:	83 ec 04             	sub    $0x4,%esp
  80b9bb:	50                   	push   %eax
  80b9bc:	68 27 b3 80 00       	push   $0x80b327
  80b9c1:	52                   	push   %edx
  80b9c2:	e8 86 23 00 00       	call   80dd4d <raw_recv>
  80b9c7:	83 c4 10             	add    $0x10,%esp
  80b9ca:	eb 59                	jmp    80ba25 <do_newconn+0xe2>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80b9cc:	e8 a2 d5 ff ff       	call   808f73 <udp_new>
  80b9d1:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80b9d4:	8b 03                	mov    (%ebx),%eax
  80b9d6:	8b 50 08             	mov    0x8(%eax),%edx
  80b9d9:	85 d2                	test   %edx,%edx
  80b9db:	75 06                	jne    80b9e3 <do_newconn+0xa0>
       msg->conn->err = ERR_MEM;
  80b9dd:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b9e1:	eb 42                	jmp    80ba25 <do_newconn+0xe2>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80b9e3:	83 38 22             	cmpl   $0x22,(%eax)
  80b9e6:	75 04                	jne    80b9ec <do_newconn+0xa9>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80b9e8:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80b9ec:	8b 03                	mov    (%ebx),%eax
  80b9ee:	83 ec 04             	sub    $0x4,%esp
  80b9f1:	50                   	push   %eax
  80b9f2:	68 2f b2 80 00       	push   $0x80b22f
  80b9f7:	ff 70 08             	pushl  0x8(%eax)
  80b9fa:	e8 1c d5 ff ff       	call   808f1b <udp_recv>
  80b9ff:	83 c4 10             	add    $0x10,%esp
  80ba02:	eb 21                	jmp    80ba25 <do_newconn+0xe2>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80ba04:	e8 f2 a8 ff ff       	call   8062fb <tcp_new>
  80ba09:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80ba0c:	8b 03                	mov    (%ebx),%eax
  80ba0e:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ba12:	75 06                	jne    80ba1a <do_newconn+0xd7>
       msg->conn->err = ERR_MEM;
  80ba14:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80ba18:	eb 0b                	jmp    80ba25 <do_newconn+0xe2>
       break;
     }
     setup_tcp(msg->conn);
  80ba1a:	e8 f1 f9 ff ff       	call   80b410 <setup_tcp>
  80ba1f:	eb 04                	jmp    80ba25 <do_newconn+0xe2>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80ba21:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80ba25:	83 ec 0c             	sub    $0xc,%esp
  80ba28:	8b 03                	mov    (%ebx),%eax
  80ba2a:	ff 70 10             	pushl  0x10(%eax)
  80ba2d:	e8 ab e5 ff ff       	call   809fdd <sys_sem_signal>
}
  80ba32:	83 c4 10             	add    $0x10,%esp
  80ba35:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ba38:	5b                   	pop    %ebx
  80ba39:	5e                   	pop    %esi
  80ba3a:	5d                   	pop    %ebp
  80ba3b:	c3                   	ret    

0080ba3c <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80ba3c:	55                   	push   %ebp
  80ba3d:	89 e5                	mov    %esp,%ebp
  80ba3f:	53                   	push   %ebx
  80ba40:	83 ec 10             	sub    $0x10,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80ba43:	6a 07                	push   $0x7
  80ba45:	e8 17 8a ff ff       	call   804461 <memp_malloc>
  if (conn == NULL) {
  80ba4a:	83 c4 10             	add    $0x10,%esp
  80ba4d:	85 c0                	test   %eax,%eax
  80ba4f:	0f 84 96 00 00 00    	je     80baeb <netconn_alloc+0xaf>
  80ba55:	89 c3                	mov    %eax,%ebx
    return NULL;
  }

  conn->err = ERR_OK;
  80ba57:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80ba5b:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba5e:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80ba60:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80ba67:	83 ec 0c             	sub    $0xc,%esp
  80ba6a:	6a 00                	push   $0x0
  80ba6c:	e8 c0 e2 ff ff       	call   809d31 <sys_sem_new>
  80ba71:	89 43 10             	mov    %eax,0x10(%ebx)
  80ba74:	83 c4 10             	add    $0x10,%esp
  80ba77:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ba7a:	75 15                	jne    80ba91 <netconn_alloc+0x55>
    memp_free(MEMP_NETCONN, conn);
  80ba7c:	83 ec 08             	sub    $0x8,%esp
  80ba7f:	53                   	push   %ebx
  80ba80:	6a 07                	push   $0x7
  80ba82:	e8 30 8a ff ff       	call   8044b7 <memp_free>
    return NULL;
  80ba87:	83 c4 10             	add    $0x10,%esp
  80ba8a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba8f:	eb 5f                	jmp    80baf0 <netconn_alloc+0xb4>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80ba91:	83 ec 0c             	sub    $0xc,%esp
  80ba94:	6a 00                	push   $0x0
  80ba96:	e8 3f e4 ff ff       	call   809eda <sys_mbox_new>
  80ba9b:	89 43 14             	mov    %eax,0x14(%ebx)
  80ba9e:	83 c4 10             	add    $0x10,%esp
  80baa1:	83 f8 ff             	cmp    $0xffffffff,%eax
  80baa4:	75 20                	jne    80bac6 <netconn_alloc+0x8a>
    sys_sem_free(conn->op_completed);
  80baa6:	83 ec 0c             	sub    $0xc,%esp
  80baa9:	ff 73 10             	pushl  0x10(%ebx)
  80baac:	e8 01 e3 ff ff       	call   809db2 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bab1:	83 c4 08             	add    $0x8,%esp
  80bab4:	53                   	push   %ebx
  80bab5:	6a 07                	push   $0x7
  80bab7:	e8 fb 89 ff ff       	call   8044b7 <memp_free>
    return NULL;
  80babc:	83 c4 10             	add    $0x10,%esp
  80babf:	b8 00 00 00 00       	mov    $0x0,%eax
  80bac4:	eb 2a                	jmp    80baf0 <netconn_alloc+0xb4>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80bac6:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bacd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80bad4:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80badb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bade:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bae1:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80bae7:	89 d8                	mov    %ebx,%eax
  80bae9:	eb 05                	jmp    80baf0 <netconn_alloc+0xb4>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80baeb:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80baf0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80baf3:	c9                   	leave  
  80baf4:	c3                   	ret    

0080baf5 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80baf5:	55                   	push   %ebp
  80baf6:	89 e5                	mov    %esp,%ebp
  80baf8:	56                   	push   %esi
  80baf9:	53                   	push   %ebx
  80bafa:	83 ec 10             	sub    $0x10,%esp
  80bafd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bb00:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bb04:	74 17                	je     80bb1d <netconn_free+0x28>
  80bb06:	83 ec 04             	sub    $0x4,%esp
  80bb09:	68 e8 2d 81 00       	push   $0x812de8
  80bb0e:	68 26 02 00 00       	push   $0x226
  80bb13:	68 42 2e 81 00       	push   $0x812e42
  80bb18:	e8 2d 29 00 00       	call   80e44a <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb1d:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bb20:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bb24:	75 2a                	jne    80bb50 <netconn_free+0x5b>
  80bb26:	eb 51                	jmp    80bb79 <netconn_free+0x84>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80bb28:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bb2b:	75 15                	jne    80bb42 <netconn_free+0x4d>
        if(mem != NULL) {
  80bb2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bb30:	85 c0                	test   %eax,%eax
  80bb32:	74 1c                	je     80bb50 <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80bb34:	83 ec 0c             	sub    $0xc,%esp
  80bb37:	50                   	push   %eax
  80bb38:	e8 ed 8c ff ff       	call   80482a <pbuf_free>
  80bb3d:	83 c4 10             	add    $0x10,%esp
  80bb40:	eb 0e                	jmp    80bb50 <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80bb42:	83 ec 0c             	sub    $0xc,%esp
  80bb45:	ff 75 f4             	pushl  -0xc(%ebp)
  80bb48:	e8 ab 69 ff ff       	call   8024f8 <netbuf_delete>
  80bb4d:	83 c4 10             	add    $0x10,%esp
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb50:	83 ec 08             	sub    $0x8,%esp
  80bb53:	56                   	push   %esi
  80bb54:	ff 73 14             	pushl  0x14(%ebx)
  80bb57:	e8 dc e7 ff ff       	call   80a338 <sys_arch_mbox_tryfetch>
  80bb5c:	83 c4 10             	add    $0x10,%esp
  80bb5f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb62:	75 c4                	jne    80bb28 <netconn_free+0x33>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80bb64:	83 ec 0c             	sub    $0xc,%esp
  80bb67:	ff 73 14             	pushl  0x14(%ebx)
  80bb6a:	e8 cc e2 ff ff       	call   809e3b <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bb6f:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bb76:	83 c4 10             	add    $0x10,%esp
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb79:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bb7c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bb80:	75 10                	jne    80bb92 <netconn_free+0x9d>
  80bb82:	eb 37                	jmp    80bbbb <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80bb84:	83 ec 0c             	sub    $0xc,%esp
  80bb87:	ff 75 f4             	pushl  -0xc(%ebp)
  80bb8a:	e8 83 f0 ff ff       	call   80ac12 <netconn_delete>
  80bb8f:	83 c4 10             	add    $0x10,%esp
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb92:	83 ec 08             	sub    $0x8,%esp
  80bb95:	56                   	push   %esi
  80bb96:	ff 73 18             	pushl  0x18(%ebx)
  80bb99:	e8 9a e7 ff ff       	call   80a338 <sys_arch_mbox_tryfetch>
  80bb9e:	83 c4 10             	add    $0x10,%esp
  80bba1:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bba4:	75 de                	jne    80bb84 <netconn_free+0x8f>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80bba6:	83 ec 0c             	sub    $0xc,%esp
  80bba9:	ff 73 18             	pushl  0x18(%ebx)
  80bbac:	e8 8a e2 ff ff       	call   809e3b <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bbb1:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bbb8:	83 c4 10             	add    $0x10,%esp
  }

  sys_sem_free(conn->op_completed);
  80bbbb:	83 ec 0c             	sub    $0xc,%esp
  80bbbe:	ff 73 10             	pushl  0x10(%ebx)
  80bbc1:	e8 ec e1 ff ff       	call   809db2 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bbc6:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80bbcd:	83 c4 08             	add    $0x8,%esp
  80bbd0:	53                   	push   %ebx
  80bbd1:	6a 07                	push   $0x7
  80bbd3:	e8 df 88 ff ff       	call   8044b7 <memp_free>
}
  80bbd8:	83 c4 10             	add    $0x10,%esp
  80bbdb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bbde:	5b                   	pop    %ebx
  80bbdf:	5e                   	pop    %esi
  80bbe0:	5d                   	pop    %ebp
  80bbe1:	c3                   	ret    

0080bbe2 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80bbe2:	55                   	push   %ebp
  80bbe3:	89 e5                	mov    %esp,%ebp
  80bbe5:	57                   	push   %edi
  80bbe6:	56                   	push   %esi
  80bbe7:	53                   	push   %ebx
  80bbe8:	83 ec 0c             	sub    $0xc,%esp
  80bbeb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bbee:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bbf1:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bbf5:	75 17                	jne    80bc0e <accept_function+0x2c>
  80bbf7:	83 ec 04             	sub    $0x4,%esp
  80bbfa:	68 18 2e 81 00       	push   $0x812e18
  80bbff:	68 65 01 00 00       	push   $0x165
  80bc04:	68 42 2e 81 00       	push   $0x812e42
  80bc09:	e8 3c 28 00 00       	call   80e44a <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80bc0e:	83 ec 08             	sub    $0x8,%esp
  80bc11:	ff 73 2c             	pushl  0x2c(%ebx)
  80bc14:	ff 33                	pushl  (%ebx)
  80bc16:	e8 21 fe ff ff       	call   80ba3c <netconn_alloc>
  80bc1b:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bc1d:	83 c4 10             	add    $0x10,%esp
  80bc20:	85 c0                	test   %eax,%eax
  80bc22:	74 53                	je     80bc77 <accept_function+0x95>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80bc24:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc27:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bc2a:	89 f0                	mov    %esi,%eax
  80bc2c:	e8 df f7 ff ff       	call   80b410 <setup_tcp>
  newconn->err = err;
  80bc31:	89 f8                	mov    %edi,%eax
  80bc33:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bc36:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bc39:	85 c0                	test   %eax,%eax
  80bc3b:	74 0d                	je     80bc4a <accept_function+0x68>
  80bc3d:	83 ec 04             	sub    $0x4,%esp
  80bc40:	6a 00                	push   $0x0
  80bc42:	6a 00                	push   $0x0
  80bc44:	53                   	push   %ebx
  80bc45:	ff d0                	call   *%eax
  80bc47:	83 c4 10             	add    $0x10,%esp

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bc4a:	83 ec 08             	sub    $0x8,%esp
  80bc4d:	56                   	push   %esi
  80bc4e:	ff 73 18             	pushl  0x18(%ebx)
  80bc51:	e8 03 e5 ff ff       	call   80a159 <sys_mbox_trypost>
  80bc56:	83 c4 10             	add    $0x10,%esp
  80bc59:	84 c0                	test   %al,%al
  80bc5b:	74 1f                	je     80bc7c <accept_function+0x9a>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80bc5d:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bc64:	83 ec 0c             	sub    $0xc,%esp
  80bc67:	56                   	push   %esi
  80bc68:	e8 88 fe ff ff       	call   80baf5 <netconn_free>
    return ERR_MEM;
  80bc6d:	83 c4 10             	add    $0x10,%esp
  80bc70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bc75:	eb 05                	jmp    80bc7c <accept_function+0x9a>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80bc77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
}
  80bc7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bc7f:	5b                   	pop    %ebx
  80bc80:	5e                   	pop    %esi
  80bc81:	5f                   	pop    %edi
  80bc82:	5d                   	pop    %ebp
  80bc83:	c3                   	ret    

0080bc84 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80bc84:	55                   	push   %ebp
  80bc85:	89 e5                	mov    %esp,%ebp
  80bc87:	53                   	push   %ebx
  80bc88:	83 ec 04             	sub    $0x4,%esp
  80bc8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bc8e:	8b 13                	mov    (%ebx),%edx
  80bc90:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bc93:	85 c9                	test   %ecx,%ecx
  80bc95:	74 4f                	je     80bce6 <do_delconn+0x62>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bc97:	8b 02                	mov    (%edx),%eax
  80bc99:	25 f0 00 00 00       	and    $0xf0,%eax
  80bc9e:	83 f8 20             	cmp    $0x20,%eax
  80bca1:	74 1a                	je     80bcbd <do_delconn+0x39>
  80bca3:	83 f8 40             	cmp    $0x40,%eax
  80bca6:	74 07                	je     80bcaf <do_delconn+0x2b>
  80bca8:	83 f8 10             	cmp    $0x10,%eax
  80bcab:	75 39                	jne    80bce6 <do_delconn+0x62>
  80bcad:	eb 27                	jmp    80bcd6 <do_delconn+0x52>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80bcaf:	83 ec 0c             	sub    $0xc,%esp
  80bcb2:	51                   	push   %ecx
  80bcb3:	e8 d3 21 00 00       	call   80de8b <raw_remove>
      break;
  80bcb8:	83 c4 10             	add    $0x10,%esp
  80bcbb:	eb 29                	jmp    80bce6 <do_delconn+0x62>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80bcbd:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bcc4:	83 ec 0c             	sub    $0xc,%esp
  80bcc7:	8b 03                	mov    (%ebx),%eax
  80bcc9:	ff 70 08             	pushl  0x8(%eax)
  80bccc:	e8 5e d2 ff ff       	call   808f2f <udp_remove>
      break;
  80bcd1:	83 c4 10             	add    $0x10,%esp
  80bcd4:	eb 10                	jmp    80bce6 <do_delconn+0x62>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80bcd6:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bcdd:	8b 03                	mov    (%ebx),%eax
  80bcdf:	e8 e0 f9 ff ff       	call   80b6c4 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80bce4:	eb 42                	jmp    80bd28 <do_delconn+0xa4>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bce6:	8b 13                	mov    (%ebx),%edx
  80bce8:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bceb:	85 c0                	test   %eax,%eax
  80bced:	74 23                	je     80bd12 <do_delconn+0x8e>
  80bcef:	83 ec 04             	sub    $0x4,%esp
  80bcf2:	6a 00                	push   $0x0
  80bcf4:	6a 00                	push   $0x0
  80bcf6:	52                   	push   %edx
  80bcf7:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bcf9:	8b 13                	mov    (%ebx),%edx
  80bcfb:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bcfe:	83 c4 10             	add    $0x10,%esp
  80bd01:	85 c0                	test   %eax,%eax
  80bd03:	74 0d                	je     80bd12 <do_delconn+0x8e>
  80bd05:	83 ec 04             	sub    $0x4,%esp
  80bd08:	6a 00                	push   $0x0
  80bd0a:	6a 02                	push   $0x2
  80bd0c:	52                   	push   %edx
  80bd0d:	ff d0                	call   *%eax
  80bd0f:	83 c4 10             	add    $0x10,%esp

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bd12:	8b 03                	mov    (%ebx),%eax
  80bd14:	8b 40 10             	mov    0x10(%eax),%eax
  80bd17:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd1a:	74 0c                	je     80bd28 <do_delconn+0xa4>
    sys_sem_signal(msg->conn->op_completed);
  80bd1c:	83 ec 0c             	sub    $0xc,%esp
  80bd1f:	50                   	push   %eax
  80bd20:	e8 b8 e2 ff ff       	call   809fdd <sys_sem_signal>
  80bd25:	83 c4 10             	add    $0x10,%esp
  }
}
  80bd28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bd2b:	c9                   	leave  
  80bd2c:	c3                   	ret    

0080bd2d <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80bd2d:	55                   	push   %ebp
  80bd2e:	89 e5                	mov    %esp,%ebp
  80bd30:	56                   	push   %esi
  80bd31:	53                   	push   %ebx
  80bd32:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bd35:	8b 33                	mov    (%ebx),%esi
  80bd37:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bd3b:	7c 69                	jl     80bda6 <do_bind+0x79>
    if (msg->conn->pcb.tcp != NULL) {
  80bd3d:	8b 56 08             	mov    0x8(%esi),%edx
  80bd40:	85 d2                	test   %edx,%edx
  80bd42:	74 5e                	je     80bda2 <do_bind+0x75>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd44:	8b 06                	mov    (%esi),%eax
  80bd46:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd4b:	83 f8 20             	cmp    $0x20,%eax
  80bd4e:	74 20                	je     80bd70 <do_bind+0x43>
  80bd50:	83 f8 40             	cmp    $0x40,%eax
  80bd53:	74 07                	je     80bd5c <do_bind+0x2f>
  80bd55:	83 f8 10             	cmp    $0x10,%eax
  80bd58:	75 4c                	jne    80bda6 <do_bind+0x79>
  80bd5a:	eb 2d                	jmp    80bd89 <do_bind+0x5c>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bd5c:	83 ec 08             	sub    $0x8,%esp
  80bd5f:	ff 73 04             	pushl  0x4(%ebx)
  80bd62:	52                   	push   %edx
  80bd63:	e8 a6 1f 00 00       	call   80dd0e <raw_bind>
  80bd68:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd6b:	83 c4 10             	add    $0x10,%esp
  80bd6e:	eb 36                	jmp    80bda6 <do_bind+0x79>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd70:	83 ec 04             	sub    $0x4,%esp
  80bd73:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd77:	50                   	push   %eax
  80bd78:	ff 73 04             	pushl  0x4(%ebx)
  80bd7b:	52                   	push   %edx
  80bd7c:	e8 6c ce ff ff       	call   808bed <udp_bind>
  80bd81:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd84:	83 c4 10             	add    $0x10,%esp
  80bd87:	eb 1d                	jmp    80bda6 <do_bind+0x79>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd89:	83 ec 04             	sub    $0x4,%esp
  80bd8c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd90:	50                   	push   %eax
  80bd91:	ff 73 04             	pushl  0x4(%ebx)
  80bd94:	52                   	push   %edx
  80bd95:	e8 22 96 ff ff       	call   8053bc <tcp_bind>
  80bd9a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd9d:	83 c4 10             	add    $0x10,%esp
  80bda0:	eb 04                	jmp    80bda6 <do_bind+0x79>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80bda2:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bda6:	83 ec 0c             	sub    $0xc,%esp
  80bda9:	8b 03                	mov    (%ebx),%eax
  80bdab:	ff 70 10             	pushl  0x10(%eax)
  80bdae:	e8 2a e2 ff ff       	call   809fdd <sys_sem_signal>
}
  80bdb3:	83 c4 10             	add    $0x10,%esp
  80bdb6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bdb9:	5b                   	pop    %ebx
  80bdba:	5e                   	pop    %esi
  80bdbb:	5d                   	pop    %ebp
  80bdbc:	c3                   	ret    

0080bdbd <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80bdbd:	55                   	push   %ebp
  80bdbe:	89 e5                	mov    %esp,%ebp
  80bdc0:	56                   	push   %esi
  80bdc1:	53                   	push   %ebx
  80bdc2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bdc5:	8b 33                	mov    (%ebx),%esi
  80bdc7:	8b 56 08             	mov    0x8(%esi),%edx
  80bdca:	85 d2                	test   %edx,%edx
  80bdcc:	75 13                	jne    80bde1 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80bdce:	83 ec 0c             	sub    $0xc,%esp
  80bdd1:	ff 76 10             	pushl  0x10(%esi)
  80bdd4:	e8 04 e2 ff ff       	call   809fdd <sys_sem_signal>
    return;
  80bdd9:	83 c4 10             	add    $0x10,%esp
  80bddc:	e9 8a 00 00 00       	jmp    80be6b <do_connect+0xae>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bde1:	8b 06                	mov    (%esi),%eax
  80bde3:	25 f0 00 00 00       	and    $0xf0,%eax
  80bde8:	83 f8 20             	cmp    $0x20,%eax
  80bdeb:	74 2d                	je     80be1a <do_connect+0x5d>
  80bded:	83 f8 40             	cmp    $0x40,%eax
  80bdf0:	74 07                	je     80bdf9 <do_connect+0x3c>
  80bdf2:	83 f8 10             	cmp    $0x10,%eax
  80bdf5:	75 74                	jne    80be6b <do_connect+0xae>
  80bdf7:	eb 47                	jmp    80be40 <do_connect+0x83>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bdf9:	83 ec 08             	sub    $0x8,%esp
  80bdfc:	ff 73 04             	pushl  0x4(%ebx)
  80bdff:	52                   	push   %edx
  80be00:	e8 28 1f 00 00       	call   80dd2d <raw_connect>
  80be05:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80be08:	83 c4 04             	add    $0x4,%esp
  80be0b:	8b 03                	mov    (%ebx),%eax
  80be0d:	ff 70 10             	pushl  0x10(%eax)
  80be10:	e8 c8 e1 ff ff       	call   809fdd <sys_sem_signal>
    break;
  80be15:	83 c4 10             	add    $0x10,%esp
  80be18:	eb 51                	jmp    80be6b <do_connect+0xae>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be1a:	83 ec 04             	sub    $0x4,%esp
  80be1d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be21:	50                   	push   %eax
  80be22:	ff 73 04             	pushl  0x4(%ebx)
  80be25:	52                   	push   %edx
  80be26:	e8 64 d0 ff ff       	call   808e8f <udp_connect>
  80be2b:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80be2e:	83 c4 04             	add    $0x4,%esp
  80be31:	8b 03                	mov    (%ebx),%eax
  80be33:	ff 70 10             	pushl  0x10(%eax)
  80be36:	e8 a2 e1 ff ff       	call   809fdd <sys_sem_signal>
    break;
  80be3b:	83 c4 10             	add    $0x10,%esp
  80be3e:	eb 2b                	jmp    80be6b <do_connect+0xae>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80be40:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80be47:	8b 03                	mov    (%ebx),%eax
  80be49:	e8 c2 f5 ff ff       	call   80b410 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80be4e:	8b 33                	mov    (%ebx),%esi
  80be50:	68 63 b4 80 00       	push   $0x80b463
  80be55:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be59:	50                   	push   %eax
  80be5a:	ff 73 04             	pushl  0x4(%ebx)
  80be5d:	ff 76 08             	pushl  0x8(%esi)
  80be60:	e8 de a4 ff ff       	call   806343 <tcp_connect>
  80be65:	88 46 0c             	mov    %al,0xc(%esi)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  80be68:	83 c4 10             	add    $0x10,%esp
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80be6b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be6e:	5b                   	pop    %ebx
  80be6f:	5e                   	pop    %esi
  80be70:	5d                   	pop    %ebp
  80be71:	c3                   	ret    

0080be72 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80be72:	55                   	push   %ebp
  80be73:	89 e5                	mov    %esp,%ebp
  80be75:	53                   	push   %ebx
  80be76:	83 ec 04             	sub    $0x4,%esp
  80be79:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80be7c:	8b 13                	mov    (%ebx),%edx
  80be7e:	8b 02                	mov    (%edx),%eax
  80be80:	25 f0 00 00 00       	and    $0xf0,%eax
  80be85:	83 f8 20             	cmp    $0x20,%eax
  80be88:	75 0e                	jne    80be98 <do_disconnect+0x26>
    udp_disconnect(msg->conn->pcb.udp);
  80be8a:	83 ec 0c             	sub    $0xc,%esp
  80be8d:	ff 72 08             	pushl  0x8(%edx)
  80be90:	e8 6b d0 ff ff       	call   808f00 <udp_disconnect>
  80be95:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80be98:	83 ec 0c             	sub    $0xc,%esp
  80be9b:	8b 03                	mov    (%ebx),%eax
  80be9d:	ff 70 10             	pushl  0x10(%eax)
  80bea0:	e8 38 e1 ff ff       	call   809fdd <sys_sem_signal>
}
  80bea5:	83 c4 10             	add    $0x10,%esp
  80bea8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80beab:	c9                   	leave  
  80beac:	c3                   	ret    

0080bead <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80bead:	55                   	push   %ebp
  80beae:	89 e5                	mov    %esp,%ebp
  80beb0:	57                   	push   %edi
  80beb1:	56                   	push   %esi
  80beb2:	53                   	push   %ebx
  80beb3:	83 ec 0c             	sub    $0xc,%esp
  80beb6:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80beb9:	8b 03                	mov    (%ebx),%eax
  80bebb:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bebf:	0f 8c bc 00 00 00    	jl     80bf81 <do_listen+0xd4>
    if (msg->conn->pcb.tcp != NULL) {
  80bec5:	8b 50 08             	mov    0x8(%eax),%edx
  80bec8:	85 d2                	test   %edx,%edx
  80beca:	0f 84 b1 00 00 00    	je     80bf81 <do_listen+0xd4>
      if (msg->conn->type == NETCONN_TCP) {
  80bed0:	83 38 10             	cmpl   $0x10,(%eax)
  80bed3:	0f 85 a8 00 00 00    	jne    80bf81 <do_listen+0xd4>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80bed9:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80bedd:	0f 85 9a 00 00 00    	jne    80bf7d <do_listen+0xd0>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bee3:	83 ec 08             	sub    $0x8,%esp
  80bee6:	68 ff 00 00 00       	push   $0xff
  80beeb:	52                   	push   %edx
  80beec:	e8 5b 96 ff ff       	call   80554c <tcp_listen_with_backlog>
  80bef1:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80bef3:	83 c4 10             	add    $0x10,%esp
  80bef6:	85 c0                	test   %eax,%eax
  80bef8:	75 08                	jne    80bf02 <do_listen+0x55>
            msg->conn->err = ERR_MEM;
  80befa:	8b 03                	mov    (%ebx),%eax
  80befc:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bf00:	eb 7f                	jmp    80bf81 <do_listen+0xd4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80bf02:	8b 03                	mov    (%ebx),%eax
  80bf04:	8b 40 14             	mov    0x14(%eax),%eax
  80bf07:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf0a:	74 15                	je     80bf21 <do_listen+0x74>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80bf0c:	83 ec 0c             	sub    $0xc,%esp
  80bf0f:	50                   	push   %eax
  80bf10:	e8 26 df ff ff       	call   809e3b <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80bf15:	8b 03                	mov    (%ebx),%eax
  80bf17:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80bf1e:	83 c4 10             	add    $0x10,%esp
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80bf21:	8b 3b                	mov    (%ebx),%edi
  80bf23:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80bf27:	75 1b                	jne    80bf44 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80bf29:	83 ec 0c             	sub    $0xc,%esp
  80bf2c:	6a 00                	push   $0x0
  80bf2e:	e8 a7 df ff ff       	call   809eda <sys_mbox_new>
  80bf33:	89 47 18             	mov    %eax,0x18(%edi)
  80bf36:	83 c4 10             	add    $0x10,%esp
  80bf39:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf3c:	75 06                	jne    80bf44 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80bf3e:	8b 03                	mov    (%ebx),%eax
  80bf40:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80bf44:	8b 03                	mov    (%ebx),%eax
  80bf46:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bf4a:	75 35                	jne    80bf81 <do_listen+0xd4>
              msg->conn->state = NETCONN_LISTEN;
  80bf4c:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80bf53:	8b 03                	mov    (%ebx),%eax
  80bf55:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80bf58:	8b 03                	mov    (%ebx),%eax
  80bf5a:	83 ec 08             	sub    $0x8,%esp
  80bf5d:	50                   	push   %eax
  80bf5e:	ff 70 08             	pushl  0x8(%eax)
  80bf61:	e8 c4 98 ff ff       	call   80582a <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80bf66:	83 c4 08             	add    $0x8,%esp
  80bf69:	68 e2 bb 80 00       	push   $0x80bbe2
  80bf6e:	8b 03                	mov    (%ebx),%eax
  80bf70:	ff 70 08             	pushl  0x8(%eax)
  80bf73:	e8 f3 98 ff ff       	call   80586b <tcp_accept>
  80bf78:	83 c4 10             	add    $0x10,%esp
  80bf7b:	eb 04                	jmp    80bf81 <do_listen+0xd4>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80bf7d:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80bf81:	83 ec 0c             	sub    $0xc,%esp
  80bf84:	8b 03                	mov    (%ebx),%eax
  80bf86:	ff 70 10             	pushl  0x10(%eax)
  80bf89:	e8 4f e0 ff ff       	call   809fdd <sys_sem_signal>
}
  80bf8e:	83 c4 10             	add    $0x10,%esp
  80bf91:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf94:	5b                   	pop    %ebx
  80bf95:	5e                   	pop    %esi
  80bf96:	5f                   	pop    %edi
  80bf97:	5d                   	pop    %ebp
  80bf98:	c3                   	ret    

0080bf99 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80bf99:	55                   	push   %ebp
  80bf9a:	89 e5                	mov    %esp,%ebp
  80bf9c:	57                   	push   %edi
  80bf9d:	56                   	push   %esi
  80bf9e:	53                   	push   %ebx
  80bf9f:	83 ec 0c             	sub    $0xc,%esp
  80bfa2:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bfa5:	8b 1e                	mov    (%esi),%ebx
  80bfa7:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80bfab:	7c 7a                	jl     80c027 <do_send+0x8e>
    if (msg->conn->pcb.tcp != NULL) {
  80bfad:	8b 53 08             	mov    0x8(%ebx),%edx
  80bfb0:	85 d2                	test   %edx,%edx
  80bfb2:	74 73                	je     80c027 <do_send+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bfb4:	8b 03                	mov    (%ebx),%eax
  80bfb6:	25 f0 00 00 00       	and    $0xf0,%eax
  80bfbb:	83 f8 20             	cmp    $0x20,%eax
  80bfbe:	74 36                	je     80bff6 <do_send+0x5d>
  80bfc0:	83 f8 40             	cmp    $0x40,%eax
  80bfc3:	75 62                	jne    80c027 <do_send+0x8e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80bfc5:	8b 46 04             	mov    0x4(%esi),%eax
  80bfc8:	8b 48 08             	mov    0x8(%eax),%ecx
  80bfcb:	85 c9                	test   %ecx,%ecx
  80bfcd:	75 13                	jne    80bfe2 <do_send+0x49>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80bfcf:	83 ec 08             	sub    $0x8,%esp
  80bfd2:	ff 30                	pushl  (%eax)
  80bfd4:	52                   	push   %edx
  80bfd5:	e8 99 1e 00 00       	call   80de73 <raw_send>
  80bfda:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfdd:	83 c4 10             	add    $0x10,%esp
  80bfe0:	eb 45                	jmp    80c027 <do_send+0x8e>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80bfe2:	83 ec 04             	sub    $0x4,%esp
  80bfe5:	51                   	push   %ecx
  80bfe6:	ff 30                	pushl  (%eax)
  80bfe8:	52                   	push   %edx
  80bfe9:	e8 73 1d 00 00       	call   80dd61 <raw_sendto>
  80bfee:	88 43 0c             	mov    %al,0xc(%ebx)
  80bff1:	83 c4 10             	add    $0x10,%esp
  80bff4:	eb 31                	jmp    80c027 <do_send+0x8e>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80bff6:	8b 46 04             	mov    0x4(%esi),%eax
  80bff9:	8b 48 08             	mov    0x8(%eax),%ecx
  80bffc:	85 c9                	test   %ecx,%ecx
  80bffe:	75 13                	jne    80c013 <do_send+0x7a>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c000:	83 ec 08             	sub    $0x8,%esp
  80c003:	ff 30                	pushl  (%eax)
  80c005:	52                   	push   %edx
  80c006:	e8 67 ce ff ff       	call   808e72 <udp_send>
  80c00b:	88 43 0c             	mov    %al,0xc(%ebx)
  80c00e:	83 c4 10             	add    $0x10,%esp
  80c011:	eb 14                	jmp    80c027 <do_send+0x8e>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c013:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c017:	57                   	push   %edi
  80c018:	51                   	push   %ecx
  80c019:	ff 30                	pushl  (%eax)
  80c01b:	52                   	push   %edx
  80c01c:	e8 11 ce ff ff       	call   808e32 <udp_sendto>
  80c021:	88 43 0c             	mov    %al,0xc(%ebx)
  80c024:	83 c4 10             	add    $0x10,%esp
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c027:	83 ec 0c             	sub    $0xc,%esp
  80c02a:	8b 06                	mov    (%esi),%eax
  80c02c:	ff 70 10             	pushl  0x10(%eax)
  80c02f:	e8 a9 df ff ff       	call   809fdd <sys_sem_signal>
}
  80c034:	83 c4 10             	add    $0x10,%esp
  80c037:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c03a:	5b                   	pop    %ebx
  80c03b:	5e                   	pop    %esi
  80c03c:	5f                   	pop    %edi
  80c03d:	5d                   	pop    %ebp
  80c03e:	c3                   	ret    

0080c03f <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80c03f:	55                   	push   %ebp
  80c040:	89 e5                	mov    %esp,%ebp
  80c042:	53                   	push   %ebx
  80c043:	83 ec 04             	sub    $0x4,%esp
  80c046:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c049:	8b 03                	mov    (%ebx),%eax
  80c04b:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c04f:	7c 1d                	jl     80c06e <do_recv+0x2f>
    if (msg->conn->pcb.tcp != NULL) {
  80c051:	8b 50 08             	mov    0x8(%eax),%edx
  80c054:	85 d2                	test   %edx,%edx
  80c056:	74 16                	je     80c06e <do_recv+0x2f>
      if (msg->conn->type == NETCONN_TCP) {
  80c058:	83 38 10             	cmpl   $0x10,(%eax)
  80c05b:	75 11                	jne    80c06e <do_recv+0x2f>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c05d:	83 ec 08             	sub    $0x8,%esp
  80c060:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c064:	50                   	push   %eax
  80c065:	52                   	push   %edx
  80c066:	e8 00 96 ff ff       	call   80566b <tcp_recved>
  80c06b:	83 c4 10             	add    $0x10,%esp
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c06e:	83 ec 0c             	sub    $0xc,%esp
  80c071:	8b 03                	mov    (%ebx),%eax
  80c073:	ff 70 10             	pushl  0x10(%eax)
  80c076:	e8 62 df ff ff       	call   809fdd <sys_sem_signal>
}
  80c07b:	83 c4 10             	add    $0x10,%esp
  80c07e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c081:	c9                   	leave  
  80c082:	c3                   	ret    

0080c083 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c083:	55                   	push   %ebp
  80c084:	89 e5                	mov    %esp,%ebp
  80c086:	83 ec 08             	sub    $0x8,%esp
  80c089:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c08c:	8b 02                	mov    (%edx),%eax
  80c08e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c092:	7c 2d                	jl     80c0c1 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c094:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c098:	74 23                	je     80c0bd <do_write+0x3a>
  80c09a:	83 38 10             	cmpl   $0x10,(%eax)
  80c09d:	75 1e                	jne    80c0bd <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80c09f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80c0a6:	8b 02                	mov    (%edx),%eax
  80c0a8:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c0ab:	8b 02                	mov    (%edx),%eax
  80c0ad:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80c0b4:	8b 02                	mov    (%edx),%eax
  80c0b6:	e8 c0 f4 ff ff       	call   80b57b <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80c0bb:	eb 14                	jmp    80c0d1 <do_write+0x4e>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c0bd:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c0c1:	83 ec 0c             	sub    $0xc,%esp
  80c0c4:	8b 02                	mov    (%edx),%eax
  80c0c6:	ff 70 10             	pushl  0x10(%eax)
  80c0c9:	e8 0f df ff ff       	call   809fdd <sys_sem_signal>
  80c0ce:	83 c4 10             	add    $0x10,%esp
}
  80c0d1:	c9                   	leave  
  80c0d2:	c3                   	ret    

0080c0d3 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c0d3:	55                   	push   %ebp
  80c0d4:	89 e5                	mov    %esp,%ebp
  80c0d6:	83 ec 08             	sub    $0x8,%esp
  80c0d9:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c0dc:	8b 08                	mov    (%eax),%ecx
  80c0de:	8b 51 08             	mov    0x8(%ecx),%edx
  80c0e1:	85 d2                	test   %edx,%edx
  80c0e3:	0f 84 98 00 00 00    	je     80c181 <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c0e9:	8b 48 04             	mov    0x4(%eax),%ecx
  80c0ec:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0f0:	74 06                	je     80c0f8 <do_getaddr+0x25>
  80c0f2:	8b 12                	mov    (%edx),%edx
  80c0f4:	89 11                	mov    %edx,(%ecx)
  80c0f6:	eb 05                	jmp    80c0fd <do_getaddr+0x2a>
  80c0f8:	8b 52 04             	mov    0x4(%edx),%edx
  80c0fb:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c0fd:	8b 08                	mov    (%eax),%ecx
  80c0ff:	8b 11                	mov    (%ecx),%edx
  80c101:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c107:	83 fa 20             	cmp    $0x20,%edx
  80c10a:	74 27                	je     80c133 <do_getaddr+0x60>
  80c10c:	83 fa 40             	cmp    $0x40,%edx
  80c10f:	74 07                	je     80c118 <do_getaddr+0x45>
  80c111:	83 fa 10             	cmp    $0x10,%edx
  80c114:	75 6f                	jne    80c185 <do_getaddr+0xb2>
  80c116:	eb 4b                	jmp    80c163 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80c118:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c11c:	74 0f                	je     80c12d <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c11e:	8b 50 08             	mov    0x8(%eax),%edx
  80c121:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c124:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c128:	66 89 0a             	mov    %cx,(%edx)
  80c12b:	eb 58                	jmp    80c185 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80c12d:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c131:	eb 52                	jmp    80c185 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80c133:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c137:	74 0f                	je     80c148 <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c139:	8b 50 08             	mov    0x8(%eax),%edx
  80c13c:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c13f:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c143:	66 89 0a             	mov    %cx,(%edx)
  80c146:	eb 3d                	jmp    80c185 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c148:	8b 51 08             	mov    0x8(%ecx),%edx
  80c14b:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c14f:	75 06                	jne    80c157 <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80c151:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c155:	eb 2e                	jmp    80c185 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c157:	8b 48 08             	mov    0x8(%eax),%ecx
  80c15a:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c15e:	66 89 11             	mov    %dx,(%ecx)
  80c161:	eb 22                	jmp    80c185 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c163:	8b 50 08             	mov    0x8(%eax),%edx
  80c166:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c16a:	74 09                	je     80c175 <do_getaddr+0xa2>
  80c16c:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c16f:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80c173:	eb 07                	jmp    80c17c <do_getaddr+0xa9>
  80c175:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c178:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80c17c:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c17f:	eb 04                	jmp    80c185 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80c181:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80c185:	83 ec 0c             	sub    $0xc,%esp
  80c188:	8b 00                	mov    (%eax),%eax
  80c18a:	ff 70 10             	pushl  0x10(%eax)
  80c18d:	e8 4b de ff ff       	call   809fdd <sys_sem_signal>
}
  80c192:	83 c4 10             	add    $0x10,%esp
  80c195:	c9                   	leave  
  80c196:	c3                   	ret    

0080c197 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c197:	55                   	push   %ebp
  80c198:	89 e5                	mov    %esp,%ebp
  80c19a:	83 ec 08             	sub    $0x8,%esp
  80c19d:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c1a0:	8b 02                	mov    (%edx),%eax
  80c1a2:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c1a6:	74 15                	je     80c1bd <do_close+0x26>
  80c1a8:	83 38 10             	cmpl   $0x10,(%eax)
  80c1ab:	75 10                	jne    80c1bd <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80c1ad:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c1b4:	8b 02                	mov    (%edx),%eax
  80c1b6:	e8 09 f5 ff ff       	call   80b6c4 <do_close_internal>
  80c1bb:	eb 14                	jmp    80c1d1 <do_close+0x3a>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c1bd:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c1c1:	83 ec 0c             	sub    $0xc,%esp
  80c1c4:	8b 02                	mov    (%edx),%eax
  80c1c6:	ff 70 10             	pushl  0x10(%eax)
  80c1c9:	e8 0f de ff ff       	call   809fdd <sys_sem_signal>
  80c1ce:	83 c4 10             	add    $0x10,%esp
  }
}
  80c1d1:	c9                   	leave  
  80c1d2:	c3                   	ret    

0080c1d3 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c1d3:	55                   	push   %ebp
  80c1d4:	89 e5                	mov    %esp,%ebp
  80c1d6:	57                   	push   %edi
  80c1d7:	56                   	push   %esi
  80c1d8:	53                   	push   %ebx
  80c1d9:	83 ec 18             	sub    $0x18,%esp
  80c1dc:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c1de:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c1e4:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c1e8:	50                   	push   %eax
  80c1e9:	e8 fa b4 ff ff       	call   8076e8 <ntohs>
  80c1ee:	83 c4 10             	add    $0x10,%esp
  80c1f1:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c1f5:	0f 86 83 00 00 00    	jbe    80c27e <tcp_parseopt+0xab>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c1fb:	83 c6 14             	add    $0x14,%esi
  80c1fe:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c203:	eb 4f                	jmp    80c254 <tcp_parseopt+0x81>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80c205:	0f b6 d3             	movzbl %bl,%edx
  80c208:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c20c:	84 c0                	test   %al,%al
  80c20e:	74 6e                	je     80c27e <tcp_parseopt+0xab>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80c210:	3c 01                	cmp    $0x1,%al
  80c212:	75 05                	jne    80c219 <tcp_parseopt+0x46>
        ++c;
  80c214:	83 c3 01             	add    $0x1,%ebx
  80c217:	eb 3b                	jmp    80c254 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80c219:	3c 02                	cmp    $0x2,%al
  80c21b:	75 2c                	jne    80c249 <tcp_parseopt+0x76>
  80c21d:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c222:	75 25                	jne    80c249 <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c224:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80c229:	c1 e0 08             	shl    $0x8,%eax
  80c22c:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c231:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c233:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c236:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80c23b:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80c240:	0f 47 c2             	cmova  %edx,%eax
  80c243:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80c247:	eb 35                	jmp    80c27e <tcp_parseopt+0xab>
      } else {
        if (opts[c + 1] == 0) {
  80c249:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c24e:	84 c0                	test   %al,%al
  80c250:	74 2c                	je     80c27e <tcp_parseopt+0xab>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c252:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c254:	83 ec 0c             	sub    $0xc,%esp
  80c257:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c25c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c260:	50                   	push   %eax
  80c261:	e8 82 b4 ff ff       	call   8076e8 <ntohs>
  80c266:	0f b6 d3             	movzbl %bl,%edx
  80c269:	66 c1 e8 0c          	shr    $0xc,%ax
  80c26d:	0f b7 c0             	movzwl %ax,%eax
  80c270:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c277:	83 c4 10             	add    $0x10,%esp
  80c27a:	39 c2                	cmp    %eax,%edx
  80c27c:	7c 87                	jl     80c205 <tcp_parseopt+0x32>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80c27e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c281:	5b                   	pop    %ebx
  80c282:	5e                   	pop    %esi
  80c283:	5f                   	pop    %edi
  80c284:	5d                   	pop    %ebp
  80c285:	c3                   	ret    

0080c286 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80c286:	55                   	push   %ebp
  80c287:	89 e5                	mov    %esp,%ebp
  80c289:	57                   	push   %edi
  80c28a:	56                   	push   %esi
  80c28b:	53                   	push   %ebx
  80c28c:	83 ec 1c             	sub    $0x1c,%esp
  80c28f:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80c291:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c298:	0f 84 46 04 00 00    	je     80c6e4 <tcp_receive+0x45e>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c29e:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80c2a2:	8b 40 60             	mov    0x60(%eax),%eax

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c2a5:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c2ab:	39 d0                	cmp    %edx,%eax
  80c2ad:	78 26                	js     80c2d5 <tcp_receive+0x4f>
  80c2af:	39 d0                	cmp    %edx,%eax
  80c2b1:	75 0b                	jne    80c2be <tcp_receive+0x38>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c2b3:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c2b9:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c2bc:	78 17                	js     80c2d5 <tcp_receive+0x4f>
  80c2be:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c2c4:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c2c7:	75 3b                	jne    80c304 <tcp_receive+0x7e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c2c9:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c2cf:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80c2d3:	73 2f                	jae    80c304 <tcp_receive+0x7e>
      pcb->snd_wnd = tcphdr->wnd;
  80c2d5:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c2db:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80c2df:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c2e3:	89 57 60             	mov    %edx,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c2e6:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c2ec:	89 57 64             	mov    %edx,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c2ef:	66 85 c9             	test   %cx,%cx
  80c2f2:	74 10                	je     80c304 <tcp_receive+0x7e>
  80c2f4:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c2fb:	74 07                	je     80c304 <tcp_receive+0x7e>
          pcb->persist_backoff = 0;
  80c2fd:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80c304:	8b 4f 48             	mov    0x48(%edi),%ecx
  80c307:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c30d:	39 d1                	cmp    %edx,%ecx
  80c30f:	0f 85 ad 00 00 00    	jne    80c3c2 <tcp_receive+0x13c>
      pcb->acked = 0;
  80c315:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c31b:	0f b7 db             	movzwl %bx,%ebx
  80c31e:	01 d8                	add    %ebx,%eax
  80c320:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c324:	03 57 60             	add    0x60(%edi),%edx
  80c327:	39 d0                	cmp    %edx,%eax
  80c329:	0f 85 e2 02 00 00    	jne    80c611 <tcp_receive+0x38b>
        ++pcb->dupacks;
  80c32f:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c333:	83 c0 01             	add    $0x1,%eax
  80c336:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c339:	3c 02                	cmp    $0x2,%al
  80c33b:	0f 86 d0 02 00 00    	jbe    80c611 <tcp_receive+0x38b>
  80c341:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c345:	0f 84 c6 02 00 00    	je     80c611 <tcp_receive+0x38b>
          if (!(pcb->flags & TF_INFR)) {
  80c34b:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c34f:	75 55                	jne    80c3a6 <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80c351:	83 ec 0c             	sub    $0xc,%esp
  80c354:	57                   	push   %edi
  80c355:	e8 9a c2 ff ff       	call   8085f4 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80c35a:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80c35e:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c362:	83 c4 10             	add    $0x10,%esp
  80c365:	66 39 d0             	cmp    %dx,%ax
  80c368:	76 09                	jbe    80c373 <tcp_receive+0xed>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c36a:	66 d1 ea             	shr    %dx
  80c36d:	66 89 57 50          	mov    %dx,0x50(%edi)
  80c371:	eb 07                	jmp    80c37a <tcp_receive+0xf4>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80c373:	66 d1 e8             	shr    %ax
  80c376:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80c37a:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c37e:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80c382:	0f b7 d0             	movzwl %ax,%edx
  80c385:	01 d2                	add    %edx,%edx
  80c387:	39 d1                	cmp    %edx,%ecx
  80c389:	7d 07                	jge    80c392 <tcp_receive+0x10c>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80c38b:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c38e:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c392:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c395:	66 03 47 50          	add    0x50(%edi),%ax
  80c399:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c39d:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c3a1:	e9 6b 02 00 00       	jmp    80c611 <tcp_receive+0x38b>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c3a6:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c3aa:	89 d0                	mov    %edx,%eax
  80c3ac:	66 03 47 34          	add    0x34(%edi),%ax
  80c3b0:	66 39 c2             	cmp    %ax,%dx
  80c3b3:	0f 83 58 02 00 00    	jae    80c611 <tcp_receive+0x38b>
              pcb->cwnd += pcb->mss;
  80c3b9:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c3bd:	e9 4f 02 00 00       	jmp    80c611 <tcp_receive+0x38b>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c3c2:	8d 42 ff             	lea    -0x1(%edx),%eax
  80c3c5:	39 c8                	cmp    %ecx,%eax
  80c3c7:	0f 88 9d 01 00 00    	js     80c56a <tcp_receive+0x2e4>
  80c3cd:	89 d0                	mov    %edx,%eax
  80c3cf:	2b 47 58             	sub    0x58(%edi),%eax
  80c3d2:	85 c0                	test   %eax,%eax
  80c3d4:	0f 8f 90 01 00 00    	jg     80c56a <tcp_receive+0x2e4>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80c3da:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80c3de:	a8 04                	test   $0x4,%al
  80c3e0:	74 0e                	je     80c3f0 <tcp_receive+0x16a>
        pcb->flags &= ~TF_INFR;
  80c3e2:	83 e0 fb             	and    $0xfffffffb,%eax
  80c3e5:	88 47 20             	mov    %al,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c3e8:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80c3ec:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80c3f0:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c3f4:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  80c3f8:	66 c1 f8 03          	sar    $0x3,%ax
  80c3fc:	66 03 47 42          	add    0x42(%edi),%ax
  80c400:	66 89 47 44          	mov    %ax,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c404:	89 d0                	mov    %edx,%eax
  80c406:	29 c8                	sub    %ecx,%eax
  80c408:	66 89 47 6c          	mov    %ax,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80c40c:	66 01 47 6e          	add    %ax,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80c410:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c414:	89 57 48             	mov    %edx,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80c417:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c41b:	0f 86 c3 00 00 00    	jbe    80c4e4 <tcp_receive+0x25e>
        if (pcb->cwnd < pcb->ssthresh) {
  80c421:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c425:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c429:	73 18                	jae    80c443 <tcp_receive+0x1bd>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c42b:	89 c8                	mov    %ecx,%eax
  80c42d:	66 03 47 34          	add    0x34(%edi),%ax
  80c431:	66 39 c1             	cmp    %ax,%cx
  80c434:	0f 83 aa 00 00 00    	jae    80c4e4 <tcp_receive+0x25e>
            pcb->cwnd += pcb->mss;
  80c43a:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c43e:	e9 a1 00 00 00       	jmp    80c4e4 <tcp_receive+0x25e>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c443:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c447:	0f af c0             	imul   %eax,%eax
  80c44a:	0f b7 d9             	movzwl %cx,%ebx
  80c44d:	99                   	cltd   
  80c44e:	f7 fb                	idiv   %ebx
  80c450:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c452:	66 39 c1             	cmp    %ax,%cx
  80c455:	0f 83 89 00 00 00    	jae    80c4e4 <tcp_receive+0x25e>
            pcb->cwnd = new_cwnd;
  80c45b:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c45f:	e9 80 00 00 00       	jmp    80c4e4 <tcp_receive+0x25e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80c464:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c467:	8b 03                	mov    (%ebx),%eax
  80c469:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c46c:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c470:	83 ec 0c             	sub    $0xc,%esp
  80c473:	ff 73 04             	pushl  0x4(%ebx)
  80c476:	e8 0e 88 ff ff       	call   804c89 <pbuf_clen>
  80c47b:	0f b6 c0             	movzbl %al,%eax
  80c47e:	83 c4 10             	add    $0x10,%esp
  80c481:	66 39 c6             	cmp    %ax,%si
  80c484:	73 17                	jae    80c49d <tcp_receive+0x217>
  80c486:	83 ec 04             	sub    $0x4,%esp
  80c489:	68 24 2f 81 00       	push   $0x812f24
  80c48e:	68 55 03 00 00       	push   $0x355
  80c493:	68 90 30 81 00       	push   $0x813090
  80c498:	e8 ad 1f 00 00       	call   80e44a <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c49d:	83 ec 0c             	sub    $0xc,%esp
  80c4a0:	ff 73 04             	pushl  0x4(%ebx)
  80c4a3:	e8 e1 87 ff ff       	call   804c89 <pbuf_clen>
  80c4a8:	0f b6 c0             	movzbl %al,%eax
  80c4ab:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c4af:	89 1c 24             	mov    %ebx,(%esp)
  80c4b2:	e8 b9 92 ff ff       	call   805770 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80c4b7:	83 c4 10             	add    $0x10,%esp
  80c4ba:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c4bf:	74 23                	je     80c4e4 <tcp_receive+0x25e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c4c1:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c4c5:	75 1d                	jne    80c4e4 <tcp_receive+0x25e>
  80c4c7:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c4cb:	75 17                	jne    80c4e4 <tcp_receive+0x25e>
  80c4cd:	83 ec 04             	sub    $0x4,%esp
  80c4d0:	68 4c 2f 81 00       	push   $0x812f4c
  80c4d5:	68 5c 03 00 00       	push   $0x35c
  80c4da:	68 90 30 81 00       	push   $0x813090
  80c4df:	e8 66 1f 00 00       	call   80e44a <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c4e4:	8b 47 78             	mov    0x78(%edi),%eax
  80c4e7:	85 c0                	test   %eax,%eax
  80c4e9:	74 68                	je     80c553 <tcp_receive+0x2cd>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c4eb:	83 ec 0c             	sub    $0xc,%esp
  80c4ee:	8b 40 10             	mov    0x10(%eax),%eax
  80c4f1:	ff 70 04             	pushl  0x4(%eax)
  80c4f4:	e8 1d b4 ff ff       	call   807916 <ntohl>
  80c4f9:	89 c6                	mov    %eax,%esi
  80c4fb:	8b 47 78             	mov    0x78(%edi),%eax
  80c4fe:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c502:	8b 40 10             	mov    0x10(%eax),%eax
  80c505:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c509:	89 04 24             	mov    %eax,(%esp)
  80c50c:	e8 d7 b1 ff ff       	call   8076e8 <ntohs>
  80c511:	83 c4 10             	add    $0x10,%esp
  80c514:	ba 01 00 00 00       	mov    $0x1,%edx
  80c519:	a8 01                	test   $0x1,%al
  80c51b:	75 1e                	jne    80c53b <tcp_receive+0x2b5>
  80c51d:	83 ec 0c             	sub    $0xc,%esp
  80c520:	8b 47 78             	mov    0x78(%edi),%eax
  80c523:	8b 40 10             	mov    0x10(%eax),%eax
  80c526:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c52a:	50                   	push   %eax
  80c52b:	e8 b8 b1 ff ff       	call   8076e8 <ntohs>
  80c530:	66 d1 e8             	shr    %ax
  80c533:	89 c2                	mov    %eax,%edx
  80c535:	83 e2 01             	and    $0x1,%edx
  80c538:	83 c4 10             	add    $0x10,%esp
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c53b:	2b 35 a4 b1 b3 00    	sub    0xb3b1a4,%esi
  80c541:	01 d3                	add    %edx,%ebx
  80c543:	01 f3                	add    %esi,%ebx
  80c545:	85 db                	test   %ebx,%ebx
  80c547:	0f 8e 17 ff ff ff    	jle    80c464 <tcp_receive+0x1de>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80c54d:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c551:	75 08                	jne    80c55b <tcp_receive+0x2d5>
        pcb->rtime = -1;
  80c553:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80c559:	eb 06                	jmp    80c561 <tcp_receive+0x2db>
      else
        pcb->rtime = 0;
  80c55b:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80c561:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c565:	e9 a7 00 00 00       	jmp    80c611 <tcp_receive+0x38b>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80c56a:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c570:	e9 9c 00 00 00       	jmp    80c611 <tcp_receive+0x38b>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80c575:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c578:	8b 03                	mov    (%ebx),%eax
  80c57a:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c57d:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c581:	83 ec 0c             	sub    $0xc,%esp
  80c584:	ff 73 04             	pushl  0x4(%ebx)
  80c587:	e8 fd 86 ff ff       	call   804c89 <pbuf_clen>
  80c58c:	0f b6 c0             	movzbl %al,%eax
  80c58f:	83 c4 10             	add    $0x10,%esp
  80c592:	66 39 c6             	cmp    %ax,%si
  80c595:	73 17                	jae    80c5ae <tcp_receive+0x328>
  80c597:	83 ec 04             	sub    $0x4,%esp
  80c59a:	68 24 2f 81 00       	push   $0x812f24
  80c59f:	68 7f 03 00 00       	push   $0x37f
  80c5a4:	68 90 30 81 00       	push   $0x813090
  80c5a9:	e8 9c 1e 00 00       	call   80e44a <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c5ae:	83 ec 0c             	sub    $0xc,%esp
  80c5b1:	ff 73 04             	pushl  0x4(%ebx)
  80c5b4:	e8 d0 86 ff ff       	call   804c89 <pbuf_clen>
  80c5b9:	0f b6 c0             	movzbl %al,%eax
  80c5bc:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c5c0:	89 1c 24             	mov    %ebx,(%esp)
  80c5c3:	e8 a8 91 ff ff       	call   805770 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80c5c8:	83 c4 10             	add    $0x10,%esp
  80c5cb:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c5d0:	74 24                	je     80c5f6 <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c5d2:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c5d6:	75 1e                	jne    80c5f6 <tcp_receive+0x370>
  80c5d8:	8b 47 74             	mov    0x74(%edi),%eax
  80c5db:	85 c0                	test   %eax,%eax
  80c5dd:	75 1e                	jne    80c5fd <tcp_receive+0x377>
  80c5df:	83 ec 04             	sub    $0x4,%esp
  80c5e2:	68 4c 2f 81 00       	push   $0x812f4c
  80c5e7:	68 85 03 00 00       	push   $0x385
  80c5ec:	68 90 30 81 00       	push   $0x813090
  80c5f1:	e8 54 1e 00 00       	call   80e44a <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80c5f6:	8b 47 74             	mov    0x74(%edi),%eax
  80c5f9:	85 c0                	test   %eax,%eax
  80c5fb:	74 14                	je     80c611 <tcp_receive+0x38b>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c5fd:	83 ec 0c             	sub    $0xc,%esp
  80c600:	8b 40 10             	mov    0x10(%eax),%eax
  80c603:	ff 70 04             	pushl  0x4(%eax)
  80c606:	e8 ea b0 ff ff       	call   8076f5 <htonl>
  80c60b:	89 47 54             	mov    %eax,0x54(%edi)
  80c60e:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c611:	8b 47 74             	mov    0x74(%edi),%eax
  80c614:	85 c0                	test   %eax,%eax
  80c616:	74 70                	je     80c688 <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c618:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c61e:	83 ec 0c             	sub    $0xc,%esp
  80c621:	8b 40 10             	mov    0x10(%eax),%eax
  80c624:	ff 70 04             	pushl  0x4(%eax)
  80c627:	e8 ea b2 ff ff       	call   807916 <ntohl>
  80c62c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c62f:	8b 47 74             	mov    0x74(%edi),%eax
  80c632:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c636:	8b 40 10             	mov    0x10(%eax),%eax
  80c639:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c63d:	89 04 24             	mov    %eax,(%esp)
  80c640:	e8 a3 b0 ff ff       	call   8076e8 <ntohs>
  80c645:	83 c4 10             	add    $0x10,%esp
  80c648:	ba 01 00 00 00       	mov    $0x1,%edx
  80c64d:	a8 01                	test   $0x1,%al
  80c64f:	75 1e                	jne    80c66f <tcp_receive+0x3e9>
  80c651:	83 ec 0c             	sub    $0xc,%esp
  80c654:	8b 47 74             	mov    0x74(%edi),%eax
  80c657:	8b 40 10             	mov    0x10(%eax),%eax
  80c65a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c65e:	50                   	push   %eax
  80c65f:	e8 84 b0 ff ff       	call   8076e8 <ntohs>
  80c664:	66 d1 e8             	shr    %ax
  80c667:	89 c2                	mov    %eax,%edx
  80c669:	83 e2 01             	and    $0x1,%edx
  80c66c:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c66f:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c672:	01 d3                	add    %edx,%ebx
  80c674:	39 de                	cmp    %ebx,%esi
  80c676:	78 10                	js     80c688 <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c678:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c67d:	2b 47 58             	sub    0x58(%edi),%eax
  80c680:	85 c0                	test   %eax,%eax
  80c682:	0f 8e ed fe ff ff    	jle    80c575 <tcp_receive+0x2ef>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c688:	8b 47 38             	mov    0x38(%edi),%eax
  80c68b:	85 c0                	test   %eax,%eax
  80c68d:	74 55                	je     80c6e4 <tcp_receive+0x45e>
  80c68f:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c695:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c698:	79 4a                	jns    80c6e4 <tcp_receive+0x45e>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80c69a:	0f b7 5f 40          	movzwl 0x40(%edi),%ebx
  80c69e:	0f b7 15 40 b2 b3 00 	movzwl 0xb3b240,%edx
  80c6a5:	29 c2                	sub    %eax,%edx
  80c6a7:	89 d8                	mov    %ebx,%eax
  80c6a9:	66 c1 f8 03          	sar    $0x3,%ax
  80c6ad:	89 d1                	mov    %edx,%ecx
  80c6af:	29 c1                	sub    %eax,%ecx
      pcb->sa += m;
  80c6b1:	01 cb                	add    %ecx,%ebx
  80c6b3:	66 89 5f 40          	mov    %bx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80c6b7:	89 ca                	mov    %ecx,%edx
  80c6b9:	f7 da                	neg    %edx
  80c6bb:	66 85 c9             	test   %cx,%cx
  80c6be:	0f 49 d1             	cmovns %ecx,%edx
      }
      m = m - (pcb->sv >> 2);
  80c6c1:	0f b7 47 42          	movzwl 0x42(%edi),%eax
      pcb->sv += m;
  80c6c5:	89 c1                	mov    %eax,%ecx
  80c6c7:	66 c1 f9 02          	sar    $0x2,%cx
  80c6cb:	29 c8                	sub    %ecx,%eax
  80c6cd:	01 d0                	add    %edx,%eax
  80c6cf:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c6d3:	66 c1 fb 03          	sar    $0x3,%bx
  80c6d7:	01 d8                	add    %ebx,%eax
  80c6d9:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80c6dd:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80c6e4:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c6eb:	66 85 c0             	test   %ax,%ax
  80c6ee:	0f 84 8e 07 00 00    	je     80ce82 <tcp_receive+0xbfc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c6f4:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c6f7:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c6fd:	89 d9                	mov    %ebx,%ecx
  80c6ff:	29 d1                	sub    %edx,%ecx
  80c701:	89 ce                	mov    %ecx,%esi
  80c703:	83 ee 01             	sub    $0x1,%esi
  80c706:	0f 88 27 01 00 00    	js     80c833 <tcp_receive+0x5ad>
  80c70c:	8d 73 01             	lea    0x1(%ebx),%esi
  80c70f:	29 d6                	sub    %edx,%esi
  80c711:	0f b7 c0             	movzwl %ax,%eax
  80c714:	29 c6                	sub    %eax,%esi
  80c716:	85 f6                	test   %esi,%esi
  80c718:	0f 8f 15 01 00 00    	jg     80c833 <tcp_receive+0x5ad>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80c71e:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c720:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c726:	85 db                	test   %ebx,%ebx
  80c728:	75 17                	jne    80c741 <tcp_receive+0x4bb>
  80c72a:	83 ec 04             	sub    $0x4,%esp
  80c72d:	68 a7 30 81 00       	push   $0x8130a7
  80c732:	68 e5 03 00 00       	push   $0x3e5
  80c737:	68 90 30 81 00       	push   $0x813090
  80c73c:	e8 09 1d 00 00       	call   80e44a <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c741:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c747:	7e 17                	jle    80c760 <tcp_receive+0x4da>
  80c749:	83 ec 04             	sub    $0x4,%esp
  80c74c:	68 b7 30 81 00       	push   $0x8130b7
  80c751:	68 e6 03 00 00       	push   $0x3e6
  80c756:	68 90 30 81 00       	push   $0x813090
  80c75b:	e8 ea 1c 00 00       	call   80e44a <_panic>
      if (inseg.p->len < off) {
  80c760:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c764:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c767:	39 d1                	cmp    %edx,%ecx
  80c769:	7e 6a                	jle    80c7d5 <tcp_receive+0x54f>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c76b:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c76f:	0f b7 d6             	movzwl %si,%edx
  80c772:	39 d1                	cmp    %edx,%ecx
  80c774:	7e 17                	jle    80c78d <tcp_receive+0x507>
  80c776:	83 ec 04             	sub    $0x4,%esp
  80c779:	68 c6 30 81 00       	push   $0x8130c6
  80c77e:	68 e8 03 00 00       	push   $0x3e8
  80c783:	68 90 30 81 00       	push   $0x813090
  80c788:	e8 bd 1c 00 00       	call   80e44a <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c78d:	29 ce                	sub    %ecx,%esi
  80c78f:	89 f1                	mov    %esi,%ecx
  80c791:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        while (p->len < off) {
          off -= p->len;
  80c794:	29 d0                	sub    %edx,%eax
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80c796:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c79a:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c7a0:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80c7a2:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c7a6:	39 c2                	cmp    %eax,%edx
  80c7a8:	7c ea                	jl     80c794 <tcp_receive+0x50e>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80c7aa:	83 ec 08             	sub    $0x8,%esp
  80c7ad:	f7 d8                	neg    %eax
  80c7af:	98                   	cwtl   
  80c7b0:	50                   	push   %eax
  80c7b1:	53                   	push   %ebx
  80c7b2:	e8 a1 7f ff ff       	call   804758 <pbuf_header>
  80c7b7:	83 c4 10             	add    $0x10,%esp
  80c7ba:	84 c0                	test   %al,%al
  80c7bc:	74 44                	je     80c802 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c7be:	83 ec 04             	sub    $0x4,%esp
  80c7c1:	68 d6 30 81 00       	push   $0x8130d6
  80c7c6:	68 f5 03 00 00       	push   $0x3f5
  80c7cb:	68 90 30 81 00       	push   $0x813090
  80c7d0:	e8 75 1c 00 00       	call   80e44a <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c7d5:	83 ec 08             	sub    $0x8,%esp
  80c7d8:	f7 d9                	neg    %ecx
  80c7da:	0f bf c1             	movswl %cx,%eax
  80c7dd:	50                   	push   %eax
  80c7de:	53                   	push   %ebx
  80c7df:	e8 74 7f ff ff       	call   804758 <pbuf_header>
  80c7e4:	83 c4 10             	add    $0x10,%esp
  80c7e7:	84 c0                	test   %al,%al
  80c7e9:	74 17                	je     80c802 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c7eb:	83 ec 04             	sub    $0x4,%esp
  80c7ee:	68 d6 30 81 00       	push   $0x8130d6
  80c7f3:	68 fa 03 00 00       	push   $0x3fa
  80c7f8:	68 90 30 81 00       	push   $0x813090
  80c7fd:	e8 48 1c 00 00       	call   80e44a <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80c802:	8b 43 04             	mov    0x4(%ebx),%eax
  80c805:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c80a:	8b 57 24             	mov    0x24(%edi),%edx
  80c80d:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c814:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c81b:	29 d0                	sub    %edx,%eax
  80c81d:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c823:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c829:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c82e:	89 50 04             	mov    %edx,0x4(%eax)
  80c831:	eb 14                	jmp    80c847 <tcp_receive+0x5c1>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c833:	39 da                	cmp    %ebx,%edx
  80c835:	79 21                	jns    80c858 <tcp_receive+0x5d2>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80c837:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c83b:	83 ec 0c             	sub    $0xc,%esp
  80c83e:	57                   	push   %edi
  80c83f:	e8 bb b7 ff ff       	call   807fff <tcp_output>
  80c844:	83 c4 10             	add    $0x10,%esp
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c847:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c84d:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c850:	39 da                	cmp    %ebx,%edx
  80c852:	0f 88 13 06 00 00    	js     80ce6b <tcp_receive+0xbe5>
  80c858:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c85c:	89 d1                	mov    %edx,%ecx
  80c85e:	29 c1                	sub    %eax,%ecx
  80c860:	8d 41 01             	lea    0x1(%ecx),%eax
  80c863:	29 d8                	sub    %ebx,%eax
  80c865:	85 c0                	test   %eax,%eax
  80c867:	0f 8f fe 05 00 00    	jg     80ce6b <tcp_receive+0xbe5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80c86d:	39 da                	cmp    %ebx,%edx
  80c86f:	0f 85 77 03 00 00    	jne    80cbec <tcp_receive+0x966>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c875:	8b 4f 7c             	mov    0x7c(%edi),%ecx
  80c878:	85 c9                	test   %ecx,%ecx
  80c87a:	0f 84 85 00 00 00    	je     80c905 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c880:	8b 41 10             	mov    0x10(%ecx),%eax
  80c883:	8b 58 04             	mov    0x4(%eax),%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c886:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c88d:	89 de                	mov    %ebx,%esi
  80c88f:	29 c6                	sub    %eax,%esi
  80c891:	89 f0                	mov    %esi,%eax
  80c893:	29 d0                	sub    %edx,%eax
  80c895:	85 c0                	test   %eax,%eax
  80c897:	7f 6c                	jg     80c905 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80c899:	66 83 79 0c 00       	cmpw   $0x0,0xc(%ecx)
  80c89e:	74 20                	je     80c8c0 <tcp_receive+0x63a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80c8a0:	29 d3                	sub    %edx,%ebx
  80c8a2:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80c8a9:	83 ec 08             	sub    $0x8,%esp
  80c8ac:	0f b7 db             	movzwl %bx,%ebx
  80c8af:	53                   	push   %ebx
  80c8b0:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80c8b6:	e8 b8 82 ff ff       	call   804b73 <pbuf_realloc>
  80c8bb:	83 c4 10             	add    $0x10,%esp
  80c8be:	eb 45                	jmp    80c905 <tcp_receive+0x67f>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c8c0:	83 ec 0c             	sub    $0xc,%esp
  80c8c3:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c8c8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8cc:	50                   	push   %eax
  80c8cd:	e8 16 ae ff ff       	call   8076e8 <ntohs>
  80c8d2:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80c8d4:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c8d7:	8b 40 10             	mov    0x10(%eax),%eax
  80c8da:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8de:	89 04 24             	mov    %eax,(%esp)
  80c8e1:	e8 02 ae ff ff       	call   8076e8 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c8e6:	31 d8                	xor    %ebx,%eax
  80c8e8:	83 c4 10             	add    $0x10,%esp
  80c8eb:	a8 03                	test   $0x3,%al
  80c8ed:	75 16                	jne    80c905 <tcp_receive+0x67f>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80c8ef:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80c8f2:	8b 10                	mov    (%eax),%edx
  80c8f4:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80c8f7:	83 ec 08             	sub    $0x8,%esp
  80c8fa:	50                   	push   %eax
  80c8fb:	6a 04                	push   $0x4
  80c8fd:	e8 b5 7b ff ff       	call   8044b7 <memp_free>
  80c902:	83 c4 10             	add    $0x10,%esp
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80c905:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80c90c:	83 ec 0c             	sub    $0xc,%esp
  80c90f:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c914:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c918:	50                   	push   %eax
  80c919:	e8 ca ad ff ff       	call   8076e8 <ntohs>
  80c91e:	83 c4 10             	add    $0x10,%esp
  80c921:	ba 01 00 00 00       	mov    $0x1,%edx
  80c926:	a8 01                	test   $0x1,%al
  80c928:	75 1d                	jne    80c947 <tcp_receive+0x6c1>
  80c92a:	83 ec 0c             	sub    $0xc,%esp
  80c92d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c932:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c936:	50                   	push   %eax
  80c937:	e8 ac ad ff ff       	call   8076e8 <ntohs>
  80c93c:	66 d1 e8             	shr    %ax
  80c93f:	89 c2                	mov    %eax,%edx
  80c941:	83 e2 01             	and    $0x1,%edx
  80c944:	83 c4 10             	add    $0x10,%esp
  80c947:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c94a:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80c950:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c954:	74 06                	je     80c95c <tcp_receive+0x6d6>
          pcb->rcv_nxt += tcplen;
  80c956:	0f b7 d0             	movzwl %ax,%edx
  80c959:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80c95c:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80c960:	66 39 d0             	cmp    %dx,%ax
  80c963:	76 08                	jbe    80c96d <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80c965:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c96b:	eb 06                	jmp    80c973 <tcp_receive+0x6ed>
        } else {
          pcb->rcv_wnd -= tcplen;
  80c96d:	29 c2                	sub    %eax,%edx
  80c96f:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80c973:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80c977:	66 39 d0             	cmp    %dx,%ax
  80c97a:	76 08                	jbe    80c984 <tcp_receive+0x6fe>
          pcb->rcv_ann_wnd = 0;
  80c97c:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80c982:	eb 06                	jmp    80c98a <tcp_receive+0x704>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80c984:	29 c2                	sub    %eax,%edx
  80c986:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80c98a:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80c98f:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80c994:	74 0f                	je     80c9a5 <tcp_receive+0x71f>
          recv_data = inseg.p;
  80c996:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80c99b:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80c9a2:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80c9a5:	83 ec 0c             	sub    $0xc,%esp
  80c9a8:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c9ad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9b1:	50                   	push   %eax
  80c9b2:	e8 31 ad ff ff       	call   8076e8 <ntohs>
  80c9b7:	83 c4 10             	add    $0x10,%esp
  80c9ba:	a8 01                	test   $0x1,%al
  80c9bc:	0f 84 dd 01 00 00    	je     80cb9f <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80c9c2:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80c9c9:	e9 d1 01 00 00       	jmp    80cb9f <tcp_receive+0x919>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80c9ce:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80c9d3:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9d7:	83 ec 0c             	sub    $0xc,%esp
  80c9da:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80c9de:	50                   	push   %eax
  80c9df:	e8 04 ad ff ff       	call   8076e8 <ntohs>
  80c9e4:	83 c4 10             	add    $0x10,%esp
  80c9e7:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9ec:	a8 01                	test   $0x1,%al
  80c9ee:	75 1b                	jne    80ca0b <tcp_receive+0x785>
  80c9f0:	83 ec 0c             	sub    $0xc,%esp
  80c9f3:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9f6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9fa:	50                   	push   %eax
  80c9fb:	e8 e8 ac ff ff       	call   8076e8 <ntohs>
  80ca00:	66 d1 e8             	shr    %ax
  80ca03:	89 c2                	mov    %eax,%edx
  80ca05:	83 e2 01             	and    $0x1,%edx
  80ca08:	83 c4 10             	add    $0x10,%esp
  80ca0b:	01 d6                	add    %edx,%esi
  80ca0d:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80ca10:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80ca14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ca17:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca1b:	83 ec 0c             	sub    $0xc,%esp
  80ca1e:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca21:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca25:	50                   	push   %eax
  80ca26:	e8 bd ac ff ff       	call   8076e8 <ntohs>
  80ca2b:	83 c4 10             	add    $0x10,%esp
  80ca2e:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca33:	a8 01                	test   $0x1,%al
  80ca35:	75 1b                	jne    80ca52 <tcp_receive+0x7cc>
  80ca37:	83 ec 0c             	sub    $0xc,%esp
  80ca3a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca3d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca41:	50                   	push   %eax
  80ca42:	e8 a1 ac ff ff       	call   8076e8 <ntohs>
  80ca47:	66 d1 e8             	shr    %ax
  80ca4a:	89 c2                	mov    %eax,%edx
  80ca4c:	83 e2 01             	and    $0x1,%edx
  80ca4f:	83 c4 10             	add    $0x10,%esp
  80ca52:	01 d6                	add    %edx,%esi
  80ca54:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ca57:	7d 08                	jge    80ca61 <tcp_receive+0x7db>
            pcb->rcv_wnd = 0;
  80ca59:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80ca5f:	eb 41                	jmp    80caa2 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80ca61:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca65:	83 ec 0c             	sub    $0xc,%esp
  80ca68:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca6b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca6f:	50                   	push   %eax
  80ca70:	e8 73 ac ff ff       	call   8076e8 <ntohs>
  80ca75:	83 c4 10             	add    $0x10,%esp
  80ca78:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca7d:	a8 01                	test   $0x1,%al
  80ca7f:	75 1b                	jne    80ca9c <tcp_receive+0x816>
  80ca81:	83 ec 0c             	sub    $0xc,%esp
  80ca84:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca87:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca8b:	50                   	push   %eax
  80ca8c:	e8 57 ac ff ff       	call   8076e8 <ntohs>
  80ca91:	66 d1 e8             	shr    %ax
  80ca94:	89 c2                	mov    %eax,%edx
  80ca96:	83 e2 01             	and    $0x1,%edx
  80ca99:	83 c4 10             	add    $0x10,%esp
  80ca9c:	01 d6                	add    %edx,%esi
  80ca9e:	66 29 77 28          	sub    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80caa2:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80caa6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80caa9:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80caad:	83 ec 0c             	sub    $0xc,%esp
  80cab0:	8b 43 10             	mov    0x10(%ebx),%eax
  80cab3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cab7:	50                   	push   %eax
  80cab8:	e8 2b ac ff ff       	call   8076e8 <ntohs>
  80cabd:	83 c4 10             	add    $0x10,%esp
  80cac0:	ba 01 00 00 00       	mov    $0x1,%edx
  80cac5:	a8 01                	test   $0x1,%al
  80cac7:	75 1b                	jne    80cae4 <tcp_receive+0x85e>
  80cac9:	83 ec 0c             	sub    $0xc,%esp
  80cacc:	8b 43 10             	mov    0x10(%ebx),%eax
  80cacf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cad3:	50                   	push   %eax
  80cad4:	e8 0f ac ff ff       	call   8076e8 <ntohs>
  80cad9:	66 d1 e8             	shr    %ax
  80cadc:	89 c2                	mov    %eax,%edx
  80cade:	83 e2 01             	and    $0x1,%edx
  80cae1:	83 c4 10             	add    $0x10,%esp
  80cae4:	01 d6                	add    %edx,%esi
  80cae6:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cae9:	7d 08                	jge    80caf3 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80caeb:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80caf1:	eb 41                	jmp    80cb34 <tcp_receive+0x8ae>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80caf3:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80caf7:	83 ec 0c             	sub    $0xc,%esp
  80cafa:	8b 43 10             	mov    0x10(%ebx),%eax
  80cafd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb01:	50                   	push   %eax
  80cb02:	e8 e1 ab ff ff       	call   8076e8 <ntohs>
  80cb07:	83 c4 10             	add    $0x10,%esp
  80cb0a:	ba 01 00 00 00       	mov    $0x1,%edx
  80cb0f:	a8 01                	test   $0x1,%al
  80cb11:	75 1b                	jne    80cb2e <tcp_receive+0x8a8>
  80cb13:	83 ec 0c             	sub    $0xc,%esp
  80cb16:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb19:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb1d:	50                   	push   %eax
  80cb1e:	e8 c5 ab ff ff       	call   8076e8 <ntohs>
  80cb23:	66 d1 e8             	shr    %ax
  80cb26:	89 c2                	mov    %eax,%edx
  80cb28:	83 e2 01             	and    $0x1,%edx
  80cb2b:	83 c4 10             	add    $0x10,%esp
  80cb2e:	01 d6                	add    %edx,%esi
  80cb30:	66 29 77 2a          	sub    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80cb34:	8b 43 04             	mov    0x4(%ebx),%eax
  80cb37:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cb3c:	74 25                	je     80cb63 <tcp_receive+0x8dd>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80cb3e:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80cb44:	85 d2                	test   %edx,%edx
  80cb46:	74 0f                	je     80cb57 <tcp_receive+0x8d1>
              pbuf_cat(recv_data, cseg->p);
  80cb48:	83 ec 08             	sub    $0x8,%esp
  80cb4b:	50                   	push   %eax
  80cb4c:	52                   	push   %edx
  80cb4d:	e8 60 81 ff ff       	call   804cb2 <pbuf_cat>
  80cb52:	83 c4 10             	add    $0x10,%esp
  80cb55:	eb 05                	jmp    80cb5c <tcp_receive+0x8d6>
            } else {
              recv_data = cseg->p;
  80cb57:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            }
            cseg->p = NULL;
  80cb5c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cb63:	83 ec 0c             	sub    $0xc,%esp
  80cb66:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb69:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb6d:	50                   	push   %eax
  80cb6e:	e8 75 ab ff ff       	call   8076e8 <ntohs>
  80cb73:	83 c4 10             	add    $0x10,%esp
  80cb76:	a8 01                	test   $0x1,%al
  80cb78:	74 14                	je     80cb8e <tcp_receive+0x908>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80cb7a:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cb81:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cb85:	75 07                	jne    80cb8e <tcp_receive+0x908>
              pcb->state = CLOSE_WAIT;
  80cb87:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80cb8e:	8b 03                	mov    (%ebx),%eax
  80cb90:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cb93:	83 ec 0c             	sub    $0xc,%esp
  80cb96:	53                   	push   %ebx
  80cb97:	e8 d4 8b ff ff       	call   805770 <tcp_seg_free>
  80cb9c:	83 c4 10             	add    $0x10,%esp
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cb9f:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cba2:	85 db                	test   %ebx,%ebx
  80cba4:	74 0f                	je     80cbb5 <tcp_receive+0x92f>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cba6:	8b 53 10             	mov    0x10(%ebx),%edx
  80cba9:	8b 42 04             	mov    0x4(%edx),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cbac:	3b 47 24             	cmp    0x24(%edi),%eax
  80cbaf:	0f 84 19 fe ff ff    	je     80c9ce <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cbb5:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cbb9:	a8 01                	test   $0x1,%al
  80cbbb:	74 1f                	je     80cbdc <tcp_receive+0x956>
  80cbbd:	83 e0 fe             	and    $0xfffffffe,%eax
  80cbc0:	83 c8 02             	or     $0x2,%eax
  80cbc3:	88 47 20             	mov    %al,0x20(%edi)
  80cbc6:	83 ec 0c             	sub    $0xc,%esp
  80cbc9:	57                   	push   %edi
  80cbca:	e8 30 b4 ff ff       	call   807fff <tcp_output>
  80cbcf:	83 c4 10             	add    $0x10,%esp
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cbd2:	b8 01 00 00 00       	mov    $0x1,%eax
  80cbd7:	e9 07 03 00 00       	jmp    80cee3 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cbdc:	83 c8 01             	or     $0x1,%eax
  80cbdf:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cbe2:	b8 01 00 00 00       	mov    $0x1,%eax
  80cbe7:	e9 f7 02 00 00       	jmp    80cee3 <tcp_receive+0xc5d>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80cbec:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cbf0:	83 ec 0c             	sub    $0xc,%esp
  80cbf3:	57                   	push   %edi
  80cbf4:	e8 06 b4 ff ff       	call   807fff <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80cbf9:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cbfc:	83 c4 10             	add    $0x10,%esp
  80cbff:	85 db                	test   %ebx,%ebx
  80cc01:	75 1d                	jne    80cc20 <tcp_receive+0x99a>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cc03:	83 ec 0c             	sub    $0xc,%esp
  80cc06:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cc0b:	e8 e0 8b ff ff       	call   8057f0 <tcp_seg_copy>
  80cc10:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cc13:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc16:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc1b:	e9 c3 02 00 00       	jmp    80cee3 <tcp_receive+0xc5d>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80cc20:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80cc26:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cc29:	8d 51 01             	lea    0x1(%ecx),%edx
  80cc2c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cc2f:	be 00 00 00 00       	mov    $0x0,%esi
  80cc34:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cc37:	89 c7                	mov    %eax,%edi
  80cc39:	eb 02                	jmp    80cc3d <tcp_receive+0x9b7>
  80cc3b:	89 d3                	mov    %edx,%ebx
  80cc3d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc40:	8b 40 04             	mov    0x4(%eax),%eax
  80cc43:	39 c8                	cmp    %ecx,%eax
  80cc45:	0f 85 a6 00 00 00    	jne    80ccf1 <tcp_receive+0xa6b>
  80cc4b:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc4e:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80cc53:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cc57:	66 39 0d c0 b1 b3 00 	cmp    %cx,0xb3b1c0
  80cc5e:	0f 86 7f 02 00 00    	jbe    80cee3 <tcp_receive+0xc5d>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80cc64:	83 ec 0c             	sub    $0xc,%esp
  80cc67:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cc6c:	e8 7f 8b ff ff       	call   8057f0 <tcp_seg_copy>
  80cc71:	89 c1                	mov    %eax,%ecx
  80cc73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cc76:	83 c4 10             	add    $0x10,%esp
  80cc79:	85 c0                	test   %eax,%eax
  80cc7b:	0f 84 33 02 00 00    	je     80ceb4 <tcp_receive+0xc2e>
                  cseg->next = next->next;
  80cc81:	8b 03                	mov    (%ebx),%eax
  80cc83:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cc85:	85 f6                	test   %esi,%esi
  80cc87:	74 04                	je     80cc8d <tcp_receive+0xa07>
                    prev->next = cseg;
  80cc89:	89 0e                	mov    %ecx,(%esi)
  80cc8b:	eb 06                	jmp    80cc93 <tcp_receive+0xa0d>
                  } else {
                    pcb->ooseq = cseg;
  80cc8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cc90:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80cc93:	83 ec 0c             	sub    $0xc,%esp
  80cc96:	53                   	push   %ebx
  80cc97:	e8 d4 8a ff ff       	call   805770 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cc9c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80cc9f:	8b 06                	mov    (%esi),%eax
  80cca1:	83 c4 10             	add    $0x10,%esp
  80cca4:	85 c0                	test   %eax,%eax
  80cca6:	0f 84 0f 02 00 00    	je     80cebb <tcp_receive+0xc35>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ccac:	8b 1d a8 b1 b3 00    	mov    0xb3b1a8,%ebx
  80ccb2:	8b 40 10             	mov    0x10(%eax),%eax
  80ccb5:	8b 50 04             	mov    0x4(%eax),%edx
  80ccb8:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80ccbc:	29 d1                	sub    %edx,%ecx
  80ccbe:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ccc0:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ccc5:	85 c9                	test   %ecx,%ecx
  80ccc7:	0f 8e 16 02 00 00    	jle    80cee3 <tcp_receive+0xc5d>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cccd:	89 d0                	mov    %edx,%eax
  80cccf:	29 d8                	sub    %ebx,%eax
  80ccd1:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80ccd5:	83 ec 08             	sub    $0x8,%esp
  80ccd8:	0f b7 c0             	movzwl %ax,%eax
  80ccdb:	50                   	push   %eax
  80ccdc:	ff 76 04             	pushl  0x4(%esi)
  80ccdf:	e8 8f 7e ff ff       	call   804b73 <pbuf_realloc>
  80cce4:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cce7:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccec:	e9 f2 01 00 00       	jmp    80cee3 <tcp_receive+0xc5d>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80ccf1:	85 f6                	test   %esi,%esi
  80ccf3:	75 5e                	jne    80cd53 <tcp_receive+0xacd>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ccf5:	39 c1                	cmp    %eax,%ecx
  80ccf7:	0f 89 fc 00 00 00    	jns    80cdf9 <tcp_receive+0xb73>
  80ccfd:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cd00:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cd07:	01 ca                	add    %ecx,%edx
  80cd09:	29 c2                	sub    %eax,%edx
  80cd0b:	85 d2                	test   %edx,%edx
  80cd0d:	7e 1d                	jle    80cd2c <tcp_receive+0xaa6>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cd0f:	29 c8                	sub    %ecx,%eax
  80cd11:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cd17:	83 ec 08             	sub    $0x8,%esp
  80cd1a:	0f b7 c0             	movzwl %ax,%eax
  80cd1d:	50                   	push   %eax
  80cd1e:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cd24:	e8 4a 7e ff ff       	call   804b73 <pbuf_realloc>
  80cd29:	83 c4 10             	add    $0x10,%esp
                  }
                  cseg = tcp_seg_copy(&inseg);
  80cd2c:	83 ec 0c             	sub    $0xc,%esp
  80cd2f:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cd34:	e8 b7 8a ff ff       	call   8057f0 <tcp_seg_copy>
                  if (cseg != NULL) {
  80cd39:	83 c4 10             	add    $0x10,%esp
  80cd3c:	85 c0                	test   %eax,%eax
  80cd3e:	0f 84 7e 01 00 00    	je     80cec2 <tcp_receive+0xc3c>
                    cseg->next = next;
  80cd44:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cd46:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd49:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd4e:	e9 90 01 00 00       	jmp    80cee3 <tcp_receive+0xc5d>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cd53:	8b 56 10             	mov    0x10(%esi),%edx
  80cd56:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cd59:	0f 88 9a 00 00 00    	js     80cdf9 <tcp_receive+0xb73>
  80cd5f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cd62:	29 c2                	sub    %eax,%edx
  80cd64:	85 d2                	test   %edx,%edx
  80cd66:	0f 8f 8d 00 00 00    	jg     80cdf9 <tcp_receive+0xb73>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cd6c:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cd73:	01 ca                	add    %ecx,%edx
  80cd75:	29 c2                	sub    %eax,%edx
  80cd77:	85 d2                	test   %edx,%edx
  80cd79:	7e 1d                	jle    80cd98 <tcp_receive+0xb12>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cd7b:	29 c8                	sub    %ecx,%eax
  80cd7d:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cd83:	83 ec 08             	sub    $0x8,%esp
  80cd86:	0f b7 c0             	movzwl %ax,%eax
  80cd89:	50                   	push   %eax
  80cd8a:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cd90:	e8 de 7d ff ff       	call   804b73 <pbuf_realloc>
  80cd95:	83 c4 10             	add    $0x10,%esp
                }

                cseg = tcp_seg_copy(&inseg);
  80cd98:	83 ec 0c             	sub    $0xc,%esp
  80cd9b:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cda0:	e8 4b 8a ff ff       	call   8057f0 <tcp_seg_copy>
                if (cseg != NULL) {
  80cda5:	83 c4 10             	add    $0x10,%esp
  80cda8:	85 c0                	test   %eax,%eax
  80cdaa:	0f 84 19 01 00 00    	je     80cec9 <tcp_receive+0xc43>
                  cseg->next = next;
  80cdb0:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80cdb2:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cdb4:	8b 46 10             	mov    0x10(%esi),%eax
  80cdb7:	8b 58 04             	mov    0x4(%eax),%ebx
  80cdba:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cdc0:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cdc4:	29 d1                	sub    %edx,%ecx
  80cdc6:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdc8:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cdcd:	85 c9                	test   %ecx,%ecx
  80cdcf:	0f 8e 0e 01 00 00    	jle    80cee3 <tcp_receive+0xc5d>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cdd5:	89 d0                	mov    %edx,%eax
  80cdd7:	29 d8                	sub    %ebx,%eax
  80cdd9:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cddd:	83 ec 08             	sub    $0x8,%esp
  80cde0:	0f b7 c0             	movzwl %ax,%eax
  80cde3:	50                   	push   %eax
  80cde4:	ff 76 04             	pushl  0x4(%esi)
  80cde7:	e8 87 7d ff ff       	call   804b73 <pbuf_realloc>
  80cdec:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdef:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdf4:	e9 ea 00 00 00       	jmp    80cee3 <tcp_receive+0xc5d>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80cdf9:	8b 13                	mov    (%ebx),%edx
  80cdfb:	89 de                	mov    %ebx,%esi
  80cdfd:	85 d2                	test   %edx,%edx
  80cdff:	0f 85 36 fe ff ff    	jne    80cc3b <tcp_receive+0x9b5>
  80ce05:	29 c1                	sub    %eax,%ecx
  80ce07:	85 c9                	test   %ecx,%ecx
  80ce09:	0f 8e c1 00 00 00    	jle    80ced0 <tcp_receive+0xc4a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80ce0f:	83 ec 0c             	sub    $0xc,%esp
  80ce12:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80ce17:	e8 d4 89 ff ff       	call   8057f0 <tcp_seg_copy>
  80ce1c:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80ce1e:	83 c4 10             	add    $0x10,%esp
  80ce21:	85 c0                	test   %eax,%eax
  80ce23:	0f 84 ae 00 00 00    	je     80ced7 <tcp_receive+0xc51>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80ce29:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce2c:	8b 70 04             	mov    0x4(%eax),%esi
  80ce2f:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80ce35:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80ce39:	29 d1                	sub    %edx,%ecx
  80ce3b:	01 f1                	add    %esi,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce3d:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80ce42:	85 c9                	test   %ecx,%ecx
  80ce44:	0f 8e 99 00 00 00    	jle    80cee3 <tcp_receive+0xc5d>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80ce4a:	89 d0                	mov    %edx,%eax
  80ce4c:	29 f0                	sub    %esi,%eax
  80ce4e:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80ce52:	83 ec 08             	sub    $0x8,%esp
  80ce55:	0f b7 c0             	movzwl %ax,%eax
  80ce58:	50                   	push   %eax
  80ce59:	ff 73 04             	pushl  0x4(%ebx)
  80ce5c:	e8 12 7d ff ff       	call   804b73 <pbuf_realloc>
  80ce61:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce64:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce69:	eb 78                	jmp    80cee3 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80ce6b:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ce6f:	83 ec 0c             	sub    $0xc,%esp
  80ce72:	57                   	push   %edi
  80ce73:	e8 87 b1 ff ff       	call   807fff <tcp_output>
  80ce78:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce7b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce80:	eb 61                	jmp    80cee3 <tcp_receive+0xc5d>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80ce82:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80ce87:	8b 57 24             	mov    0x24(%edi),%edx
  80ce8a:	39 d0                	cmp    %edx,%eax
  80ce8c:	78 0f                	js     80ce9d <tcp_receive+0xc17>
  80ce8e:	83 c0 01             	add    $0x1,%eax
  80ce91:	29 d0                	sub    %edx,%eax
  80ce93:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80ce97:	29 d0                	sub    %edx,%eax
  80ce99:	85 c0                	test   %eax,%eax
  80ce9b:	7e 41                	jle    80cede <tcp_receive+0xc58>
      tcp_ack_now(pcb);
  80ce9d:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cea1:	83 ec 0c             	sub    $0xc,%esp
  80cea4:	57                   	push   %edi
  80cea5:	e8 55 b1 ff ff       	call   807fff <tcp_output>
  80ceaa:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cead:	b8 00 00 00 00       	mov    $0x0,%eax
  80ceb2:	eb 2f                	jmp    80cee3 <tcp_receive+0xc5d>
  80ceb4:	b8 00 00 00 00       	mov    $0x0,%eax
  80ceb9:	eb 28                	jmp    80cee3 <tcp_receive+0xc5d>
  80cebb:	b8 00 00 00 00       	mov    $0x0,%eax
  80cec0:	eb 21                	jmp    80cee3 <tcp_receive+0xc5d>
  80cec2:	b8 00 00 00 00       	mov    $0x0,%eax
  80cec7:	eb 1a                	jmp    80cee3 <tcp_receive+0xc5d>
  80cec9:	b8 00 00 00 00       	mov    $0x0,%eax
  80cece:	eb 13                	jmp    80cee3 <tcp_receive+0xc5d>
  80ced0:	b8 00 00 00 00       	mov    $0x0,%eax
  80ced5:	eb 0c                	jmp    80cee3 <tcp_receive+0xc5d>
  80ced7:	b8 00 00 00 00       	mov    $0x0,%eax
  80cedc:	eb 05                	jmp    80cee3 <tcp_receive+0xc5d>
  80cede:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80cee3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80cee6:	5b                   	pop    %ebx
  80cee7:	5e                   	pop    %esi
  80cee8:	5f                   	pop    %edi
  80cee9:	5d                   	pop    %ebp
  80ceea:	c3                   	ret    

0080ceeb <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80ceeb:	55                   	push   %ebp
  80ceec:	89 e5                	mov    %esp,%ebp
  80ceee:	57                   	push   %edi
  80ceef:	56                   	push   %esi
  80cef0:	53                   	push   %ebx
  80cef1:	83 ec 38             	sub    $0x38,%esp
  80cef4:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80cef7:	8b 5e 04             	mov    0x4(%esi),%ebx
  80cefa:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80cf00:	0f b7 03             	movzwl (%ebx),%eax
  80cf03:	50                   	push   %eax
  80cf04:	e8 df a7 ff ff       	call   8076e8 <ntohs>
  80cf09:	66 c1 e8 08          	shr    $0x8,%ax
  80cf0d:	83 e0 0f             	and    $0xf,%eax
  80cf10:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80cf13:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80cf18:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cf1d:	0f b7 00             	movzwl (%eax),%eax
  80cf20:	89 04 24             	mov    %eax,(%esp)
  80cf23:	e8 c0 a7 ff ff       	call   8076e8 <ntohs>
  80cf28:	83 c4 08             	add    $0x8,%esp
  80cf2b:	66 c1 e8 06          	shr    $0x6,%ax
  80cf2f:	83 e0 3c             	and    $0x3c,%eax
  80cf32:	f7 d8                	neg    %eax
  80cf34:	98                   	cwtl   
  80cf35:	50                   	push   %eax
  80cf36:	56                   	push   %esi
  80cf37:	e8 1c 78 ff ff       	call   804758 <pbuf_header>
  80cf3c:	83 c4 10             	add    $0x10,%esp
  80cf3f:	84 c0                	test   %al,%al
  80cf41:	75 07                	jne    80cf4a <tcp_input+0x5f>
  80cf43:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80cf48:	77 11                	ja     80cf5b <tcp_input+0x70>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf4a:	83 ec 0c             	sub    $0xc,%esp
  80cf4d:	56                   	push   %esi
  80cf4e:	e8 d7 78 ff ff       	call   80482a <pbuf_free>
    return;
  80cf53:	83 c4 10             	add    $0x10,%esp
  80cf56:	e9 fb 0c 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cf5b:	83 ec 08             	sub    $0x8,%esp
  80cf5e:	ff 75 0c             	pushl  0xc(%ebp)
  80cf61:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cf66:	83 c0 10             	add    $0x10,%eax
  80cf69:	50                   	push   %eax
  80cf6a:	e8 64 95 ff ff       	call   8064d3 <ip_addr_isbroadcast>
  80cf6f:	83 c4 10             	add    $0x10,%esp
  80cf72:	84 c0                	test   %al,%al
  80cf74:	75 2a                	jne    80cfa0 <tcp_input+0xb5>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80cf76:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cf7b:	8b 58 10             	mov    0x10(%eax),%ebx
  80cf7e:	83 ec 0c             	sub    $0xc,%esp
  80cf81:	68 00 00 00 f0       	push   $0xf0000000
  80cf86:	e8 8b a9 ff ff       	call   807916 <ntohl>
  80cf8b:	21 c3                	and    %eax,%ebx
  80cf8d:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cf94:	e8 7d a9 ff ff       	call   807916 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cf99:	83 c4 10             	add    $0x10,%esp
  80cf9c:	39 c3                	cmp    %eax,%ebx
  80cf9e:	75 11                	jne    80cfb1 <tcp_input+0xc6>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cfa0:	83 ec 0c             	sub    $0xc,%esp
  80cfa3:	56                   	push   %esi
  80cfa4:	e8 81 78 ff ff       	call   80482a <pbuf_free>
    return;
  80cfa9:	83 c4 10             	add    $0x10,%esp
  80cfac:	e9 a5 0c 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80cfb1:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80cfb6:	83 ec 0c             	sub    $0xc,%esp
  80cfb9:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80cfbd:	52                   	push   %edx
  80cfbe:	6a 06                	push   $0x6
  80cfc0:	8d 50 10             	lea    0x10(%eax),%edx
  80cfc3:	52                   	push   %edx
  80cfc4:	83 c0 0c             	add    $0xc,%eax
  80cfc7:	50                   	push   %eax
  80cfc8:	56                   	push   %esi
  80cfc9:	e8 f4 a3 ff ff       	call   8073c2 <inet_chksum_pseudo>
  80cfce:	83 c4 20             	add    $0x20,%esp
  80cfd1:	66 85 c0             	test   %ax,%ax
  80cfd4:	74 11                	je     80cfe7 <tcp_input+0xfc>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cfd6:	83 ec 0c             	sub    $0xc,%esp
  80cfd9:	56                   	push   %esi
  80cfda:	e8 4b 78 ff ff       	call   80482a <pbuf_free>
    return;
  80cfdf:	83 c4 10             	add    $0x10,%esp
  80cfe2:	e9 6f 0c 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80cfe7:	83 ec 0c             	sub    $0xc,%esp
  80cfea:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cfef:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cff3:	50                   	push   %eax
  80cff4:	e8 ef a6 ff ff       	call   8076e8 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80cff9:	83 c4 08             	add    $0x8,%esp
  80cffc:	66 c1 e8 0c          	shr    $0xc,%ax
  80d000:	f7 d8                	neg    %eax
  80d002:	c1 e0 02             	shl    $0x2,%eax
  80d005:	98                   	cwtl   
  80d006:	50                   	push   %eax
  80d007:	56                   	push   %esi
  80d008:	e8 4b 77 ff ff       	call   804758 <pbuf_header>
  80d00d:	83 c4 10             	add    $0x10,%esp
  80d010:	84 c0                	test   %al,%al
  80d012:	74 11                	je     80d025 <tcp_input+0x13a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d014:	83 ec 0c             	sub    $0xc,%esp
  80d017:	56                   	push   %esi
  80d018:	e8 0d 78 ff ff       	call   80482a <pbuf_free>
    return;
  80d01d:	83 c4 10             	add    $0x10,%esp
  80d020:	e9 31 0c 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80d025:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d02b:	83 ec 0c             	sub    $0xc,%esp
  80d02e:	0f b7 03             	movzwl (%ebx),%eax
  80d031:	50                   	push   %eax
  80d032:	e8 b1 a6 ff ff       	call   8076e8 <ntohs>
  80d037:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d03a:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d040:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d044:	89 04 24             	mov    %eax,(%esp)
  80d047:	e8 9c a6 ff ff       	call   8076e8 <ntohs>
  80d04c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d050:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d056:	83 c4 04             	add    $0x4,%esp
  80d059:	ff 73 04             	pushl  0x4(%ebx)
  80d05c:	e8 b5 a8 ff ff       	call   807916 <ntohl>
  80d061:	89 43 04             	mov    %eax,0x4(%ebx)
  80d064:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d069:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d06f:	83 c4 04             	add    $0x4,%esp
  80d072:	ff 73 08             	pushl  0x8(%ebx)
  80d075:	e8 9c a8 ff ff       	call   807916 <ntohl>
  80d07a:	89 43 08             	mov    %eax,0x8(%ebx)
  80d07d:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d082:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d088:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d08c:	89 04 24             	mov    %eax,(%esp)
  80d08f:	e8 54 a6 ff ff       	call   8076e8 <ntohs>
  80d094:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d098:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d09d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0a1:	89 04 24             	mov    %eax,(%esp)
  80d0a4:	e8 3f a6 ff ff       	call   8076e8 <ntohs>
  80d0a9:	89 c1                	mov    %eax,%ecx
  80d0ab:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d0af:	83 e0 3f             	and    $0x3f,%eax
  80d0b2:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d0b7:	83 c4 10             	add    $0x10,%esp
  80d0ba:	89 c8                	mov    %ecx,%eax
  80d0bc:	a8 03                	test   $0x3,%al
  80d0be:	0f 95 c0             	setne  %al
  80d0c1:	0f b6 c0             	movzbl %al,%eax
  80d0c4:	66 03 46 08          	add    0x8(%esi),%ax
  80d0c8:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d0cc:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0d2:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d0d7:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80d0da:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d0e0:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0e6:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80d0e8:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0ed:	e9 d1 00 00 00       	jmp    80d1c3 <tcp_input+0x2d8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d0f2:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0f5:	85 c0                	test   %eax,%eax
  80d0f7:	75 17                	jne    80d110 <tcp_input+0x225>
  80d0f9:	83 ec 04             	sub    $0x4,%esp
  80d0fc:	68 6c 2f 81 00       	push   $0x812f6c
  80d101:	68 b5 00 00 00       	push   $0xb5
  80d106:	68 90 30 81 00       	push   $0x813090
  80d10b:	e8 3a 13 00 00       	call   80e44a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d110:	83 f8 0a             	cmp    $0xa,%eax
  80d113:	75 17                	jne    80d12c <tcp_input+0x241>
  80d115:	83 ec 04             	sub    $0x4,%esp
  80d118:	68 94 2f 81 00       	push   $0x812f94
  80d11d:	68 b6 00 00 00       	push   $0xb6
  80d122:	68 90 30 81 00       	push   $0x813090
  80d127:	e8 1e 13 00 00       	call   80e44a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d12c:	83 f8 01             	cmp    $0x1,%eax
  80d12f:	75 17                	jne    80d148 <tcp_input+0x25d>
  80d131:	83 ec 04             	sub    $0x4,%esp
  80d134:	68 c0 2f 81 00       	push   $0x812fc0
  80d139:	68 b7 00 00 00       	push   $0xb7
  80d13e:	68 90 30 81 00       	push   $0x813090
  80d143:	e8 02 13 00 00       	call   80e44a <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80d148:	0f b7 02             	movzwl (%edx),%eax
  80d14b:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d14f:	75 6d                	jne    80d1be <tcp_input+0x2d3>
  80d151:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d155:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d159:	75 63                	jne    80d1be <tcp_input+0x2d3>
       pcb->local_port == tcphdr->dest &&
  80d15b:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d15e:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d161:	75 5b                	jne    80d1be <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d163:	8b 41 10             	mov    0x10(%ecx),%eax
  80d166:	39 03                	cmp    %eax,(%ebx)
  80d168:	75 54                	jne    80d1be <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d16a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d16d:	39 c3                	cmp    %eax,%ebx
  80d16f:	75 17                	jne    80d188 <tcp_input+0x29d>
  80d171:	83 ec 04             	sub    $0x4,%esp
  80d174:	68 e8 2f 81 00       	push   $0x812fe8
  80d179:	68 c0 00 00 00       	push   $0xc0
  80d17e:	68 90 30 81 00       	push   $0x813090
  80d183:	e8 c2 12 00 00       	call   80e44a <_panic>
      if (prev != NULL) {
  80d188:	85 ff                	test   %edi,%edi
  80d18a:	0f 84 80 02 00 00    	je     80d410 <tcp_input+0x525>
        prev->next = pcb->next;
  80d190:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d193:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d196:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d199:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d19f:	39 c3                	cmp    %eax,%ebx
  80d1a1:	0f 85 69 02 00 00    	jne    80d410 <tcp_input+0x525>
  80d1a7:	83 ec 04             	sub    $0x4,%esp
  80d1aa:	68 14 30 81 00       	push   $0x813014
  80d1af:	68 c6 00 00 00       	push   $0xc6
  80d1b4:	68 90 30 81 00       	push   $0x813090
  80d1b9:	e8 8c 12 00 00       	call   80e44a <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1be:	89 df                	mov    %ebx,%edi
  80d1c0:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d1c3:	85 db                	test   %ebx,%ebx
  80d1c5:	0f 85 27 ff ff ff    	jne    80d0f2 <tcp_input+0x207>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1cb:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80d1d1:	e9 88 00 00 00       	jmp    80d25e <tcp_input+0x373>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d1d6:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d1da:	74 17                	je     80d1f3 <tcp_input+0x308>
  80d1dc:	83 ec 04             	sub    $0x4,%esp
  80d1df:	68 40 30 81 00       	push   $0x813040
  80d1e4:	68 d0 00 00 00       	push   $0xd0
  80d1e9:	68 90 30 81 00       	push   $0x813090
  80d1ee:	e8 57 12 00 00       	call   80e44a <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80d1f3:	0f b7 02             	movzwl (%edx),%eax
  80d1f6:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d1fa:	75 5f                	jne    80d25b <tcp_input+0x370>
  80d1fc:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d200:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d204:	75 55                	jne    80d25b <tcp_input+0x370>
         pcb->local_port == tcphdr->dest &&
  80d206:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d209:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d20c:	75 4d                	jne    80d25b <tcp_input+0x370>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d20e:	8b 41 10             	mov    0x10(%ecx),%eax
  80d211:	39 03                	cmp    %eax,(%ebx)
  80d213:	75 46                	jne    80d25b <tcp_input+0x370>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d215:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d219:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d21f:	89 c2                	mov    %eax,%edx
  80d221:	2b 53 24             	sub    0x24(%ebx),%edx
  80d224:	85 d2                	test   %edx,%edx
  80d226:	7e 03                	jle    80d22b <tcp_input+0x340>
    pcb->rcv_nxt = seqno + tcplen;
  80d228:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80d22b:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80d230:	74 10                	je     80d242 <tcp_input+0x357>
    tcp_ack_now(pcb);
  80d232:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d236:	83 ec 0c             	sub    $0xc,%esp
  80d239:	53                   	push   %ebx
  80d23a:	e8 c0 ad ff ff       	call   807fff <tcp_output>
  80d23f:	83 c4 10             	add    $0x10,%esp
  }
  return tcp_output(pcb);
  80d242:	83 ec 0c             	sub    $0xc,%esp
  80d245:	53                   	push   %ebx
  80d246:	e8 b4 ad ff ff       	call   807fff <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80d24b:	89 34 24             	mov    %esi,(%esp)
  80d24e:	e8 d7 75 ff ff       	call   80482a <pbuf_free>
        return;
  80d253:	83 c4 10             	add    $0x10,%esp
  80d256:	e9 fb 09 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d25b:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d25e:	85 db                	test   %ebx,%ebx
  80d260:	0f 85 70 ff ff ff    	jne    80d1d6 <tcp_input+0x2eb>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d266:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d26b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d26e:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80d270:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d275:	e9 89 01 00 00       	jmp    80d403 <tcp_input+0x518>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d27a:	85 db                	test   %ebx,%ebx
  80d27c:	74 0f                	je     80d28d <tcp_input+0x3a2>
  80d27e:	8b 03                	mov    (%ebx),%eax
  80d280:	85 c0                	test   %eax,%eax
  80d282:	74 09                	je     80d28d <tcp_input+0x3a2>
  80d284:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d287:	0f 85 71 01 00 00    	jne    80d3fe <tcp_input+0x513>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d28d:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d291:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d295:	0f 85 63 01 00 00    	jne    80d3fe <tcp_input+0x513>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80d29b:	85 ff                	test   %edi,%edi
  80d29d:	74 12                	je     80d2b1 <tcp_input+0x3c6>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d29f:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d2a2:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d2a5:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d2a8:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d2ab:	89 1d 44 b2 b3 00    	mov    %ebx,0xb3b244
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80d2b1:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80d2b5:	74 35                	je     80d2ec <tcp_input+0x401>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80d2b7:	83 ec 08             	sub    $0x8,%esp
  80d2ba:	0f b7 02             	movzwl (%edx),%eax
  80d2bd:	50                   	push   %eax
  80d2be:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d2c2:	50                   	push   %eax
  80d2c3:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d2c6:	50                   	push   %eax
  80d2c7:	83 c1 10             	add    $0x10,%ecx
  80d2ca:	51                   	push   %ecx
  80d2cb:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d2cf:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d2d5:	50                   	push   %eax
  80d2d6:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d2db:	83 c0 01             	add    $0x1,%eax
  80d2de:	50                   	push   %eax
  80d2df:	e8 92 b1 ff ff       	call   808476 <tcp_rst>
  80d2e4:	83 c4 20             	add    $0x20,%esp
  80d2e7:	e9 01 01 00 00       	jmp    80d3ed <tcp_input+0x502>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80d2ec:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80d2f0:	0f 84 f7 00 00 00    	je     80d3ed <tcp_input+0x502>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80d2f6:	83 ec 0c             	sub    $0xc,%esp
  80d2f9:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80d2fd:	50                   	push   %eax
  80d2fe:	e8 7a 8e ff ff       	call   80617d <tcp_alloc>
  80d303:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80d305:	83 c4 10             	add    $0x10,%esp
  80d308:	85 c0                	test   %eax,%eax
  80d30a:	0f 84 dd 00 00 00    	je     80d3ed <tcp_input+0x502>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d310:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d315:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d318:	74 05                	je     80d31f <tcp_input+0x434>
  80d31a:	8b 50 10             	mov    0x10(%eax),%edx
  80d31d:	eb 05                	jmp    80d324 <tcp_input+0x439>
  80d31f:	ba 00 00 00 00       	mov    $0x0,%edx
  80d324:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80d326:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80d32a:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d32e:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d331:	74 05                	je     80d338 <tcp_input+0x44d>
  80d333:	8b 40 0c             	mov    0xc(%eax),%eax
  80d336:	eb 05                	jmp    80d33d <tcp_input+0x452>
  80d338:	b8 00 00 00 00       	mov    $0x0,%eax
  80d33d:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80d340:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d346:	0f b7 02             	movzwl (%edx),%eax
  80d349:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80d34d:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80d354:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d359:	8d 48 01             	lea    0x1(%eax),%ecx
  80d35c:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80d35f:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d363:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80d367:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d36b:	83 e8 01             	sub    $0x1,%eax
  80d36e:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80d371:	8b 43 18             	mov    0x18(%ebx),%eax
  80d374:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80d377:	8b 43 20             	mov    0x20(%ebx),%eax
  80d37a:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d380:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80d384:	66 25 99 01          	and    $0x199,%ax
  80d388:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80d38c:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d391:	89 47 0c             	mov    %eax,0xc(%edi)
  80d394:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  80d39a:	e8 ca 4e ff ff       	call   802269 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80d39f:	89 f8                	mov    %edi,%eax
  80d3a1:	e8 2d ee ff ff       	call   80c1d3 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d3a6:	83 ec 08             	sub    $0x8,%esp
  80d3a9:	8d 47 04             	lea    0x4(%edi),%eax
  80d3ac:	50                   	push   %eax
  80d3ad:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d3b1:	50                   	push   %eax
  80d3b2:	e8 53 8f ff ff       	call   80630a <tcp_eff_send_mss>
  80d3b7:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80d3bb:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d3c2:	e8 2e a3 ff ff       	call   8076f5 <htonl>
  80d3c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d3ca:	83 c4 0c             	add    $0xc,%esp
  80d3cd:	6a 04                	push   $0x4
  80d3cf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d3d2:	50                   	push   %eax
  80d3d3:	6a 00                	push   $0x0
  80d3d5:	6a 12                	push   $0x12
  80d3d7:	6a 00                	push   $0x0
  80d3d9:	6a 00                	push   $0x0
  80d3db:	57                   	push   %edi
  80d3dc:	e8 45 a5 ff ff       	call   807926 <tcp_enqueue>
    return tcp_output(npcb);
  80d3e1:	83 c4 14             	add    $0x14,%esp
  80d3e4:	57                   	push   %edi
  80d3e5:	e8 15 ac ff ff       	call   807fff <tcp_output>
  80d3ea:	83 c4 10             	add    $0x10,%esp
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80d3ed:	83 ec 0c             	sub    $0xc,%esp
  80d3f0:	56                   	push   %esi
  80d3f1:	e8 34 74 ff ff       	call   80482a <pbuf_free>
        return;
  80d3f6:	83 c4 10             	add    $0x10,%esp
  80d3f9:	e9 58 08 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  80d3fe:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d400:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d403:	85 db                	test   %ebx,%ebx
  80d405:	0f 85 6f fe ff ff    	jne    80d27a <tcp_input+0x38f>
  80d40b:	e9 b5 07 00 00       	jmp    80dbc5 <tcp_input+0xcda>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80d410:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d417:	00 00 00 
    inseg.len = p->tot_len;
  80d41a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d41e:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d424:	8b 46 04             	mov    0x4(%esi),%eax
  80d427:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d42c:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d432:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4

    recv_data = NULL;
  80d438:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d43f:	00 00 00 
    recv_flags = 0;
  80d442:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80d449:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d44f:	85 c0                	test   %eax,%eax
  80d451:	74 45                	je     80d498 <tcp_input+0x5ad>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d453:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d459:	85 d2                	test   %edx,%edx
  80d45b:	74 12                	je     80d46f <tcp_input+0x584>
  80d45d:	6a 00                	push   $0x0
  80d45f:	50                   	push   %eax
  80d460:	53                   	push   %ebx
  80d461:	ff 73 18             	pushl  0x18(%ebx)
  80d464:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d466:	83 c4 10             	add    $0x10,%esp
  80d469:	84 c0                	test   %al,%al
  80d46b:	74 0e                	je     80d47b <tcp_input+0x590>
  80d46d:	eb 18                	jmp    80d487 <tcp_input+0x59c>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d46f:	83 ec 0c             	sub    $0xc,%esp
  80d472:	50                   	push   %eax
  80d473:	e8 b2 73 ff ff       	call   80482a <pbuf_free>
  80d478:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80d47b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d482:	00 00 00 
  80d485:	eb 11                	jmp    80d498 <tcp_input+0x5ad>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80d487:	83 ec 0c             	sub    $0xc,%esp
  80d48a:	56                   	push   %esi
  80d48b:	e8 9a 73 ff ff       	call   80482a <pbuf_free>
        return;
  80d490:	83 c4 10             	add    $0x10,%esp
  80d493:	e9 be 07 00 00       	jmp    80dc56 <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
  80d498:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80d49e:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d4a5:	a8 04                	test   $0x4,%al
  80d4a7:	74 5e                	je     80d507 <tcp_input+0x61c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80d4a9:	8b 53 10             	mov    0x10(%ebx),%edx
  80d4ac:	83 fa 02             	cmp    $0x2,%edx
  80d4af:	75 0f                	jne    80d4c0 <tcp_input+0x5d5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d4b1:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d4b6:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d4b9:	74 3c                	je     80d4f7 <tcp_input+0x60c>
  80d4bb:	e9 b1 05 00 00       	jmp    80da71 <tcp_input+0xb86>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d4c0:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d4c5:	2b 43 24             	sub    0x24(%ebx),%eax
  80d4c8:	0f 88 a3 05 00 00    	js     80da71 <tcp_input+0xb86>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d4ce:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d4d2:	29 c8                	sub    %ecx,%eax
  80d4d4:	85 c0                	test   %eax,%eax
  80d4d6:	0f 8f 46 07 00 00    	jg     80dc22 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d4dc:	85 d2                	test   %edx,%edx
  80d4de:	75 17                	jne    80d4f7 <tcp_input+0x60c>
  80d4e0:	83 ec 04             	sub    $0x4,%esp
  80d4e3:	68 70 30 81 00       	push   $0x813070
  80d4e8:	68 09 02 00 00       	push   $0x209
  80d4ed:	68 90 30 81 00       	push   $0x813090
  80d4f2:	e8 53 0f 00 00       	call   80e44a <_panic>
      recv_flags = TF_RESET;
  80d4f7:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d4fe:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80d502:	e9 1b 07 00 00       	jmp    80dc22 <tcp_input+0xd37>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80d507:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d50d:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d510:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80d517:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d51b:	0f 87 50 05 00 00    	ja     80da71 <tcp_input+0xb86>
  80d521:	8b 53 10             	mov    0x10(%ebx),%edx
  80d524:	ff 24 95 14 31 81 00 	jmp    *0x813114(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d52b:	83 e0 12             	and    $0x12,%eax
  80d52e:	3c 12                	cmp    $0x12,%al
  80d530:	0f 85 04 01 00 00    	jne    80d63a <tcp_input+0x74f>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d536:	83 ec 0c             	sub    $0xc,%esp
  80d539:	8b 43 78             	mov    0x78(%ebx),%eax
  80d53c:	8b 40 10             	mov    0x10(%eax),%eax
  80d53f:	ff 70 04             	pushl  0x4(%eax)
  80d542:	e8 cf a3 ff ff       	call   807916 <ntohl>
  80d547:	8d 50 01             	lea    0x1(%eax),%edx
  80d54a:	83 c4 10             	add    $0x10,%esp
  80d54d:	3b 15 a4 b1 b3 00    	cmp    0xb3b1a4,%edx
  80d553:	0f 85 e1 00 00 00    	jne    80d63a <tcp_input+0x74f>
      pcb->snd_buf++;
  80d559:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d55e:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d563:	8d 48 01             	lea    0x1(%eax),%ecx
  80d566:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d569:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d56c:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d572:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d576:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d57a:	83 e8 01             	sub    $0x1,%eax
  80d57d:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d580:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80d587:	89 d8                	mov    %ebx,%eax
  80d589:	e8 45 ec ff ff       	call   80c1d3 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d58e:	83 ec 08             	sub    $0x8,%esp
  80d591:	8d 43 04             	lea    0x4(%ebx),%eax
  80d594:	50                   	push   %eax
  80d595:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d599:	50                   	push   %eax
  80d59a:	e8 6b 8d ff ff       	call   80630a <tcp_eff_send_mss>
  80d59f:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80d5a3:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d5a6:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d5aa:	83 c4 10             	add    $0x10,%esp
  80d5ad:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80d5b0:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d5b5:	0f 44 c2             	cmove  %edx,%eax
  80d5b8:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d5bc:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d5c0:	66 85 c0             	test   %ax,%ax
  80d5c3:	75 17                	jne    80d5dc <tcp_input+0x6f1>
  80d5c5:	83 ec 04             	sub    $0x4,%esp
  80d5c8:	68 e9 30 81 00       	push   $0x8130e9
  80d5cd:	68 35 02 00 00       	push   $0x235
  80d5d2:	68 90 30 81 00       	push   $0x813090
  80d5d7:	e8 6e 0e 00 00       	call   80e44a <_panic>
      --pcb->snd_queuelen;
  80d5dc:	83 e8 01             	sub    $0x1,%eax
  80d5df:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80d5e3:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d5e6:	8b 10                	mov    (%eax),%edx
  80d5e8:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d5eb:	85 d2                	test   %edx,%edx
  80d5ed:	75 08                	jne    80d5f7 <tcp_input+0x70c>
        pcb->rtime = -1;
  80d5ef:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d5f5:	eb 0a                	jmp    80d601 <tcp_input+0x716>
      else {
        pcb->rtime = 0;
  80d5f7:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d5fd:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80d601:	83 ec 0c             	sub    $0xc,%esp
  80d604:	50                   	push   %eax
  80d605:	e8 66 81 ff ff       	call   805770 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d60a:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d610:	83 c4 10             	add    $0x10,%esp
  80d613:	85 c0                	test   %eax,%eax
  80d615:	74 0e                	je     80d625 <tcp_input+0x73a>
  80d617:	83 ec 04             	sub    $0x4,%esp
  80d61a:	6a 00                	push   $0x0
  80d61c:	53                   	push   %ebx
  80d61d:	ff 73 18             	pushl  0x18(%ebx)
  80d620:	ff d0                	call   *%eax
  80d622:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d625:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d629:	83 ec 0c             	sub    $0xc,%esp
  80d62c:	53                   	push   %ebx
  80d62d:	e8 cd a9 ff ff       	call   807fff <tcp_output>
  80d632:	83 c4 10             	add    $0x10,%esp
  80d635:	e9 e8 05 00 00       	jmp    80dc22 <tcp_input+0xd37>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80d63a:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d641:	0f 84 db 05 00 00    	je     80dc22 <tcp_input+0xd37>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80d647:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d64d:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d652:	83 ec 08             	sub    $0x8,%esp
  80d655:	0f b7 0a             	movzwl (%edx),%ecx
  80d658:	51                   	push   %ecx
  80d659:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d65d:	52                   	push   %edx
  80d65e:	8d 50 0c             	lea    0xc(%eax),%edx
  80d661:	52                   	push   %edx
  80d662:	83 c0 10             	add    $0x10,%eax
  80d665:	50                   	push   %eax
  80d666:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d66d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d673:	50                   	push   %eax
  80d674:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d67a:	e8 f7 ad ff ff       	call   808476 <tcp_rst>
  80d67f:	83 c4 20             	add    $0x20,%esp
  80d682:	e9 9b 05 00 00       	jmp    80dc22 <tcp_input+0xd37>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80d687:	83 e0 14             	and    $0x14,%eax
  80d68a:	3c 10                	cmp    $0x10,%al
  80d68c:	0f 85 90 05 00 00    	jne    80dc22 <tcp_input+0xd37>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d692:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d698:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d69b:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d69e:	0f 88 b5 00 00 00    	js     80d759 <tcp_input+0x86e>
  80d6a4:	89 d0                	mov    %edx,%eax
  80d6a6:	2b 43 54             	sub    0x54(%ebx),%eax
  80d6a9:	85 c0                	test   %eax,%eax
  80d6ab:	0f 8f a8 00 00 00    	jg     80d759 <tcp_input+0x86e>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80d6b1:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d6b8:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d6be:	85 c0                	test   %eax,%eax
  80d6c0:	75 17                	jne    80d6d9 <tcp_input+0x7ee>
  80d6c2:	83 ec 04             	sub    $0x4,%esp
  80d6c5:	68 ff 30 81 00       	push   $0x8130ff
  80d6ca:	68 5b 02 00 00       	push   $0x25b
  80d6cf:	68 90 30 81 00       	push   $0x813090
  80d6d4:	e8 71 0d 00 00       	call   80e44a <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d6d9:	83 ec 04             	sub    $0x4,%esp
  80d6dc:	6a 00                	push   $0x0
  80d6de:	53                   	push   %ebx
  80d6df:	ff 73 18             	pushl  0x18(%ebx)
  80d6e2:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d6e4:	83 c4 10             	add    $0x10,%esp
  80d6e7:	84 c0                	test   %al,%al
  80d6e9:	74 1b                	je     80d706 <tcp_input+0x81b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80d6eb:	83 ec 0c             	sub    $0xc,%esp
  80d6ee:	53                   	push   %ebx
  80d6ef:	e8 f5 84 ff ff       	call   805be9 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d6f4:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d6fb:	00 00 00 
  80d6fe:	83 c4 10             	add    $0x10,%esp
  80d701:	e9 97 04 00 00       	jmp    80db9d <tcp_input+0xcb2>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80d706:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80d70a:	89 d8                	mov    %ebx,%eax
  80d70c:	e8 75 eb ff ff       	call   80c286 <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d711:	66 83 fe 01          	cmp    $0x1,%si
  80d715:	75 09                	jne    80d720 <tcp_input+0x835>
  80d717:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d71b:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d71e:	eb 04                	jmp    80d724 <tcp_input+0x839>
  80d720:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d724:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80d728:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d72f:	0f 84 ed 04 00 00    	je     80dc22 <tcp_input+0xd37>
  80d735:	84 c0                	test   %al,%al
  80d737:	0f 84 e5 04 00 00    	je     80dc22 <tcp_input+0xd37>
          tcp_ack_now(pcb);
  80d73d:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d741:	83 ec 0c             	sub    $0xc,%esp
  80d744:	53                   	push   %ebx
  80d745:	e8 b5 a8 ff ff       	call   807fff <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d74a:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d751:	83 c4 10             	add    $0x10,%esp
  80d754:	e9 c9 04 00 00       	jmp    80dc22 <tcp_input+0xd37>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80d759:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d75f:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d764:	83 ec 08             	sub    $0x8,%esp
  80d767:	0f b7 31             	movzwl (%ecx),%esi
  80d76a:	56                   	push   %esi
  80d76b:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d76f:	51                   	push   %ecx
  80d770:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d773:	51                   	push   %ecx
  80d774:	83 c0 10             	add    $0x10,%eax
  80d777:	50                   	push   %eax
  80d778:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d77f:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d785:	50                   	push   %eax
  80d786:	52                   	push   %edx
  80d787:	e8 ea ac ff ff       	call   808476 <tcp_rst>
  80d78c:	83 c4 20             	add    $0x20,%esp
  80d78f:	e9 8e 04 00 00       	jmp    80dc22 <tcp_input+0xd37>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80d794:	89 d8                	mov    %ebx,%eax
  80d796:	e8 eb ea ff ff       	call   80c286 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d79b:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d7a2:	0f 84 7a 04 00 00    	je     80dc22 <tcp_input+0xd37>
  80d7a8:	84 c0                	test   %al,%al
  80d7aa:	0f 84 72 04 00 00    	je     80dc22 <tcp_input+0xd37>
      tcp_ack_now(pcb);
  80d7b0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7b4:	83 ec 0c             	sub    $0xc,%esp
  80d7b7:	53                   	push   %ebx
  80d7b8:	e8 42 a8 ff ff       	call   807fff <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d7bd:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d7c4:	83 c4 10             	add    $0x10,%esp
  80d7c7:	e9 56 04 00 00       	jmp    80dc22 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80d7cc:	89 d8                	mov    %ebx,%eax
  80d7ce:	e8 b3 ea ff ff       	call   80c286 <tcp_receive>
    if (flags & TCP_FIN) {
  80d7d3:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d7da:	a8 01                	test   $0x1,%al
  80d7dc:	0f 84 cf 00 00 00    	je     80d8b1 <tcp_input+0x9c6>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d7e2:	a8 10                	test   $0x10,%al
  80d7e4:	0f 84 ab 00 00 00    	je     80d895 <tcp_input+0x9aa>
  80d7ea:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d7ef:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d7f2:	0f 85 9d 00 00 00    	jne    80d895 <tcp_input+0x9aa>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80d7f8:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7fc:	83 ec 0c             	sub    $0xc,%esp
  80d7ff:	53                   	push   %ebx
  80d800:	e8 fa a7 ff ff       	call   807fff <tcp_output>
        tcp_pcb_purge(pcb);
  80d805:	89 1c 24             	mov    %ebx,(%esp)
  80d808:	e8 83 80 ff ff       	call   805890 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d80d:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d812:	83 c4 10             	add    $0x10,%esp
  80d815:	39 c3                	cmp    %eax,%ebx
  80d817:	75 0a                	jne    80d823 <tcp_input+0x938>
  80d819:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d81c:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d821:	eb 53                	jmp    80d876 <tcp_input+0x98b>
  80d823:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d828:	ba 00 00 00 00       	mov    $0x0,%edx
  80d82d:	89 de                	mov    %ebx,%esi
  80d82f:	89 d7                	mov    %edx,%edi
  80d831:	eb 2d                	jmp    80d860 <tcp_input+0x975>
  80d833:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d836:	39 ce                	cmp    %ecx,%esi
  80d838:	0f 94 c3             	sete   %bl
  80d83b:	85 c9                	test   %ecx,%ecx
  80d83d:	0f 95 c2             	setne  %dl
  80d840:	84 d3                	test   %dl,%bl
  80d842:	74 15                	je     80d859 <tcp_input+0x96e>
  80d844:	89 f3                	mov    %esi,%ebx
  80d846:	89 fa                	mov    %edi,%edx
  80d848:	84 d2                	test   %dl,%dl
  80d84a:	74 05                	je     80d851 <tcp_input+0x966>
  80d84c:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d851:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d854:	89 50 0c             	mov    %edx,0xc(%eax)
  80d857:	eb 1d                	jmp    80d876 <tcp_input+0x98b>
  80d859:	bf 01 00 00 00       	mov    $0x1,%edi
  80d85e:	89 c8                	mov    %ecx,%eax
  80d860:	85 c0                	test   %eax,%eax
  80d862:	75 cf                	jne    80d833 <tcp_input+0x948>
  80d864:	89 f3                	mov    %esi,%ebx
  80d866:	89 fa                	mov    %edi,%edx
  80d868:	84 d2                	test   %dl,%dl
  80d86a:	74 0a                	je     80d876 <tcp_input+0x98b>
  80d86c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d873:	00 00 00 
        pcb->state = TIME_WAIT;
  80d876:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d87d:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d882:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d885:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d88b:	e8 d9 49 ff ff       	call   802269 <tcp_timer_needed>
  80d890:	e9 8d 03 00 00       	jmp    80dc22 <tcp_input+0xd37>
      } else {
        tcp_ack_now(pcb);
  80d895:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d899:	83 ec 0c             	sub    $0xc,%esp
  80d89c:	53                   	push   %ebx
  80d89d:	e8 5d a7 ff ff       	call   807fff <tcp_output>
        pcb->state = CLOSING;
  80d8a2:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d8a9:	83 c4 10             	add    $0x10,%esp
  80d8ac:	e9 71 03 00 00       	jmp    80dc22 <tcp_input+0xd37>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d8b1:	a8 10                	test   $0x10,%al
  80d8b3:	0f 84 69 03 00 00    	je     80dc22 <tcp_input+0xd37>
  80d8b9:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d8be:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d8c1:	0f 85 5b 03 00 00    	jne    80dc22 <tcp_input+0xd37>
      pcb->state = FIN_WAIT_2;
  80d8c7:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80d8ce:	e9 4f 03 00 00       	jmp    80dc22 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80d8d3:	89 d8                	mov    %ebx,%eax
  80d8d5:	e8 ac e9 ff ff       	call   80c286 <tcp_receive>
    if (flags & TCP_FIN) {
  80d8da:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d8e1:	0f 84 3b 03 00 00    	je     80dc22 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d8e7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8eb:	83 ec 0c             	sub    $0xc,%esp
  80d8ee:	53                   	push   %ebx
  80d8ef:	e8 0b a7 ff ff       	call   807fff <tcp_output>
      tcp_pcb_purge(pcb);
  80d8f4:	89 1c 24             	mov    %ebx,(%esp)
  80d8f7:	e8 94 7f ff ff       	call   805890 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d8fc:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d901:	83 c4 10             	add    $0x10,%esp
  80d904:	39 c3                	cmp    %eax,%ebx
  80d906:	75 0a                	jne    80d912 <tcp_input+0xa27>
  80d908:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d90b:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d910:	eb 53                	jmp    80d965 <tcp_input+0xa7a>
  80d912:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d917:	b9 00 00 00 00       	mov    $0x0,%ecx
  80d91c:	89 de                	mov    %ebx,%esi
  80d91e:	89 cf                	mov    %ecx,%edi
  80d920:	eb 2d                	jmp    80d94f <tcp_input+0xa64>
  80d922:	8b 50 0c             	mov    0xc(%eax),%edx
  80d925:	85 d2                	test   %edx,%edx
  80d927:	0f 95 c3             	setne  %bl
  80d92a:	39 d6                	cmp    %edx,%esi
  80d92c:	0f 94 c1             	sete   %cl
  80d92f:	84 cb                	test   %cl,%bl
  80d931:	74 15                	je     80d948 <tcp_input+0xa5d>
  80d933:	89 f3                	mov    %esi,%ebx
  80d935:	89 f9                	mov    %edi,%ecx
  80d937:	84 c9                	test   %cl,%cl
  80d939:	74 05                	je     80d940 <tcp_input+0xa55>
  80d93b:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d940:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d943:	89 50 0c             	mov    %edx,0xc(%eax)
  80d946:	eb 1d                	jmp    80d965 <tcp_input+0xa7a>
  80d948:	bf 01 00 00 00       	mov    $0x1,%edi
  80d94d:	89 d0                	mov    %edx,%eax
  80d94f:	85 c0                	test   %eax,%eax
  80d951:	75 cf                	jne    80d922 <tcp_input+0xa37>
  80d953:	89 f3                	mov    %esi,%ebx
  80d955:	89 f9                	mov    %edi,%ecx
  80d957:	84 c9                	test   %cl,%cl
  80d959:	74 0a                	je     80d965 <tcp_input+0xa7a>
  80d95b:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d962:	00 00 00 
      pcb->state = TIME_WAIT;
  80d965:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d96c:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d971:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d974:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d97a:	e8 ea 48 ff ff       	call   802269 <tcp_timer_needed>
  80d97f:	e9 9e 02 00 00       	jmp    80dc22 <tcp_input+0xd37>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80d984:	89 d8                	mov    %ebx,%eax
  80d986:	e8 fb e8 ff ff       	call   80c286 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d98b:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d992:	0f 84 8a 02 00 00    	je     80dc22 <tcp_input+0xd37>
  80d998:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d99d:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d9a0:	0f 85 7c 02 00 00    	jne    80dc22 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d9a6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d9aa:	83 ec 0c             	sub    $0xc,%esp
  80d9ad:	53                   	push   %ebx
  80d9ae:	e8 4c a6 ff ff       	call   807fff <tcp_output>
      tcp_pcb_purge(pcb);
  80d9b3:	89 1c 24             	mov    %ebx,(%esp)
  80d9b6:	e8 d5 7e ff ff       	call   805890 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d9bb:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d9c0:	83 c4 10             	add    $0x10,%esp
  80d9c3:	39 c3                	cmp    %eax,%ebx
  80d9c5:	75 0a                	jne    80d9d1 <tcp_input+0xae6>
  80d9c7:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d9ca:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d9cf:	eb 53                	jmp    80da24 <tcp_input+0xb39>
  80d9d1:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d9d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80d9db:	89 de                	mov    %ebx,%esi
  80d9dd:	89 d7                	mov    %edx,%edi
  80d9df:	eb 2d                	jmp    80da0e <tcp_input+0xb23>
  80d9e1:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d9e4:	39 ce                	cmp    %ecx,%esi
  80d9e6:	0f 94 c3             	sete   %bl
  80d9e9:	85 c9                	test   %ecx,%ecx
  80d9eb:	0f 95 c2             	setne  %dl
  80d9ee:	84 d3                	test   %dl,%bl
  80d9f0:	74 15                	je     80da07 <tcp_input+0xb1c>
  80d9f2:	89 f3                	mov    %esi,%ebx
  80d9f4:	89 fa                	mov    %edi,%edx
  80d9f6:	84 d2                	test   %dl,%dl
  80d9f8:	74 05                	je     80d9ff <tcp_input+0xb14>
  80d9fa:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d9ff:	8b 53 0c             	mov    0xc(%ebx),%edx
  80da02:	89 50 0c             	mov    %edx,0xc(%eax)
  80da05:	eb 1d                	jmp    80da24 <tcp_input+0xb39>
  80da07:	bf 01 00 00 00       	mov    $0x1,%edi
  80da0c:	89 c8                	mov    %ecx,%eax
  80da0e:	85 c0                	test   %eax,%eax
  80da10:	75 cf                	jne    80d9e1 <tcp_input+0xaf6>
  80da12:	89 f3                	mov    %esi,%ebx
  80da14:	89 fa                	mov    %edi,%edx
  80da16:	84 d2                	test   %dl,%dl
  80da18:	74 0a                	je     80da24 <tcp_input+0xb39>
  80da1a:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80da21:	00 00 00 
      pcb->state = TIME_WAIT;
  80da24:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80da2b:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80da30:	89 43 0c             	mov    %eax,0xc(%ebx)
  80da33:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80da39:	e8 2b 48 ff ff       	call   802269 <tcp_timer_needed>
  80da3e:	e9 df 01 00 00       	jmp    80dc22 <tcp_input+0xd37>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80da43:	89 d8                	mov    %ebx,%eax
  80da45:	e8 3c e8 ff ff       	call   80c286 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80da4a:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80da51:	0f 84 cb 01 00 00    	je     80dc22 <tcp_input+0xd37>
  80da57:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da5c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da5f:	0f 85 bd 01 00 00    	jne    80dc22 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80da65:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80da6c:	e9 b1 01 00 00       	jmp    80dc22 <tcp_input+0xd37>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80da71:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80da78:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80da7b:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80da82:	a8 08                	test   $0x8,%al
  80da84:	74 38                	je     80dabe <tcp_input+0xbd3>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80da86:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80da8c:	85 c0                	test   %eax,%eax
  80da8e:	74 0d                	je     80da9d <tcp_input+0xbb2>
  80da90:	83 ec 08             	sub    $0x8,%esp
  80da93:	6a fa                	push   $0xfffffffa
  80da95:	ff 73 18             	pushl  0x18(%ebx)
  80da98:	ff d0                	call   *%eax
  80da9a:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80da9d:	83 ec 08             	sub    $0x8,%esp
  80daa0:	53                   	push   %ebx
  80daa1:	68 3c b2 b3 00       	push   $0xb3b23c
  80daa6:	e8 60 7e ff ff       	call   80590b <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80daab:	83 c4 08             	add    $0x8,%esp
  80daae:	53                   	push   %ebx
  80daaf:	6a 02                	push   $0x2
  80dab1:	e8 01 6a ff ff       	call   8044b7 <memp_free>
  80dab6:	83 c4 10             	add    $0x10,%esp
  80dab9:	e9 df 00 00 00       	jmp    80db9d <tcp_input+0xcb2>
      } else if (recv_flags & TF_CLOSED) {
  80dabe:	a8 10                	test   $0x10,%al
  80dac0:	74 21                	je     80dae3 <tcp_input+0xbf8>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dac2:	83 ec 08             	sub    $0x8,%esp
  80dac5:	53                   	push   %ebx
  80dac6:	68 3c b2 b3 00       	push   $0xb3b23c
  80dacb:	e8 3b 7e ff ff       	call   80590b <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80dad0:	83 c4 08             	add    $0x8,%esp
  80dad3:	53                   	push   %ebx
  80dad4:	6a 02                	push   $0x2
  80dad6:	e8 dc 69 ff ff       	call   8044b7 <memp_free>
  80dadb:	83 c4 10             	add    $0x10,%esp
  80dade:	e9 ba 00 00 00       	jmp    80db9d <tcp_input+0xcb2>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80dae3:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80dae7:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80daec:	66 85 d2             	test   %dx,%dx
  80daef:	74 1a                	je     80db0b <tcp_input+0xc20>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80daf1:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80daf7:	85 c9                	test   %ecx,%ecx
  80daf9:	74 10                	je     80db0b <tcp_input+0xc20>
  80dafb:	83 ec 04             	sub    $0x4,%esp
  80dafe:	0f b7 d2             	movzwl %dx,%edx
  80db01:	52                   	push   %edx
  80db02:	53                   	push   %ebx
  80db03:	ff 73 18             	pushl  0x18(%ebx)
  80db06:	ff d1                	call   *%ecx
  80db08:	83 c4 10             	add    $0x10,%esp
        }
      
        if (recv_data != NULL) {
  80db0b:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80db11:	85 d2                	test   %edx,%edx
  80db13:	74 58                	je     80db6d <tcp_input+0xc82>
          if(flags & TCP_PSH) {
  80db15:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80db1c:	0f 84 0f 01 00 00    	je     80dc31 <tcp_input+0xd46>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80db22:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80db26:	e9 06 01 00 00       	jmp    80dc31 <tcp_input+0xd46>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80db2b:	6a 00                	push   $0x0
  80db2d:	52                   	push   %edx
  80db2e:	53                   	push   %ebx
  80db2f:	ff 73 18             	pushl  0x18(%ebx)
  80db32:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80db34:	83 c4 10             	add    $0x10,%esp
  80db37:	84 c0                	test   %al,%al
  80db39:	75 1c                	jne    80db57 <tcp_input+0xc6c>
  80db3b:	e9 04 01 00 00       	jmp    80dc44 <tcp_input+0xd59>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80db40:	83 ec 0c             	sub    $0xc,%esp
  80db43:	52                   	push   %edx
  80db44:	e8 e1 6c ff ff       	call   80482a <pbuf_free>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80db49:	83 c4 10             	add    $0x10,%esp
  80db4c:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db53:	75 21                	jne    80db76 <tcp_input+0xc8b>
  80db55:	eb 3a                	jmp    80db91 <tcp_input+0xca6>
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80db57:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80db5c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80db62:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db69:	74 32                	je     80db9d <tcp_input+0xcb2>
  80db6b:	eb 09                	jmp    80db76 <tcp_input+0xc8b>
  80db6d:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db74:	74 17                	je     80db8d <tcp_input+0xca2>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80db76:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80db7c:	85 c0                	test   %eax,%eax
  80db7e:	74 11                	je     80db91 <tcp_input+0xca6>
  80db80:	6a 00                	push   $0x0
  80db82:	6a 00                	push   $0x0
  80db84:	53                   	push   %ebx
  80db85:	ff 73 18             	pushl  0x18(%ebx)
  80db88:	ff d0                	call   *%eax
  80db8a:	83 c4 10             	add    $0x10,%esp
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80db8d:	84 c0                	test   %al,%al
  80db8f:	75 0c                	jne    80db9d <tcp_input+0xcb2>
          tcp_output(pcb);
  80db91:	83 ec 0c             	sub    $0xc,%esp
  80db94:	53                   	push   %ebx
  80db95:	e8 65 a4 ff ff       	call   807fff <tcp_output>
  80db9a:	83 c4 10             	add    $0x10,%esp
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80db9d:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80dba2:	85 c0                	test   %eax,%eax
  80dba4:	0f 84 ac 00 00 00    	je     80dc56 <tcp_input+0xd6b>
    {
      pbuf_free(inseg.p);
  80dbaa:	83 ec 0c             	sub    $0xc,%esp
  80dbad:	50                   	push   %eax
  80dbae:	e8 77 6c ff ff       	call   80482a <pbuf_free>
      inseg.p = NULL;
  80dbb3:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80dbba:	00 00 00 
  80dbbd:	83 c4 10             	add    $0x10,%esp
  80dbc0:	e9 91 00 00 00       	jmp    80dc56 <tcp_input+0xd6b>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dbc5:	83 ec 0c             	sub    $0xc,%esp
  80dbc8:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80dbcc:	50                   	push   %eax
  80dbcd:	e8 16 9b ff ff       	call   8076e8 <ntohs>
  80dbd2:	83 c4 10             	add    $0x10,%esp
  80dbd5:	a8 04                	test   $0x4,%al
  80dbd7:	75 3b                	jne    80dc14 <tcp_input+0xd29>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80dbd9:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80dbdf:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80dbe4:	83 ec 08             	sub    $0x8,%esp
  80dbe7:	0f b7 0a             	movzwl (%edx),%ecx
  80dbea:	51                   	push   %ecx
  80dbeb:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dbef:	52                   	push   %edx
  80dbf0:	8d 50 0c             	lea    0xc(%eax),%edx
  80dbf3:	52                   	push   %edx
  80dbf4:	83 c0 10             	add    $0x10,%eax
  80dbf7:	50                   	push   %eax
  80dbf8:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dbff:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dc05:	50                   	push   %eax
  80dc06:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80dc0c:	e8 65 a8 ff ff       	call   808476 <tcp_rst>
  80dc11:	83 c4 20             	add    $0x20,%esp
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80dc14:	83 ec 0c             	sub    $0xc,%esp
  80dc17:	56                   	push   %esi
  80dc18:	e8 0d 6c ff ff       	call   80482a <pbuf_free>
  80dc1d:	83 c4 10             	add    $0x10,%esp
  80dc20:	eb 34                	jmp    80dc56 <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80dc22:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dc29:	00 00 00 
  80dc2c:	e9 4a fe ff ff       	jmp    80da7b <tcp_input+0xb90>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dc31:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dc37:	85 c0                	test   %eax,%eax
  80dc39:	0f 85 ec fe ff ff    	jne    80db2b <tcp_input+0xc40>
  80dc3f:	e9 fc fe ff ff       	jmp    80db40 <tcp_input+0xc55>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80dc44:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dc4b:	0f 85 25 ff ff ff    	jne    80db76 <tcp_input+0xc8b>
  80dc51:	e9 3b ff ff ff       	jmp    80db91 <tcp_input+0xca6>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80dc56:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dc59:	5b                   	pop    %ebx
  80dc5a:	5e                   	pop    %esi
  80dc5b:	5f                   	pop    %edi
  80dc5c:	5d                   	pop    %ebp
  80dc5d:	c3                   	ret    

0080dc5e <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dc5e:	55                   	push   %ebp
  80dc5f:	89 e5                	mov    %esp,%ebp
  80dc61:	57                   	push   %edi
  80dc62:	56                   	push   %esi
  80dc63:	53                   	push   %ebx
  80dc64:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dc67:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc6a:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80dc6d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dc70:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80dc74:	50                   	push   %eax
  80dc75:	e8 6e 9a ff ff       	call   8076e8 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80dc7a:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc80:	83 c4 10             	add    $0x10,%esp
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80dc83:	be 00 00 00 00       	mov    $0x0,%esi
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80dc88:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80dc8f:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dc92:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dc95:	83 c0 0c             	add    $0xc,%eax
  80dc98:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc9b:	eb 5d                	jmp    80dcfa <raw_input+0x9c>
    if (pcb->protocol == proto) {
  80dc9d:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dca1:	39 f8                	cmp    %edi,%eax
  80dca3:	75 4f                	jne    80dcf4 <raw_input+0x96>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80dca5:	8b 43 14             	mov    0x14(%ebx),%eax
  80dca8:	85 c0                	test   %eax,%eax
  80dcaa:	74 48                	je     80dcf4 <raw_input+0x96>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dcac:	ff 75 e0             	pushl  -0x20(%ebp)
  80dcaf:	ff 75 08             	pushl  0x8(%ebp)
  80dcb2:	53                   	push   %ebx
  80dcb3:	ff 73 18             	pushl  0x18(%ebx)
  80dcb6:	ff d0                	call   *%eax
  80dcb8:	83 c4 10             	add    $0x10,%esp
  80dcbb:	84 c0                	test   %al,%al
  80dcbd:	74 35                	je     80dcf4 <raw_input+0x96>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80dcbf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dcc2:	85 d2                	test   %edx,%edx
  80dcc4:	74 22                	je     80dce8 <raw_input+0x8a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80dcc6:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dcc9:	89 42 0c             	mov    %eax,0xc(%edx)
            pcb->next = raw_pcbs;
  80dccc:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dcd1:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dcd4:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80dcda:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dcdf:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dce6:	eb 0c                	jmp    80dcf4 <raw_input+0x96>
          eaten = 1;
  80dce8:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dced:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dcf4:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dcf7:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dcfa:	89 f0                	mov    %esi,%eax
  80dcfc:	84 c0                	test   %al,%al
  80dcfe:	75 04                	jne    80dd04 <raw_input+0xa6>
  80dd00:	85 db                	test   %ebx,%ebx
  80dd02:	75 99                	jne    80dc9d <raw_input+0x3f>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80dd04:	89 f0                	mov    %esi,%eax
  80dd06:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dd09:	5b                   	pop    %ebx
  80dd0a:	5e                   	pop    %esi
  80dd0b:	5f                   	pop    %edi
  80dd0c:	5d                   	pop    %ebp
  80dd0d:	c3                   	ret    

0080dd0e <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dd0e:	55                   	push   %ebp
  80dd0f:	89 e5                	mov    %esp,%ebp
  80dd11:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80dd14:	85 c0                	test   %eax,%eax
  80dd16:	74 04                	je     80dd1c <raw_bind+0xe>
  80dd18:	8b 10                	mov    (%eax),%edx
  80dd1a:	eb 05                	jmp    80dd21 <raw_bind+0x13>
  80dd1c:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd21:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd24:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80dd26:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd2b:	5d                   	pop    %ebp
  80dd2c:	c3                   	ret    

0080dd2d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dd2d:	55                   	push   %ebp
  80dd2e:	89 e5                	mov    %esp,%ebp
  80dd30:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80dd33:	85 c0                	test   %eax,%eax
  80dd35:	74 04                	je     80dd3b <raw_connect+0xe>
  80dd37:	8b 10                	mov    (%eax),%edx
  80dd39:	eb 05                	jmp    80dd40 <raw_connect+0x13>
  80dd3b:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd40:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd43:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80dd46:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd4b:	5d                   	pop    %ebp
  80dd4c:	c3                   	ret    

0080dd4d <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dd4d:	55                   	push   %ebp
  80dd4e:	89 e5                	mov    %esp,%ebp
  80dd50:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dd53:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dd56:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80dd59:	8b 55 10             	mov    0x10(%ebp),%edx
  80dd5c:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dd5f:	5d                   	pop    %ebp
  80dd60:	c3                   	ret    

0080dd61 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dd61:	55                   	push   %ebp
  80dd62:	89 e5                	mov    %esp,%ebp
  80dd64:	57                   	push   %edi
  80dd65:	56                   	push   %esi
  80dd66:	53                   	push   %ebx
  80dd67:	83 ec 14             	sub    $0x14,%esp
  80dd6a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dd6d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80dd70:	6a 14                	push   $0x14
  80dd72:	57                   	push   %edi
  80dd73:	e8 e0 69 ff ff       	call   804758 <pbuf_header>
  80dd78:	83 c4 10             	add    $0x10,%esp
  80dd7b:	84 c0                	test   %al,%al
  80dd7d:	74 39                	je     80ddb8 <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80dd7f:	83 ec 04             	sub    $0x4,%esp
  80dd82:	6a 00                	push   $0x0
  80dd84:	6a 00                	push   $0x0
  80dd86:	6a 01                	push   $0x1
  80dd88:	e8 63 6b ff ff       	call   8048f0 <pbuf_alloc>
  80dd8d:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dd8f:	83 c4 10             	add    $0x10,%esp
  80dd92:	85 c0                	test   %eax,%eax
  80dd94:	0f 84 a6 00 00 00    	je     80de40 <raw_sendto+0xdf>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80dd9a:	83 ec 08             	sub    $0x8,%esp
  80dd9d:	57                   	push   %edi
  80dd9e:	50                   	push   %eax
  80dd9f:	e8 7a 6f ff ff       	call   804d1e <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dda4:	83 c4 04             	add    $0x4,%esp
  80dda7:	ff 75 10             	pushl  0x10(%ebp)
  80ddaa:	e8 70 87 ff ff       	call   80651f <ip_route>
  80ddaf:	83 c4 10             	add    $0x10,%esp
  80ddb2:	85 c0                	test   %eax,%eax
  80ddb4:	75 46                	jne    80ddfc <raw_sendto+0x9b>
  80ddb6:	eb 2d                	jmp    80dde5 <raw_sendto+0x84>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80ddb8:	83 ec 08             	sub    $0x8,%esp
  80ddbb:	6a ec                	push   $0xffffffec
  80ddbd:	57                   	push   %edi
  80ddbe:	e8 95 69 ff ff       	call   804758 <pbuf_header>
  80ddc3:	83 c4 10             	add    $0x10,%esp
  80ddc6:	84 c0                	test   %al,%al
  80ddc8:	0f 84 87 00 00 00    	je     80de55 <raw_sendto+0xf4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80ddce:	83 ec 04             	sub    $0x4,%esp
  80ddd1:	68 3c 31 81 00       	push   $0x81313c
  80ddd6:	68 e3 00 00 00       	push   $0xe3
  80dddb:	68 62 31 81 00       	push   $0x813162
  80dde0:	e8 65 06 00 00       	call   80e44a <_panic>
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80dde5:	39 f7                	cmp    %esi,%edi
  80dde7:	74 5e                	je     80de47 <raw_sendto+0xe6>
      pbuf_free(q);
  80dde9:	83 ec 0c             	sub    $0xc,%esp
  80ddec:	56                   	push   %esi
  80dded:	e8 38 6a ff ff       	call   80482a <pbuf_free>
  80ddf2:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80ddf5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ddfa:	eb 6f                	jmp    80de6b <raw_sendto+0x10a>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80ddfc:	89 da                	mov    %ebx,%edx
  80ddfe:	85 db                	test   %ebx,%ebx
  80de00:	74 05                	je     80de07 <raw_sendto+0xa6>
  80de02:	83 3b 00             	cmpl   $0x0,(%ebx)
  80de05:	75 03                	jne    80de0a <raw_sendto+0xa9>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80de07:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80de0a:	83 ec 04             	sub    $0x4,%esp
  80de0d:	50                   	push   %eax
  80de0e:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80de12:	50                   	push   %eax
  80de13:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80de17:	50                   	push   %eax
  80de18:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80de1c:	50                   	push   %eax
  80de1d:	ff 75 10             	pushl  0x10(%ebp)
  80de20:	52                   	push   %edx
  80de21:	56                   	push   %esi
  80de22:	e8 5a 8a ff ff       	call   806881 <ip_output_if>
  80de27:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80de29:	83 c4 20             	add    $0x20,%esp
  80de2c:	39 f7                	cmp    %esi,%edi
  80de2e:	74 3b                	je     80de6b <raw_sendto+0x10a>
    /* free the header */
    pbuf_free(q);
  80de30:	83 ec 0c             	sub    $0xc,%esp
  80de33:	56                   	push   %esi
  80de34:	e8 f1 69 ff ff       	call   80482a <pbuf_free>
  80de39:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  80de3c:	89 d8                	mov    %ebx,%eax
  80de3e:	eb 2b                	jmp    80de6b <raw_sendto+0x10a>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80de40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80de45:	eb 24                	jmp    80de6b <raw_sendto+0x10a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80de47:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80de4c:	eb 1d                	jmp    80de6b <raw_sendto+0x10a>
  80de4e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80de53:	eb 16                	jmp    80de6b <raw_sendto+0x10a>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80de55:	83 ec 0c             	sub    $0xc,%esp
  80de58:	ff 75 10             	pushl  0x10(%ebp)
  80de5b:	e8 bf 86 ff ff       	call   80651f <ip_route>
  80de60:	83 c4 10             	add    $0x10,%esp
  80de63:	85 c0                	test   %eax,%eax
  80de65:	74 e7                	je     80de4e <raw_sendto+0xed>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80de67:	89 fe                	mov    %edi,%esi
  80de69:	eb 91                	jmp    80ddfc <raw_sendto+0x9b>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80de6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80de6e:	5b                   	pop    %ebx
  80de6f:	5e                   	pop    %esi
  80de70:	5f                   	pop    %edi
  80de71:	5d                   	pop    %ebp
  80de72:	c3                   	ret    

0080de73 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80de73:	55                   	push   %ebp
  80de74:	89 e5                	mov    %esp,%ebp
  80de76:	83 ec 0c             	sub    $0xc,%esp
  80de79:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80de7c:	8d 50 04             	lea    0x4(%eax),%edx
  80de7f:	52                   	push   %edx
  80de80:	ff 75 0c             	pushl  0xc(%ebp)
  80de83:	50                   	push   %eax
  80de84:	e8 d8 fe ff ff       	call   80dd61 <raw_sendto>
}
  80de89:	c9                   	leave  
  80de8a:	c3                   	ret    

0080de8b <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80de8b:	55                   	push   %ebp
  80de8c:	89 e5                	mov    %esp,%ebp
  80de8e:	83 ec 08             	sub    $0x8,%esp
  80de91:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80de94:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80de99:	39 c8                	cmp    %ecx,%eax
  80de9b:	75 1e                	jne    80debb <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80de9d:	8b 40 0c             	mov    0xc(%eax),%eax
  80dea0:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
  80dea5:	eb 18                	jmp    80debf <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80dea7:	8b 50 0c             	mov    0xc(%eax),%edx
  80deaa:	39 d1                	cmp    %edx,%ecx
  80deac:	75 0a                	jne    80deb8 <raw_remove+0x2d>
  80deae:	85 d2                	test   %edx,%edx
  80deb0:	74 06                	je     80deb8 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80deb2:	8b 51 0c             	mov    0xc(%ecx),%edx
  80deb5:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80deb8:	8b 40 0c             	mov    0xc(%eax),%eax
  80debb:	85 c0                	test   %eax,%eax
  80debd:	75 e8                	jne    80dea7 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80debf:	83 ec 08             	sub    $0x8,%esp
  80dec2:	51                   	push   %ecx
  80dec3:	6a 00                	push   $0x0
  80dec5:	e8 ed 65 ff ff       	call   8044b7 <memp_free>
}
  80deca:	83 c4 10             	add    $0x10,%esp
  80decd:	c9                   	leave  
  80dece:	c3                   	ret    

0080decf <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80decf:	55                   	push   %ebp
  80ded0:	89 e5                	mov    %esp,%ebp
  80ded2:	56                   	push   %esi
  80ded3:	53                   	push   %ebx
  80ded4:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80ded7:	83 ec 0c             	sub    $0xc,%esp
  80deda:	6a 00                	push   $0x0
  80dedc:	e8 80 65 ff ff       	call   804461 <memp_malloc>
  80dee1:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80dee3:	83 c4 10             	add    $0x10,%esp
  80dee6:	85 c0                	test   %eax,%eax
  80dee8:	74 27                	je     80df11 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80deea:	83 ec 04             	sub    $0x4,%esp
  80deed:	6a 1c                	push   $0x1c
  80deef:	6a 00                	push   $0x0
  80def1:	50                   	push   %eax
  80def2:	e8 f6 0c 00 00       	call   80ebed <memset>
    pcb->protocol = proto;
  80def7:	89 f0                	mov    %esi,%eax
  80def9:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80defc:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80df00:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80df05:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80df08:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80df0e:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80df11:	89 d8                	mov    %ebx,%eax
  80df13:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80df16:	5b                   	pop    %ebx
  80df17:	5e                   	pop    %esi
  80df18:	5d                   	pop    %ebp
  80df19:	c3                   	ret    

0080df1a <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80df1a:	55                   	push   %ebp
  80df1b:	89 e5                	mov    %esp,%ebp
  80df1d:	57                   	push   %edi
  80df1e:	56                   	push   %esi
  80df1f:	53                   	push   %ebx
  80df20:	83 ec 28             	sub    $0x28,%esp
  80df23:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80df26:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80df29:	0f b7 07             	movzwl (%edi),%eax
  80df2c:	50                   	push   %eax
  80df2d:	e8 b6 97 ff ff       	call   8076e8 <ntohs>
  80df32:	66 c1 e8 06          	shr    $0x6,%ax
  80df36:	83 e0 3c             	and    $0x3c,%eax
  80df39:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80df3d:	89 c6                	mov    %eax,%esi
  80df3f:	f7 de                	neg    %esi
  80df41:	0f bf f6             	movswl %si,%esi
  80df44:	83 c4 08             	add    $0x8,%esp
  80df47:	56                   	push   %esi
  80df48:	53                   	push   %ebx
  80df49:	e8 0a 68 ff ff       	call   804758 <pbuf_header>
  80df4e:	83 c4 10             	add    $0x10,%esp
  80df51:	84 c0                	test   %al,%al
  80df53:	0f 85 b1 02 00 00    	jne    80e20a <icmp_input+0x2f0>
  80df59:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80df5e:	0f 86 a6 02 00 00    	jbe    80e20a <icmp_input+0x2f0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80df64:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80df67:	80 38 08             	cmpb   $0x8,(%eax)
  80df6a:	0f 85 8c 02 00 00    	jne    80e1fc <icmp_input+0x2e2>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80df70:	83 ec 08             	sub    $0x8,%esp
  80df73:	ff 75 0c             	pushl  0xc(%ebp)
  80df76:	8d 47 10             	lea    0x10(%edi),%eax
  80df79:	50                   	push   %eax
  80df7a:	e8 54 85 ff ff       	call   8064d3 <ip_addr_isbroadcast>
  80df7f:	83 c4 10             	add    $0x10,%esp
  80df82:	84 c0                	test   %al,%al
  80df84:	75 2d                	jne    80dfb3 <icmp_input+0x99>
  80df86:	8b 47 10             	mov    0x10(%edi),%eax
  80df89:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80df8c:	83 ec 0c             	sub    $0xc,%esp
  80df8f:	68 00 00 00 f0       	push   $0xf0000000
  80df94:	e8 7d 99 ff ff       	call   807916 <ntohl>
  80df99:	23 45 e0             	and    -0x20(%ebp),%eax
  80df9c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80df9f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80dfa6:	e8 6b 99 ff ff       	call   807916 <ntohl>
  80dfab:	83 c4 10             	add    $0x10,%esp
  80dfae:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80dfb1:	75 11                	jne    80dfc4 <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80dfb3:	83 ec 0c             	sub    $0xc,%esp
  80dfb6:	53                   	push   %ebx
  80dfb7:	e8 6e 68 ff ff       	call   80482a <pbuf_free>
      return;
  80dfbc:	83 c4 10             	add    $0x10,%esp
  80dfbf:	e9 60 02 00 00       	jmp    80e224 <icmp_input+0x30a>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80dfc4:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80dfc9:	0f 86 3b 02 00 00    	jbe    80e20a <icmp_input+0x2f0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80dfcf:	83 ec 0c             	sub    $0xc,%esp
  80dfd2:	53                   	push   %ebx
  80dfd3:	e8 f4 95 ff ff       	call   8075cc <inet_chksum_pbuf>
  80dfd8:	83 c4 10             	add    $0x10,%esp
  80dfdb:	66 85 c0             	test   %ax,%ax
  80dfde:	74 11                	je     80dff1 <icmp_input+0xd7>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80dfe0:	83 ec 0c             	sub    $0xc,%esp
  80dfe3:	53                   	push   %ebx
  80dfe4:	e8 41 68 ff ff       	call   80482a <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80dfe9:	83 c4 10             	add    $0x10,%esp
  80dfec:	e9 33 02 00 00       	jmp    80e224 <icmp_input+0x30a>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80dff1:	83 ec 08             	sub    $0x8,%esp
  80dff4:	6a 22                	push   $0x22
  80dff6:	53                   	push   %ebx
  80dff7:	e8 5c 67 ff ff       	call   804758 <pbuf_header>
  80dffc:	83 c4 10             	add    $0x10,%esp
  80dfff:	84 c0                	test   %al,%al
  80e001:	0f 84 d7 00 00 00    	je     80e0de <icmp_input+0x1c4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80e007:	83 ec 08             	sub    $0x8,%esp
  80e00a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e00e:	50                   	push   %eax
  80e00f:	53                   	push   %ebx
  80e010:	e8 43 67 ff ff       	call   804758 <pbuf_header>
  80e015:	83 c4 10             	add    $0x10,%esp
  80e018:	84 c0                	test   %al,%al
  80e01a:	74 14                	je     80e030 <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e01c:	83 ec 04             	sub    $0x4,%esp
  80e01f:	68 78 31 81 00       	push   $0x813178
  80e024:	6a 7b                	push   $0x7b
  80e026:	68 6c 32 81 00       	push   $0x81326c
  80e02b:	e8 1a 04 00 00       	call   80e44a <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e030:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e034:	83 ec 04             	sub    $0x4,%esp
  80e037:	6a 00                	push   $0x0
  80e039:	50                   	push   %eax
  80e03a:	6a 02                	push   $0x2
  80e03c:	e8 af 68 ff ff       	call   8048f0 <pbuf_alloc>
  80e041:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e044:	83 c4 10             	add    $0x10,%esp
  80e047:	85 c0                	test   %eax,%eax
  80e049:	0f 84 c9 01 00 00    	je     80e218 <icmp_input+0x2fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e04f:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e053:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e057:	83 c0 08             	add    $0x8,%eax
  80e05a:	39 c2                	cmp    %eax,%edx
  80e05c:	73 17                	jae    80e075 <icmp_input+0x15b>
  80e05e:	83 ec 04             	sub    $0x4,%esp
  80e061:	68 ac 31 81 00       	push   $0x8131ac
  80e066:	68 85 00 00 00       	push   $0x85
  80e06b:	68 6c 32 81 00       	push   $0x81326c
  80e070:	e8 d5 03 00 00       	call   80e44a <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80e075:	83 ec 08             	sub    $0x8,%esp
  80e078:	53                   	push   %ebx
  80e079:	ff 75 e0             	pushl  -0x20(%ebp)
  80e07c:	e8 6d 6d ff ff       	call   804dee <pbuf_copy>
  80e081:	83 c4 10             	add    $0x10,%esp
  80e084:	84 c0                	test   %al,%al
  80e086:	74 17                	je     80e09f <icmp_input+0x185>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e088:	83 ec 04             	sub    $0x4,%esp
  80e08b:	68 e4 31 81 00       	push   $0x8131e4
  80e090:	68 88 00 00 00       	push   $0x88
  80e095:	68 6c 32 81 00       	push   $0x81326c
  80e09a:	e8 ab 03 00 00       	call   80e44a <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80e09f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e0a2:	8b 78 04             	mov    0x4(%eax),%edi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80e0a5:	83 ec 08             	sub    $0x8,%esp
  80e0a8:	56                   	push   %esi
  80e0a9:	50                   	push   %eax
  80e0aa:	e8 a9 66 ff ff       	call   804758 <pbuf_header>
  80e0af:	83 c4 10             	add    $0x10,%esp
  80e0b2:	84 c0                	test   %al,%al
  80e0b4:	74 17                	je     80e0cd <icmp_input+0x1b3>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e0b6:	83 ec 04             	sub    $0x4,%esp
  80e0b9:	68 0c 32 81 00       	push   $0x81320c
  80e0be:	68 8e 00 00 00       	push   $0x8e
  80e0c3:	68 6c 32 81 00       	push   $0x81326c
  80e0c8:	e8 7d 03 00 00       	call   80e44a <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80e0cd:	83 ec 0c             	sub    $0xc,%esp
  80e0d0:	53                   	push   %ebx
  80e0d1:	e8 54 67 ff ff       	call   80482a <pbuf_free>
  80e0d6:	83 c4 10             	add    $0x10,%esp
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80e0d9:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e0dc:	eb 29                	jmp    80e107 <icmp_input+0x1ed>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e0de:	83 ec 08             	sub    $0x8,%esp
  80e0e1:	6a de                	push   $0xffffffde
  80e0e3:	53                   	push   %ebx
  80e0e4:	e8 6f 66 ff ff       	call   804758 <pbuf_header>
  80e0e9:	83 c4 10             	add    $0x10,%esp
  80e0ec:	84 c0                	test   %al,%al
  80e0ee:	74 17                	je     80e107 <icmp_input+0x1ed>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e0f0:	83 ec 04             	sub    $0x4,%esp
  80e0f3:	68 0c 32 81 00       	push   $0x81320c
  80e0f8:	68 98 00 00 00       	push   $0x98
  80e0fd:	68 6c 32 81 00       	push   $0x81326c
  80e102:	e8 43 03 00 00       	call   80e44a <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80e107:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e10a:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e10d:	8b 57 10             	mov    0x10(%edi),%edx
  80e110:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e113:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e116:	83 ec 0c             	sub    $0xc,%esp
  80e119:	0f b7 06             	movzwl (%esi),%eax
  80e11c:	50                   	push   %eax
  80e11d:	e8 c6 95 ff ff       	call   8076e8 <ntohs>
  80e122:	0f b6 c0             	movzbl %al,%eax
  80e125:	89 04 24             	mov    %eax,(%esp)
  80e128:	e8 ae 95 ff ff       	call   8076db <htons>
  80e12d:	66 89 06             	mov    %ax,(%esi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e130:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e134:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e138:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e13f:	e8 97 95 ff ff       	call   8076db <htons>
  80e144:	83 c4 10             	add    $0x10,%esp
  80e147:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e14b:	72 1c                	jb     80e169 <icmp_input+0x24f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e14d:	83 ec 0c             	sub    $0xc,%esp
  80e150:	68 00 08 00 00       	push   $0x800
  80e155:	e8 81 95 ff ff       	call   8076db <htons>
  80e15a:	0f b7 c0             	movzwl %ax,%eax
  80e15d:	83 c0 01             	add    $0x1,%eax
  80e160:	66 01 46 02          	add    %ax,0x2(%esi)
  80e164:	83 c4 10             	add    $0x10,%esp
  80e167:	eb 14                	jmp    80e17d <icmp_input+0x263>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e169:	83 ec 0c             	sub    $0xc,%esp
  80e16c:	68 00 08 00 00       	push   $0x800
  80e171:	e8 65 95 ff ff       	call   8076db <htons>
  80e176:	66 01 46 02          	add    %ax,0x2(%esi)
  80e17a:	83 c4 10             	add    $0x10,%esp
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e17d:	83 ec 0c             	sub    $0xc,%esp
  80e180:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e184:	50                   	push   %eax
  80e185:	e8 5e 95 ff ff       	call   8076e8 <ntohs>
  80e18a:	66 0d 00 ff          	or     $0xff00,%ax
  80e18e:	0f b7 c0             	movzwl %ax,%eax
  80e191:	89 04 24             	mov    %eax,(%esp)
  80e194:	e8 42 95 ff ff       	call   8076db <htons>
  80e199:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e19d:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e1a3:	83 c4 08             	add    $0x8,%esp
  80e1a6:	6a 14                	push   $0x14
  80e1a8:	57                   	push   %edi
  80e1a9:	e8 08 94 ff ff       	call   8075b6 <inet_chksum>
  80e1ae:	66 89 47 0a          	mov    %ax,0xa(%edi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80e1b2:	83 c4 08             	add    $0x8,%esp
  80e1b5:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e1b9:	50                   	push   %eax
  80e1ba:	53                   	push   %ebx
  80e1bb:	e8 98 65 ff ff       	call   804758 <pbuf_header>
  80e1c0:	83 c4 10             	add    $0x10,%esp
  80e1c3:	84 c0                	test   %al,%al
  80e1c5:	74 17                	je     80e1de <icmp_input+0x2c4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e1c7:	83 ec 04             	sub    $0x4,%esp
  80e1ca:	68 d4 22 81 00       	push   $0x8122d4
  80e1cf:	68 b9 00 00 00       	push   $0xb9
  80e1d4:	68 6c 32 81 00       	push   $0x81326c
  80e1d9:	e8 6c 02 00 00       	call   80e44a <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e1de:	83 ec 04             	sub    $0x4,%esp
  80e1e1:	ff 75 0c             	pushl  0xc(%ebp)
  80e1e4:	6a 01                	push   $0x1
  80e1e6:	6a 00                	push   $0x0
  80e1e8:	68 ff 00 00 00       	push   $0xff
  80e1ed:	6a 00                	push   $0x0
  80e1ef:	83 c7 0c             	add    $0xc,%edi
  80e1f2:	57                   	push   %edi
  80e1f3:	53                   	push   %ebx
  80e1f4:	e8 88 86 ff ff       	call   806881 <ip_output_if>
  80e1f9:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e1fc:	83 ec 0c             	sub    $0xc,%esp
  80e1ff:	53                   	push   %ebx
  80e200:	e8 25 66 ff ff       	call   80482a <pbuf_free>
  return;
  80e205:	83 c4 10             	add    $0x10,%esp
  80e208:	eb 1a                	jmp    80e224 <icmp_input+0x30a>
lenerr:
  pbuf_free(p);
  80e20a:	83 ec 0c             	sub    $0xc,%esp
  80e20d:	53                   	push   %ebx
  80e20e:	e8 17 66 ff ff       	call   80482a <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e213:	83 c4 10             	add    $0x10,%esp
  80e216:	eb 0c                	jmp    80e224 <icmp_input+0x30a>
memerr:
  pbuf_free(p);
  80e218:	83 ec 0c             	sub    $0xc,%esp
  80e21b:	53                   	push   %ebx
  80e21c:	e8 09 66 ff ff       	call   80482a <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  80e221:	83 c4 10             	add    $0x10,%esp
}
  80e224:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e227:	5b                   	pop    %ebx
  80e228:	5e                   	pop    %esi
  80e229:	5f                   	pop    %edi
  80e22a:	5d                   	pop    %ebp
  80e22b:	c3                   	ret    

0080e22c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e22c:	55                   	push   %ebp
  80e22d:	89 e5                	mov    %esp,%ebp
  80e22f:	57                   	push   %edi
  80e230:	56                   	push   %esi
  80e231:	53                   	push   %ebx
  80e232:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e235:	6a 00                	push   $0x0
  80e237:	6a 24                	push   $0x24
  80e239:	6a 01                	push   $0x1
  80e23b:	e8 b0 66 ff ff       	call   8048f0 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e240:	83 c4 10             	add    $0x10,%esp
  80e243:	85 c0                	test   %eax,%eax
  80e245:	0f 84 b8 00 00 00    	je     80e303 <icmp_dest_unreach+0xd7>
  80e24b:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e24d:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e252:	77 17                	ja     80e26b <icmp_dest_unreach+0x3f>
  80e254:	83 ec 04             	sub    $0x4,%esp
  80e257:	68 40 32 81 00       	push   $0x813240
  80e25c:	68 ef 00 00 00       	push   $0xef
  80e261:	68 6c 32 81 00       	push   $0x81326c
  80e266:	e8 df 01 00 00       	call   80e44a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e26b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e26e:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e271:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e274:	83 ec 0c             	sub    $0xc,%esp
  80e277:	0f b7 06             	movzwl (%esi),%eax
  80e27a:	50                   	push   %eax
  80e27b:	e8 68 94 ff ff       	call   8076e8 <ntohs>
  80e280:	0f b6 c0             	movzbl %al,%eax
  80e283:	80 cc 03             	or     $0x3,%ah
  80e286:	89 04 24             	mov    %eax,(%esp)
  80e289:	e8 4d 94 ff ff       	call   8076db <htons>
  80e28e:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e291:	0f b7 c0             	movzwl %ax,%eax
  80e294:	89 04 24             	mov    %eax,(%esp)
  80e297:	e8 4c 94 ff ff       	call   8076e8 <ntohs>
  80e29c:	b0 00                	mov    $0x0,%al
  80e29e:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e2a2:	0f b7 c0             	movzwl %ax,%eax
  80e2a5:	89 04 24             	mov    %eax,(%esp)
  80e2a8:	e8 2e 94 ff ff       	call   8076db <htons>
  80e2ad:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e2b0:	83 c4 0c             	add    $0xc,%esp
  80e2b3:	6a 1c                	push   $0x1c
  80e2b5:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2b8:	ff 70 04             	pushl  0x4(%eax)
  80e2bb:	8b 43 04             	mov    0x4(%ebx),%eax
  80e2be:	83 c0 08             	add    $0x8,%eax
  80e2c1:	50                   	push   %eax
  80e2c2:	e8 db 09 00 00       	call   80eca2 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e2c7:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e2cd:	83 c4 08             	add    $0x8,%esp
  80e2d0:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e2d4:	50                   	push   %eax
  80e2d5:	56                   	push   %esi
  80e2d6:	e8 db 92 ff ff       	call   8075b6 <inet_chksum>
  80e2db:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e2df:	83 c4 08             	add    $0x8,%esp
  80e2e2:	6a 01                	push   $0x1
  80e2e4:	6a 00                	push   $0x0
  80e2e6:	68 ff 00 00 00       	push   $0xff
  80e2eb:	83 c7 0c             	add    $0xc,%edi
  80e2ee:	57                   	push   %edi
  80e2ef:	6a 00                	push   $0x0
  80e2f1:	53                   	push   %ebx
  80e2f2:	e8 12 87 ff ff       	call   806a09 <ip_output>
  pbuf_free(q);
  80e2f7:	83 c4 14             	add    $0x14,%esp
  80e2fa:	53                   	push   %ebx
  80e2fb:	e8 2a 65 ff ff       	call   80482a <pbuf_free>
  80e300:	83 c4 10             	add    $0x10,%esp
}
  80e303:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e306:	5b                   	pop    %ebx
  80e307:	5e                   	pop    %esi
  80e308:	5f                   	pop    %edi
  80e309:	5d                   	pop    %ebp
  80e30a:	c3                   	ret    

0080e30b <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e30b:	55                   	push   %ebp
  80e30c:	89 e5                	mov    %esp,%ebp
  80e30e:	57                   	push   %edi
  80e30f:	56                   	push   %esi
  80e310:	53                   	push   %ebx
  80e311:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e314:	6a 00                	push   $0x0
  80e316:	6a 24                	push   $0x24
  80e318:	6a 01                	push   $0x1
  80e31a:	e8 d1 65 ff ff       	call   8048f0 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e31f:	83 c4 10             	add    $0x10,%esp
  80e322:	85 c0                	test   %eax,%eax
  80e324:	0f 84 b8 00 00 00    	je     80e3e2 <icmp_time_exceeded+0xd7>
  80e32a:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e32c:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e331:	77 17                	ja     80e34a <icmp_time_exceeded+0x3f>
  80e333:	83 ec 04             	sub    $0x4,%esp
  80e336:	68 40 32 81 00       	push   $0x813240
  80e33b:	68 1e 01 00 00       	push   $0x11e
  80e340:	68 6c 32 81 00       	push   $0x81326c
  80e345:	e8 00 01 00 00       	call   80e44a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e34a:	8b 45 08             	mov    0x8(%ebp),%eax
  80e34d:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e350:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e353:	83 ec 0c             	sub    $0xc,%esp
  80e356:	0f b7 06             	movzwl (%esi),%eax
  80e359:	50                   	push   %eax
  80e35a:	e8 89 93 ff ff       	call   8076e8 <ntohs>
  80e35f:	0f b6 c0             	movzbl %al,%eax
  80e362:	80 cc 0b             	or     $0xb,%ah
  80e365:	89 04 24             	mov    %eax,(%esp)
  80e368:	e8 6e 93 ff ff       	call   8076db <htons>
  80e36d:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e370:	0f b7 c0             	movzwl %ax,%eax
  80e373:	89 04 24             	mov    %eax,(%esp)
  80e376:	e8 6d 93 ff ff       	call   8076e8 <ntohs>
  80e37b:	b0 00                	mov    $0x0,%al
  80e37d:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e381:	0f b7 c0             	movzwl %ax,%eax
  80e384:	89 04 24             	mov    %eax,(%esp)
  80e387:	e8 4f 93 ff ff       	call   8076db <htons>
  80e38c:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e38f:	83 c4 0c             	add    $0xc,%esp
  80e392:	6a 1c                	push   $0x1c
  80e394:	8b 45 08             	mov    0x8(%ebp),%eax
  80e397:	ff 70 04             	pushl  0x4(%eax)
  80e39a:	8b 43 04             	mov    0x4(%ebx),%eax
  80e39d:	83 c0 08             	add    $0x8,%eax
  80e3a0:	50                   	push   %eax
  80e3a1:	e8 fc 08 00 00       	call   80eca2 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e3a6:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e3ac:	83 c4 08             	add    $0x8,%esp
  80e3af:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e3b3:	50                   	push   %eax
  80e3b4:	56                   	push   %esi
  80e3b5:	e8 fc 91 ff ff       	call   8075b6 <inet_chksum>
  80e3ba:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e3be:	83 c4 08             	add    $0x8,%esp
  80e3c1:	6a 01                	push   $0x1
  80e3c3:	6a 00                	push   $0x0
  80e3c5:	68 ff 00 00 00       	push   $0xff
  80e3ca:	83 c7 0c             	add    $0xc,%edi
  80e3cd:	57                   	push   %edi
  80e3ce:	6a 00                	push   $0x0
  80e3d0:	53                   	push   %ebx
  80e3d1:	e8 33 86 ff ff       	call   806a09 <ip_output>
  pbuf_free(q);
  80e3d6:	83 c4 14             	add    $0x14,%esp
  80e3d9:	53                   	push   %ebx
  80e3da:	e8 4b 64 ff ff       	call   80482a <pbuf_free>
  80e3df:	83 c4 10             	add    $0x10,%esp
}
  80e3e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e3e5:	5b                   	pop    %ebx
  80e3e6:	5e                   	pop    %esi
  80e3e7:	5f                   	pop    %edi
  80e3e8:	5d                   	pop    %ebp
  80e3e9:	c3                   	ret    

0080e3ea <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e3ea:	55                   	push   %ebp
  80e3eb:	89 e5                	mov    %esp,%ebp
  80e3ed:	56                   	push   %esi
  80e3ee:	53                   	push   %ebx
  80e3ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e3f2:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e3f5:	e8 73 0a 00 00       	call   80ee6d <sys_getenvid>
  80e3fa:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e3ff:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e402:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e407:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e40c:	85 db                	test   %ebx,%ebx
  80e40e:	7e 07                	jle    80e417 <libmain+0x2d>
		binaryname = argv[0];
  80e410:	8b 06                	mov    (%esi),%eax
  80e412:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e417:	83 ec 08             	sub    $0x8,%esp
  80e41a:	56                   	push   %esi
  80e41b:	53                   	push   %ebx
  80e41c:	e8 38 21 ff ff       	call   800559 <umain>

	// exit gracefully
	exit();
  80e421:	e8 0a 00 00 00       	call   80e430 <exit>
}
  80e426:	83 c4 10             	add    $0x10,%esp
  80e429:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e42c:	5b                   	pop    %ebx
  80e42d:	5e                   	pop    %esi
  80e42e:	5d                   	pop    %ebp
  80e42f:	c3                   	ret    

0080e430 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e430:	55                   	push   %ebp
  80e431:	89 e5                	mov    %esp,%ebp
  80e433:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e436:	e8 bb 12 00 00       	call   80f6f6 <close_all>
	sys_env_destroy(0);
  80e43b:	83 ec 0c             	sub    $0xc,%esp
  80e43e:	6a 00                	push   $0x0
  80e440:	e8 e7 09 00 00       	call   80ee2c <sys_env_destroy>
}
  80e445:	83 c4 10             	add    $0x10,%esp
  80e448:	c9                   	leave  
  80e449:	c3                   	ret    

0080e44a <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e44a:	55                   	push   %ebp
  80e44b:	89 e5                	mov    %esp,%ebp
  80e44d:	56                   	push   %esi
  80e44e:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e44f:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e452:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e458:	e8 10 0a 00 00       	call   80ee6d <sys_getenvid>
  80e45d:	83 ec 0c             	sub    $0xc,%esp
  80e460:	ff 75 0c             	pushl  0xc(%ebp)
  80e463:	ff 75 08             	pushl  0x8(%ebp)
  80e466:	56                   	push   %esi
  80e467:	50                   	push   %eax
  80e468:	68 90 32 81 00       	push   $0x813290
  80e46d:	e8 b1 00 00 00       	call   80e523 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e472:	83 c4 18             	add    $0x18,%esp
  80e475:	53                   	push   %ebx
  80e476:	ff 75 10             	pushl  0x10(%ebp)
  80e479:	e8 54 00 00 00       	call   80e4d2 <vcprintf>
	cprintf("\n");
  80e47e:	c7 04 24 0b 0f 81 00 	movl   $0x810f0b,(%esp)
  80e485:	e8 99 00 00 00       	call   80e523 <cprintf>
  80e48a:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e48d:	cc                   	int3   
  80e48e:	eb fd                	jmp    80e48d <_panic+0x43>

0080e490 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e490:	55                   	push   %ebp
  80e491:	89 e5                	mov    %esp,%ebp
  80e493:	53                   	push   %ebx
  80e494:	83 ec 04             	sub    $0x4,%esp
  80e497:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e49a:	8b 13                	mov    (%ebx),%edx
  80e49c:	8d 42 01             	lea    0x1(%edx),%eax
  80e49f:	89 03                	mov    %eax,(%ebx)
  80e4a1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e4a4:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e4a8:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e4ad:	75 1a                	jne    80e4c9 <putch+0x39>
		sys_cputs(b->buf, b->idx);
  80e4af:	83 ec 08             	sub    $0x8,%esp
  80e4b2:	68 ff 00 00 00       	push   $0xff
  80e4b7:	8d 43 08             	lea    0x8(%ebx),%eax
  80e4ba:	50                   	push   %eax
  80e4bb:	e8 2f 09 00 00       	call   80edef <sys_cputs>
		b->idx = 0;
  80e4c0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e4c6:	83 c4 10             	add    $0x10,%esp
	}
	b->cnt++;
  80e4c9:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e4cd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e4d0:	c9                   	leave  
  80e4d1:	c3                   	ret    

0080e4d2 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e4d2:	55                   	push   %ebp
  80e4d3:	89 e5                	mov    %esp,%ebp
  80e4d5:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e4db:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e4e2:	00 00 00 
	b.cnt = 0;
  80e4e5:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e4ec:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e4ef:	ff 75 0c             	pushl  0xc(%ebp)
  80e4f2:	ff 75 08             	pushl  0x8(%ebp)
  80e4f5:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e4fb:	50                   	push   %eax
  80e4fc:	68 90 e4 80 00       	push   $0x80e490
  80e501:	e8 54 01 00 00       	call   80e65a <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e506:	83 c4 08             	add    $0x8,%esp
  80e509:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e50f:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e515:	50                   	push   %eax
  80e516:	e8 d4 08 00 00       	call   80edef <sys_cputs>

	return b.cnt;
}
  80e51b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e521:	c9                   	leave  
  80e522:	c3                   	ret    

0080e523 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e523:	55                   	push   %ebp
  80e524:	89 e5                	mov    %esp,%ebp
  80e526:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e529:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e52c:	50                   	push   %eax
  80e52d:	ff 75 08             	pushl  0x8(%ebp)
  80e530:	e8 9d ff ff ff       	call   80e4d2 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e535:	c9                   	leave  
  80e536:	c3                   	ret    

0080e537 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e537:	55                   	push   %ebp
  80e538:	89 e5                	mov    %esp,%ebp
  80e53a:	57                   	push   %edi
  80e53b:	56                   	push   %esi
  80e53c:	53                   	push   %ebx
  80e53d:	83 ec 1c             	sub    $0x1c,%esp
  80e540:	89 c7                	mov    %eax,%edi
  80e542:	89 d6                	mov    %edx,%esi
  80e544:	8b 45 08             	mov    0x8(%ebp),%eax
  80e547:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e54a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e54d:	89 55 dc             	mov    %edx,-0x24(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e550:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e553:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e558:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e55b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e55e:	39 d3                	cmp    %edx,%ebx
  80e560:	72 05                	jb     80e567 <printnum+0x30>
  80e562:	39 45 10             	cmp    %eax,0x10(%ebp)
  80e565:	77 45                	ja     80e5ac <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e567:	83 ec 0c             	sub    $0xc,%esp
  80e56a:	ff 75 18             	pushl  0x18(%ebp)
  80e56d:	8b 45 14             	mov    0x14(%ebp),%eax
  80e570:	8d 58 ff             	lea    -0x1(%eax),%ebx
  80e573:	53                   	push   %ebx
  80e574:	ff 75 10             	pushl  0x10(%ebp)
  80e577:	83 ec 08             	sub    $0x8,%esp
  80e57a:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e57d:	ff 75 e0             	pushl  -0x20(%ebp)
  80e580:	ff 75 dc             	pushl  -0x24(%ebp)
  80e583:	ff 75 d8             	pushl  -0x28(%ebp)
  80e586:	e8 65 24 00 00       	call   8109f0 <__udivdi3>
  80e58b:	83 c4 18             	add    $0x18,%esp
  80e58e:	52                   	push   %edx
  80e58f:	50                   	push   %eax
  80e590:	89 f2                	mov    %esi,%edx
  80e592:	89 f8                	mov    %edi,%eax
  80e594:	e8 9e ff ff ff       	call   80e537 <printnum>
  80e599:	83 c4 20             	add    $0x20,%esp
  80e59c:	eb 18                	jmp    80e5b6 <printnum+0x7f>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e59e:	83 ec 08             	sub    $0x8,%esp
  80e5a1:	56                   	push   %esi
  80e5a2:	ff 75 18             	pushl  0x18(%ebp)
  80e5a5:	ff d7                	call   *%edi
  80e5a7:	83 c4 10             	add    $0x10,%esp
  80e5aa:	eb 03                	jmp    80e5af <printnum+0x78>
  80e5ac:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80e5af:	83 eb 01             	sub    $0x1,%ebx
  80e5b2:	85 db                	test   %ebx,%ebx
  80e5b4:	7f e8                	jg     80e59e <printnum+0x67>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e5b6:	83 ec 08             	sub    $0x8,%esp
  80e5b9:	56                   	push   %esi
  80e5ba:	83 ec 04             	sub    $0x4,%esp
  80e5bd:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e5c0:	ff 75 e0             	pushl  -0x20(%ebp)
  80e5c3:	ff 75 dc             	pushl  -0x24(%ebp)
  80e5c6:	ff 75 d8             	pushl  -0x28(%ebp)
  80e5c9:	e8 52 25 00 00       	call   810b20 <__umoddi3>
  80e5ce:	83 c4 14             	add    $0x14,%esp
  80e5d1:	0f be 80 b3 32 81 00 	movsbl 0x8132b3(%eax),%eax
  80e5d8:	50                   	push   %eax
  80e5d9:	ff d7                	call   *%edi
}
  80e5db:	83 c4 10             	add    $0x10,%esp
  80e5de:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e5e1:	5b                   	pop    %ebx
  80e5e2:	5e                   	pop    %esi
  80e5e3:	5f                   	pop    %edi
  80e5e4:	5d                   	pop    %ebp
  80e5e5:	c3                   	ret    

0080e5e6 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80e5e6:	55                   	push   %ebp
  80e5e7:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80e5e9:	83 fa 01             	cmp    $0x1,%edx
  80e5ec:	7e 0e                	jle    80e5fc <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80e5ee:	8b 10                	mov    (%eax),%edx
  80e5f0:	8d 4a 08             	lea    0x8(%edx),%ecx
  80e5f3:	89 08                	mov    %ecx,(%eax)
  80e5f5:	8b 02                	mov    (%edx),%eax
  80e5f7:	8b 52 04             	mov    0x4(%edx),%edx
  80e5fa:	eb 22                	jmp    80e61e <getuint+0x38>
	else if (lflag)
  80e5fc:	85 d2                	test   %edx,%edx
  80e5fe:	74 10                	je     80e610 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80e600:	8b 10                	mov    (%eax),%edx
  80e602:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e605:	89 08                	mov    %ecx,(%eax)
  80e607:	8b 02                	mov    (%edx),%eax
  80e609:	ba 00 00 00 00       	mov    $0x0,%edx
  80e60e:	eb 0e                	jmp    80e61e <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80e610:	8b 10                	mov    (%eax),%edx
  80e612:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e615:	89 08                	mov    %ecx,(%eax)
  80e617:	8b 02                	mov    (%edx),%eax
  80e619:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80e61e:	5d                   	pop    %ebp
  80e61f:	c3                   	ret    

0080e620 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e620:	55                   	push   %ebp
  80e621:	89 e5                	mov    %esp,%ebp
  80e623:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e626:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e62a:	8b 10                	mov    (%eax),%edx
  80e62c:	3b 50 04             	cmp    0x4(%eax),%edx
  80e62f:	73 0a                	jae    80e63b <sprintputch+0x1b>
		*b->buf++ = ch;
  80e631:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e634:	89 08                	mov    %ecx,(%eax)
  80e636:	8b 45 08             	mov    0x8(%ebp),%eax
  80e639:	88 02                	mov    %al,(%edx)
}
  80e63b:	5d                   	pop    %ebp
  80e63c:	c3                   	ret    

0080e63d <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80e63d:	55                   	push   %ebp
  80e63e:	89 e5                	mov    %esp,%ebp
  80e640:	83 ec 08             	sub    $0x8,%esp
	va_list ap;

	va_start(ap, fmt);
  80e643:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e646:	50                   	push   %eax
  80e647:	ff 75 10             	pushl  0x10(%ebp)
  80e64a:	ff 75 0c             	pushl  0xc(%ebp)
  80e64d:	ff 75 08             	pushl  0x8(%ebp)
  80e650:	e8 05 00 00 00       	call   80e65a <vprintfmt>
	va_end(ap);
}
  80e655:	83 c4 10             	add    $0x10,%esp
  80e658:	c9                   	leave  
  80e659:	c3                   	ret    

0080e65a <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80e65a:	55                   	push   %ebp
  80e65b:	89 e5                	mov    %esp,%ebp
  80e65d:	57                   	push   %edi
  80e65e:	56                   	push   %esi
  80e65f:	53                   	push   %ebx
  80e660:	83 ec 2c             	sub    $0x2c,%esp
  80e663:	8b 75 08             	mov    0x8(%ebp),%esi
  80e666:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e669:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e66c:	eb 12                	jmp    80e680 <vprintfmt+0x26>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80e66e:	85 c0                	test   %eax,%eax
  80e670:	0f 84 89 03 00 00    	je     80e9ff <vprintfmt+0x3a5>
				return;
			putch(ch, putdat);
  80e676:	83 ec 08             	sub    $0x8,%esp
  80e679:	53                   	push   %ebx
  80e67a:	50                   	push   %eax
  80e67b:	ff d6                	call   *%esi
  80e67d:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e680:	83 c7 01             	add    $0x1,%edi
  80e683:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e687:	83 f8 25             	cmp    $0x25,%eax
  80e68a:	75 e2                	jne    80e66e <vprintfmt+0x14>
  80e68c:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
  80e690:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80e697:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e69e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
  80e6a5:	ba 00 00 00 00       	mov    $0x0,%edx
  80e6aa:	eb 07                	jmp    80e6b3 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6ac:	8b 7d e4             	mov    -0x1c(%ebp),%edi

		// flag to pad on the right
		case '-':
			padc = '-';
  80e6af:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6b3:	8d 47 01             	lea    0x1(%edi),%eax
  80e6b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e6b9:	0f b6 07             	movzbl (%edi),%eax
  80e6bc:	0f b6 c8             	movzbl %al,%ecx
  80e6bf:	83 e8 23             	sub    $0x23,%eax
  80e6c2:	3c 55                	cmp    $0x55,%al
  80e6c4:	0f 87 1a 03 00 00    	ja     80e9e4 <vprintfmt+0x38a>
  80e6ca:	0f b6 c0             	movzbl %al,%eax
  80e6cd:	ff 24 85 00 34 81 00 	jmp    *0x813400(,%eax,4)
  80e6d4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80e6d7:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  80e6db:	eb d6                	jmp    80e6b3 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6dd:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e6e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80e6e5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80e6e8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e6eb:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
				ch = *fmt;
  80e6ef:	0f be 0f             	movsbl (%edi),%ecx
				if (ch < '0' || ch > '9')
  80e6f2:	8d 51 d0             	lea    -0x30(%ecx),%edx
  80e6f5:	83 fa 09             	cmp    $0x9,%edx
  80e6f8:	77 39                	ja     80e733 <vprintfmt+0xd9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80e6fa:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80e6fd:	eb e9                	jmp    80e6e8 <vprintfmt+0x8e>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80e6ff:	8b 45 14             	mov    0x14(%ebp),%eax
  80e702:	8d 48 04             	lea    0x4(%eax),%ecx
  80e705:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80e708:	8b 00                	mov    (%eax),%eax
  80e70a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e70d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80e710:	eb 27                	jmp    80e739 <vprintfmt+0xdf>
  80e712:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e715:	85 c0                	test   %eax,%eax
  80e717:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e71c:	0f 49 c8             	cmovns %eax,%ecx
  80e71f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e722:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e725:	eb 8c                	jmp    80e6b3 <vprintfmt+0x59>
  80e727:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80e72a:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			goto reswitch;
  80e731:	eb 80                	jmp    80e6b3 <vprintfmt+0x59>
  80e733:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e736:	89 45 d0             	mov    %eax,-0x30(%ebp)

		process_precision:
			if (width < 0)
  80e739:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e73d:	0f 89 70 ff ff ff    	jns    80e6b3 <vprintfmt+0x59>
				width = precision, precision = -1;
  80e743:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80e746:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e749:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e750:	e9 5e ff ff ff       	jmp    80e6b3 <vprintfmt+0x59>
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80e755:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e758:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80e75b:	e9 53 ff ff ff       	jmp    80e6b3 <vprintfmt+0x59>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80e760:	8b 45 14             	mov    0x14(%ebp),%eax
  80e763:	8d 50 04             	lea    0x4(%eax),%edx
  80e766:	89 55 14             	mov    %edx,0x14(%ebp)
  80e769:	83 ec 08             	sub    $0x8,%esp
  80e76c:	53                   	push   %ebx
  80e76d:	ff 30                	pushl  (%eax)
  80e76f:	ff d6                	call   *%esi
			break;
  80e771:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e774:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80e777:	e9 04 ff ff ff       	jmp    80e680 <vprintfmt+0x26>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80e77c:	8b 45 14             	mov    0x14(%ebp),%eax
  80e77f:	8d 50 04             	lea    0x4(%eax),%edx
  80e782:	89 55 14             	mov    %edx,0x14(%ebp)
  80e785:	8b 00                	mov    (%eax),%eax
  80e787:	99                   	cltd   
  80e788:	31 d0                	xor    %edx,%eax
  80e78a:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e78c:	83 f8 0f             	cmp    $0xf,%eax
  80e78f:	7f 0b                	jg     80e79c <vprintfmt+0x142>
  80e791:	8b 14 85 60 35 81 00 	mov    0x813560(,%eax,4),%edx
  80e798:	85 d2                	test   %edx,%edx
  80e79a:	75 18                	jne    80e7b4 <vprintfmt+0x15a>
				printfmt(putch, putdat, "error %d", err);
  80e79c:	50                   	push   %eax
  80e79d:	68 cb 32 81 00       	push   $0x8132cb
  80e7a2:	53                   	push   %ebx
  80e7a3:	56                   	push   %esi
  80e7a4:	e8 94 fe ff ff       	call   80e63d <printfmt>
  80e7a9:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e7ac:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80e7af:	e9 cc fe ff ff       	jmp    80e680 <vprintfmt+0x26>
			else
				printfmt(putch, putdat, "%s", p);
  80e7b4:	52                   	push   %edx
  80e7b5:	68 99 24 81 00       	push   $0x812499
  80e7ba:	53                   	push   %ebx
  80e7bb:	56                   	push   %esi
  80e7bc:	e8 7c fe ff ff       	call   80e63d <printfmt>
  80e7c1:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e7c4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e7c7:	e9 b4 fe ff ff       	jmp    80e680 <vprintfmt+0x26>
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80e7cc:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7cf:	8d 50 04             	lea    0x4(%eax),%edx
  80e7d2:	89 55 14             	mov    %edx,0x14(%ebp)
  80e7d5:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80e7d7:	85 ff                	test   %edi,%edi
  80e7d9:	b8 c4 32 81 00       	mov    $0x8132c4,%eax
  80e7de:	0f 44 f8             	cmove  %eax,%edi
			if (width > 0 && padc != '-')
  80e7e1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e7e5:	0f 8e 94 00 00 00    	jle    80e87f <vprintfmt+0x225>
  80e7eb:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  80e7ef:	0f 84 98 00 00 00    	je     80e88d <vprintfmt+0x233>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e7f5:	83 ec 08             	sub    $0x8,%esp
  80e7f8:	ff 75 d0             	pushl  -0x30(%ebp)
  80e7fb:	57                   	push   %edi
  80e7fc:	e8 86 02 00 00       	call   80ea87 <strnlen>
  80e801:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e804:	29 c1                	sub    %eax,%ecx
  80e806:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  80e809:	83 c4 10             	add    $0x10,%esp
					putch(padc, putdat);
  80e80c:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80e810:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e813:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e816:	89 cf                	mov    %ecx,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e818:	eb 0f                	jmp    80e829 <vprintfmt+0x1cf>
					putch(padc, putdat);
  80e81a:	83 ec 08             	sub    $0x8,%esp
  80e81d:	53                   	push   %ebx
  80e81e:	ff 75 e0             	pushl  -0x20(%ebp)
  80e821:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e823:	83 ef 01             	sub    $0x1,%edi
  80e826:	83 c4 10             	add    $0x10,%esp
  80e829:	85 ff                	test   %edi,%edi
  80e82b:	7f ed                	jg     80e81a <vprintfmt+0x1c0>
  80e82d:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80e830:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80e833:	85 c9                	test   %ecx,%ecx
  80e835:	b8 00 00 00 00       	mov    $0x0,%eax
  80e83a:	0f 49 c1             	cmovns %ecx,%eax
  80e83d:	29 c1                	sub    %eax,%ecx
  80e83f:	89 75 08             	mov    %esi,0x8(%ebp)
  80e842:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e845:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e848:	89 cb                	mov    %ecx,%ebx
  80e84a:	eb 4d                	jmp    80e899 <vprintfmt+0x23f>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80e84c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e850:	74 1b                	je     80e86d <vprintfmt+0x213>
  80e852:	0f be c0             	movsbl %al,%eax
  80e855:	83 e8 20             	sub    $0x20,%eax
  80e858:	83 f8 5e             	cmp    $0x5e,%eax
  80e85b:	76 10                	jbe    80e86d <vprintfmt+0x213>
					putch('?', putdat);
  80e85d:	83 ec 08             	sub    $0x8,%esp
  80e860:	ff 75 0c             	pushl  0xc(%ebp)
  80e863:	6a 3f                	push   $0x3f
  80e865:	ff 55 08             	call   *0x8(%ebp)
  80e868:	83 c4 10             	add    $0x10,%esp
  80e86b:	eb 0d                	jmp    80e87a <vprintfmt+0x220>
				else
					putch(ch, putdat);
  80e86d:	83 ec 08             	sub    $0x8,%esp
  80e870:	ff 75 0c             	pushl  0xc(%ebp)
  80e873:	52                   	push   %edx
  80e874:	ff 55 08             	call   *0x8(%ebp)
  80e877:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e87a:	83 eb 01             	sub    $0x1,%ebx
  80e87d:	eb 1a                	jmp    80e899 <vprintfmt+0x23f>
  80e87f:	89 75 08             	mov    %esi,0x8(%ebp)
  80e882:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e885:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e888:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e88b:	eb 0c                	jmp    80e899 <vprintfmt+0x23f>
  80e88d:	89 75 08             	mov    %esi,0x8(%ebp)
  80e890:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e893:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e896:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e899:	83 c7 01             	add    $0x1,%edi
  80e89c:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e8a0:	0f be d0             	movsbl %al,%edx
  80e8a3:	85 d2                	test   %edx,%edx
  80e8a5:	74 23                	je     80e8ca <vprintfmt+0x270>
  80e8a7:	85 f6                	test   %esi,%esi
  80e8a9:	78 a1                	js     80e84c <vprintfmt+0x1f2>
  80e8ab:	83 ee 01             	sub    $0x1,%esi
  80e8ae:	79 9c                	jns    80e84c <vprintfmt+0x1f2>
  80e8b0:	89 df                	mov    %ebx,%edi
  80e8b2:	8b 75 08             	mov    0x8(%ebp),%esi
  80e8b5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e8b8:	eb 18                	jmp    80e8d2 <vprintfmt+0x278>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80e8ba:	83 ec 08             	sub    $0x8,%esp
  80e8bd:	53                   	push   %ebx
  80e8be:	6a 20                	push   $0x20
  80e8c0:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80e8c2:	83 ef 01             	sub    $0x1,%edi
  80e8c5:	83 c4 10             	add    $0x10,%esp
  80e8c8:	eb 08                	jmp    80e8d2 <vprintfmt+0x278>
  80e8ca:	89 df                	mov    %ebx,%edi
  80e8cc:	8b 75 08             	mov    0x8(%ebp),%esi
  80e8cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e8d2:	85 ff                	test   %edi,%edi
  80e8d4:	7f e4                	jg     80e8ba <vprintfmt+0x260>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e8d6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e8d9:	e9 a2 fd ff ff       	jmp    80e680 <vprintfmt+0x26>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80e8de:	83 fa 01             	cmp    $0x1,%edx
  80e8e1:	7e 16                	jle    80e8f9 <vprintfmt+0x29f>
		return va_arg(*ap, long long);
  80e8e3:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8e6:	8d 50 08             	lea    0x8(%eax),%edx
  80e8e9:	89 55 14             	mov    %edx,0x14(%ebp)
  80e8ec:	8b 50 04             	mov    0x4(%eax),%edx
  80e8ef:	8b 00                	mov    (%eax),%eax
  80e8f1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e8f4:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e8f7:	eb 32                	jmp    80e92b <vprintfmt+0x2d1>
	else if (lflag)
  80e8f9:	85 d2                	test   %edx,%edx
  80e8fb:	74 18                	je     80e915 <vprintfmt+0x2bb>
		return va_arg(*ap, long);
  80e8fd:	8b 45 14             	mov    0x14(%ebp),%eax
  80e900:	8d 50 04             	lea    0x4(%eax),%edx
  80e903:	89 55 14             	mov    %edx,0x14(%ebp)
  80e906:	8b 00                	mov    (%eax),%eax
  80e908:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e90b:	89 c1                	mov    %eax,%ecx
  80e90d:	c1 f9 1f             	sar    $0x1f,%ecx
  80e910:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e913:	eb 16                	jmp    80e92b <vprintfmt+0x2d1>
	else
		return va_arg(*ap, int);
  80e915:	8b 45 14             	mov    0x14(%ebp),%eax
  80e918:	8d 50 04             	lea    0x4(%eax),%edx
  80e91b:	89 55 14             	mov    %edx,0x14(%ebp)
  80e91e:	8b 00                	mov    (%eax),%eax
  80e920:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e923:	89 c1                	mov    %eax,%ecx
  80e925:	c1 f9 1f             	sar    $0x1f,%ecx
  80e928:	89 4d dc             	mov    %ecx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80e92b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e92e:	8b 55 dc             	mov    -0x24(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80e931:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80e936:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80e93a:	79 74                	jns    80e9b0 <vprintfmt+0x356>
				putch('-', putdat);
  80e93c:	83 ec 08             	sub    $0x8,%esp
  80e93f:	53                   	push   %ebx
  80e940:	6a 2d                	push   $0x2d
  80e942:	ff d6                	call   *%esi
				num = -(long long) num;
  80e944:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e947:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e94a:	f7 d8                	neg    %eax
  80e94c:	83 d2 00             	adc    $0x0,%edx
  80e94f:	f7 da                	neg    %edx
  80e951:	83 c4 10             	add    $0x10,%esp
			}
			base = 10;
  80e954:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80e959:	eb 55                	jmp    80e9b0 <vprintfmt+0x356>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80e95b:	8d 45 14             	lea    0x14(%ebp),%eax
  80e95e:	e8 83 fc ff ff       	call   80e5e6 <getuint>
			base = 10;
  80e963:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80e968:	eb 46                	jmp    80e9b0 <vprintfmt+0x356>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getuint(&ap, lflag);
  80e96a:	8d 45 14             	lea    0x14(%ebp),%eax
  80e96d:	e8 74 fc ff ff       	call   80e5e6 <getuint>
                        base = 8;
  80e972:	b9 08 00 00 00       	mov    $0x8,%ecx
                        goto number;
  80e977:	eb 37                	jmp    80e9b0 <vprintfmt+0x356>

		// pointer
		case 'p':
			putch('0', putdat);
  80e979:	83 ec 08             	sub    $0x8,%esp
  80e97c:	53                   	push   %ebx
  80e97d:	6a 30                	push   $0x30
  80e97f:	ff d6                	call   *%esi
			putch('x', putdat);
  80e981:	83 c4 08             	add    $0x8,%esp
  80e984:	53                   	push   %ebx
  80e985:	6a 78                	push   $0x78
  80e987:	ff d6                	call   *%esi
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80e989:	8b 45 14             	mov    0x14(%ebp),%eax
  80e98c:	8d 50 04             	lea    0x4(%eax),%edx
  80e98f:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80e992:	8b 00                	mov    (%eax),%eax
  80e994:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80e999:	83 c4 10             	add    $0x10,%esp
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80e99c:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80e9a1:	eb 0d                	jmp    80e9b0 <vprintfmt+0x356>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80e9a3:	8d 45 14             	lea    0x14(%ebp),%eax
  80e9a6:	e8 3b fc ff ff       	call   80e5e6 <getuint>
			base = 16;
  80e9ab:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80e9b0:	83 ec 0c             	sub    $0xc,%esp
  80e9b3:	0f be 7d d4          	movsbl -0x2c(%ebp),%edi
  80e9b7:	57                   	push   %edi
  80e9b8:	ff 75 e0             	pushl  -0x20(%ebp)
  80e9bb:	51                   	push   %ecx
  80e9bc:	52                   	push   %edx
  80e9bd:	50                   	push   %eax
  80e9be:	89 da                	mov    %ebx,%edx
  80e9c0:	89 f0                	mov    %esi,%eax
  80e9c2:	e8 70 fb ff ff       	call   80e537 <printnum>
			break;
  80e9c7:	83 c4 20             	add    $0x20,%esp
  80e9ca:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e9cd:	e9 ae fc ff ff       	jmp    80e680 <vprintfmt+0x26>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80e9d2:	83 ec 08             	sub    $0x8,%esp
  80e9d5:	53                   	push   %ebx
  80e9d6:	51                   	push   %ecx
  80e9d7:	ff d6                	call   *%esi
			break;
  80e9d9:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e9dc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80e9df:	e9 9c fc ff ff       	jmp    80e680 <vprintfmt+0x26>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80e9e4:	83 ec 08             	sub    $0x8,%esp
  80e9e7:	53                   	push   %ebx
  80e9e8:	6a 25                	push   $0x25
  80e9ea:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80e9ec:	83 c4 10             	add    $0x10,%esp
  80e9ef:	eb 03                	jmp    80e9f4 <vprintfmt+0x39a>
  80e9f1:	83 ef 01             	sub    $0x1,%edi
  80e9f4:	80 7f ff 25          	cmpb   $0x25,-0x1(%edi)
  80e9f8:	75 f7                	jne    80e9f1 <vprintfmt+0x397>
  80e9fa:	e9 81 fc ff ff       	jmp    80e680 <vprintfmt+0x26>
				/* do nothing */;
			break;
		}
	}
}
  80e9ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ea02:	5b                   	pop    %ebx
  80ea03:	5e                   	pop    %esi
  80ea04:	5f                   	pop    %edi
  80ea05:	5d                   	pop    %ebp
  80ea06:	c3                   	ret    

0080ea07 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ea07:	55                   	push   %ebp
  80ea08:	89 e5                	mov    %esp,%ebp
  80ea0a:	83 ec 18             	sub    $0x18,%esp
  80ea0d:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea10:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ea13:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ea16:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ea1a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ea1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ea24:	85 c0                	test   %eax,%eax
  80ea26:	74 26                	je     80ea4e <vsnprintf+0x47>
  80ea28:	85 d2                	test   %edx,%edx
  80ea2a:	7e 22                	jle    80ea4e <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ea2c:	ff 75 14             	pushl  0x14(%ebp)
  80ea2f:	ff 75 10             	pushl  0x10(%ebp)
  80ea32:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ea35:	50                   	push   %eax
  80ea36:	68 20 e6 80 00       	push   $0x80e620
  80ea3b:	e8 1a fc ff ff       	call   80e65a <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ea40:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ea43:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ea46:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ea49:	83 c4 10             	add    $0x10,%esp
  80ea4c:	eb 05                	jmp    80ea53 <vsnprintf+0x4c>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80ea4e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80ea53:	c9                   	leave  
  80ea54:	c3                   	ret    

0080ea55 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80ea55:	55                   	push   %ebp
  80ea56:	89 e5                	mov    %esp,%ebp
  80ea58:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80ea5b:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80ea5e:	50                   	push   %eax
  80ea5f:	ff 75 10             	pushl  0x10(%ebp)
  80ea62:	ff 75 0c             	pushl  0xc(%ebp)
  80ea65:	ff 75 08             	pushl  0x8(%ebp)
  80ea68:	e8 9a ff ff ff       	call   80ea07 <vsnprintf>
	va_end(ap);

	return rc;
}
  80ea6d:	c9                   	leave  
  80ea6e:	c3                   	ret    

0080ea6f <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80ea6f:	55                   	push   %ebp
  80ea70:	89 e5                	mov    %esp,%ebp
  80ea72:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80ea75:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea7a:	eb 03                	jmp    80ea7f <strlen+0x10>
		n++;
  80ea7c:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80ea7f:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80ea83:	75 f7                	jne    80ea7c <strlen+0xd>
		n++;
	return n;
}
  80ea85:	5d                   	pop    %ebp
  80ea86:	c3                   	ret    

0080ea87 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80ea87:	55                   	push   %ebp
  80ea88:	89 e5                	mov    %esp,%ebp
  80ea8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ea8d:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ea90:	ba 00 00 00 00       	mov    $0x0,%edx
  80ea95:	eb 03                	jmp    80ea9a <strnlen+0x13>
		n++;
  80ea97:	83 c2 01             	add    $0x1,%edx
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ea9a:	39 c2                	cmp    %eax,%edx
  80ea9c:	74 08                	je     80eaa6 <strnlen+0x1f>
  80ea9e:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80eaa2:	75 f3                	jne    80ea97 <strnlen+0x10>
  80eaa4:	89 d0                	mov    %edx,%eax
		n++;
	return n;
}
  80eaa6:	5d                   	pop    %ebp
  80eaa7:	c3                   	ret    

0080eaa8 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80eaa8:	55                   	push   %ebp
  80eaa9:	89 e5                	mov    %esp,%ebp
  80eaab:	53                   	push   %ebx
  80eaac:	8b 45 08             	mov    0x8(%ebp),%eax
  80eaaf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80eab2:	89 c2                	mov    %eax,%edx
  80eab4:	83 c2 01             	add    $0x1,%edx
  80eab7:	83 c1 01             	add    $0x1,%ecx
  80eaba:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80eabe:	88 5a ff             	mov    %bl,-0x1(%edx)
  80eac1:	84 db                	test   %bl,%bl
  80eac3:	75 ef                	jne    80eab4 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80eac5:	5b                   	pop    %ebx
  80eac6:	5d                   	pop    %ebp
  80eac7:	c3                   	ret    

0080eac8 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80eac8:	55                   	push   %ebp
  80eac9:	89 e5                	mov    %esp,%ebp
  80eacb:	53                   	push   %ebx
  80eacc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80eacf:	53                   	push   %ebx
  80ead0:	e8 9a ff ff ff       	call   80ea6f <strlen>
  80ead5:	83 c4 04             	add    $0x4,%esp
	strcpy(dst + len, src);
  80ead8:	ff 75 0c             	pushl  0xc(%ebp)
  80eadb:	01 d8                	add    %ebx,%eax
  80eadd:	50                   	push   %eax
  80eade:	e8 c5 ff ff ff       	call   80eaa8 <strcpy>
	return dst;
}
  80eae3:	89 d8                	mov    %ebx,%eax
  80eae5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80eae8:	c9                   	leave  
  80eae9:	c3                   	ret    

0080eaea <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80eaea:	55                   	push   %ebp
  80eaeb:	89 e5                	mov    %esp,%ebp
  80eaed:	56                   	push   %esi
  80eaee:	53                   	push   %ebx
  80eaef:	8b 75 08             	mov    0x8(%ebp),%esi
  80eaf2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eaf5:	89 f3                	mov    %esi,%ebx
  80eaf7:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80eafa:	89 f2                	mov    %esi,%edx
  80eafc:	eb 0f                	jmp    80eb0d <strncpy+0x23>
		*dst++ = *src;
  80eafe:	83 c2 01             	add    $0x1,%edx
  80eb01:	0f b6 01             	movzbl (%ecx),%eax
  80eb04:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80eb07:	80 39 01             	cmpb   $0x1,(%ecx)
  80eb0a:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80eb0d:	39 da                	cmp    %ebx,%edx
  80eb0f:	75 ed                	jne    80eafe <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80eb11:	89 f0                	mov    %esi,%eax
  80eb13:	5b                   	pop    %ebx
  80eb14:	5e                   	pop    %esi
  80eb15:	5d                   	pop    %ebp
  80eb16:	c3                   	ret    

0080eb17 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80eb17:	55                   	push   %ebp
  80eb18:	89 e5                	mov    %esp,%ebp
  80eb1a:	56                   	push   %esi
  80eb1b:	53                   	push   %ebx
  80eb1c:	8b 75 08             	mov    0x8(%ebp),%esi
  80eb1f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eb22:	8b 55 10             	mov    0x10(%ebp),%edx
  80eb25:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80eb27:	85 d2                	test   %edx,%edx
  80eb29:	74 21                	je     80eb4c <strlcpy+0x35>
  80eb2b:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80eb2f:	89 f2                	mov    %esi,%edx
  80eb31:	eb 09                	jmp    80eb3c <strlcpy+0x25>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80eb33:	83 c2 01             	add    $0x1,%edx
  80eb36:	83 c1 01             	add    $0x1,%ecx
  80eb39:	88 5a ff             	mov    %bl,-0x1(%edx)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80eb3c:	39 c2                	cmp    %eax,%edx
  80eb3e:	74 09                	je     80eb49 <strlcpy+0x32>
  80eb40:	0f b6 19             	movzbl (%ecx),%ebx
  80eb43:	84 db                	test   %bl,%bl
  80eb45:	75 ec                	jne    80eb33 <strlcpy+0x1c>
  80eb47:	89 d0                	mov    %edx,%eax
			*dst++ = *src++;
		*dst = '\0';
  80eb49:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80eb4c:	29 f0                	sub    %esi,%eax
}
  80eb4e:	5b                   	pop    %ebx
  80eb4f:	5e                   	pop    %esi
  80eb50:	5d                   	pop    %ebp
  80eb51:	c3                   	ret    

0080eb52 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80eb52:	55                   	push   %ebp
  80eb53:	89 e5                	mov    %esp,%ebp
  80eb55:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eb58:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80eb5b:	eb 06                	jmp    80eb63 <strcmp+0x11>
		p++, q++;
  80eb5d:	83 c1 01             	add    $0x1,%ecx
  80eb60:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80eb63:	0f b6 01             	movzbl (%ecx),%eax
  80eb66:	84 c0                	test   %al,%al
  80eb68:	74 04                	je     80eb6e <strcmp+0x1c>
  80eb6a:	3a 02                	cmp    (%edx),%al
  80eb6c:	74 ef                	je     80eb5d <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80eb6e:	0f b6 c0             	movzbl %al,%eax
  80eb71:	0f b6 12             	movzbl (%edx),%edx
  80eb74:	29 d0                	sub    %edx,%eax
}
  80eb76:	5d                   	pop    %ebp
  80eb77:	c3                   	ret    

0080eb78 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80eb78:	55                   	push   %ebp
  80eb79:	89 e5                	mov    %esp,%ebp
  80eb7b:	53                   	push   %ebx
  80eb7c:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb7f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eb82:	89 c3                	mov    %eax,%ebx
  80eb84:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80eb87:	eb 06                	jmp    80eb8f <strncmp+0x17>
		n--, p++, q++;
  80eb89:	83 c0 01             	add    $0x1,%eax
  80eb8c:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80eb8f:	39 d8                	cmp    %ebx,%eax
  80eb91:	74 15                	je     80eba8 <strncmp+0x30>
  80eb93:	0f b6 08             	movzbl (%eax),%ecx
  80eb96:	84 c9                	test   %cl,%cl
  80eb98:	74 04                	je     80eb9e <strncmp+0x26>
  80eb9a:	3a 0a                	cmp    (%edx),%cl
  80eb9c:	74 eb                	je     80eb89 <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eb9e:	0f b6 00             	movzbl (%eax),%eax
  80eba1:	0f b6 12             	movzbl (%edx),%edx
  80eba4:	29 d0                	sub    %edx,%eax
  80eba6:	eb 05                	jmp    80ebad <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80eba8:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80ebad:	5b                   	pop    %ebx
  80ebae:	5d                   	pop    %ebp
  80ebaf:	c3                   	ret    

0080ebb0 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80ebb0:	55                   	push   %ebp
  80ebb1:	89 e5                	mov    %esp,%ebp
  80ebb3:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebb6:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ebba:	eb 07                	jmp    80ebc3 <strchr+0x13>
		if (*s == c)
  80ebbc:	38 ca                	cmp    %cl,%dl
  80ebbe:	74 0f                	je     80ebcf <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80ebc0:	83 c0 01             	add    $0x1,%eax
  80ebc3:	0f b6 10             	movzbl (%eax),%edx
  80ebc6:	84 d2                	test   %dl,%dl
  80ebc8:	75 f2                	jne    80ebbc <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80ebca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ebcf:	5d                   	pop    %ebp
  80ebd0:	c3                   	ret    

0080ebd1 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80ebd1:	55                   	push   %ebp
  80ebd2:	89 e5                	mov    %esp,%ebp
  80ebd4:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebd7:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ebdb:	eb 03                	jmp    80ebe0 <strfind+0xf>
  80ebdd:	83 c0 01             	add    $0x1,%eax
  80ebe0:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80ebe3:	38 ca                	cmp    %cl,%dl
  80ebe5:	74 04                	je     80ebeb <strfind+0x1a>
  80ebe7:	84 d2                	test   %dl,%dl
  80ebe9:	75 f2                	jne    80ebdd <strfind+0xc>
			break;
	return (char *) s;
}
  80ebeb:	5d                   	pop    %ebp
  80ebec:	c3                   	ret    

0080ebed <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80ebed:	55                   	push   %ebp
  80ebee:	89 e5                	mov    %esp,%ebp
  80ebf0:	57                   	push   %edi
  80ebf1:	56                   	push   %esi
  80ebf2:	53                   	push   %ebx
  80ebf3:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ebf6:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80ebf9:	85 c9                	test   %ecx,%ecx
  80ebfb:	74 36                	je     80ec33 <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80ebfd:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80ec03:	75 28                	jne    80ec2d <memset+0x40>
  80ec05:	f6 c1 03             	test   $0x3,%cl
  80ec08:	75 23                	jne    80ec2d <memset+0x40>
		c &= 0xFF;
  80ec0a:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80ec0e:	89 d3                	mov    %edx,%ebx
  80ec10:	c1 e3 08             	shl    $0x8,%ebx
  80ec13:	89 d6                	mov    %edx,%esi
  80ec15:	c1 e6 18             	shl    $0x18,%esi
  80ec18:	89 d0                	mov    %edx,%eax
  80ec1a:	c1 e0 10             	shl    $0x10,%eax
  80ec1d:	09 f0                	or     %esi,%eax
  80ec1f:	09 c2                	or     %eax,%edx
		asm volatile("cld; rep stosl\n"
  80ec21:	89 d8                	mov    %ebx,%eax
  80ec23:	09 d0                	or     %edx,%eax
  80ec25:	c1 e9 02             	shr    $0x2,%ecx
  80ec28:	fc                   	cld    
  80ec29:	f3 ab                	rep stos %eax,%es:(%edi)
  80ec2b:	eb 06                	jmp    80ec33 <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80ec2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ec30:	fc                   	cld    
  80ec31:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80ec33:	89 f8                	mov    %edi,%eax
  80ec35:	5b                   	pop    %ebx
  80ec36:	5e                   	pop    %esi
  80ec37:	5f                   	pop    %edi
  80ec38:	5d                   	pop    %ebp
  80ec39:	c3                   	ret    

0080ec3a <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80ec3a:	55                   	push   %ebp
  80ec3b:	89 e5                	mov    %esp,%ebp
  80ec3d:	57                   	push   %edi
  80ec3e:	56                   	push   %esi
  80ec3f:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec42:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ec45:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80ec48:	39 c6                	cmp    %eax,%esi
  80ec4a:	73 35                	jae    80ec81 <memmove+0x47>
  80ec4c:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80ec4f:	39 d0                	cmp    %edx,%eax
  80ec51:	73 2e                	jae    80ec81 <memmove+0x47>
		s += n;
		d += n;
  80ec53:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ec56:	89 d6                	mov    %edx,%esi
  80ec58:	09 fe                	or     %edi,%esi
  80ec5a:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80ec60:	75 13                	jne    80ec75 <memmove+0x3b>
  80ec62:	f6 c1 03             	test   $0x3,%cl
  80ec65:	75 0e                	jne    80ec75 <memmove+0x3b>
			asm volatile("std; rep movsl\n"
  80ec67:	83 ef 04             	sub    $0x4,%edi
  80ec6a:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ec6d:	c1 e9 02             	shr    $0x2,%ecx
  80ec70:	fd                   	std    
  80ec71:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ec73:	eb 09                	jmp    80ec7e <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80ec75:	83 ef 01             	sub    $0x1,%edi
  80ec78:	8d 72 ff             	lea    -0x1(%edx),%esi
  80ec7b:	fd                   	std    
  80ec7c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80ec7e:	fc                   	cld    
  80ec7f:	eb 1d                	jmp    80ec9e <memmove+0x64>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ec81:	89 f2                	mov    %esi,%edx
  80ec83:	09 c2                	or     %eax,%edx
  80ec85:	f6 c2 03             	test   $0x3,%dl
  80ec88:	75 0f                	jne    80ec99 <memmove+0x5f>
  80ec8a:	f6 c1 03             	test   $0x3,%cl
  80ec8d:	75 0a                	jne    80ec99 <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
  80ec8f:	c1 e9 02             	shr    $0x2,%ecx
  80ec92:	89 c7                	mov    %eax,%edi
  80ec94:	fc                   	cld    
  80ec95:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ec97:	eb 05                	jmp    80ec9e <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80ec99:	89 c7                	mov    %eax,%edi
  80ec9b:	fc                   	cld    
  80ec9c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80ec9e:	5e                   	pop    %esi
  80ec9f:	5f                   	pop    %edi
  80eca0:	5d                   	pop    %ebp
  80eca1:	c3                   	ret    

0080eca2 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80eca2:	55                   	push   %ebp
  80eca3:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  80eca5:	ff 75 10             	pushl  0x10(%ebp)
  80eca8:	ff 75 0c             	pushl  0xc(%ebp)
  80ecab:	ff 75 08             	pushl  0x8(%ebp)
  80ecae:	e8 87 ff ff ff       	call   80ec3a <memmove>
}
  80ecb3:	c9                   	leave  
  80ecb4:	c3                   	ret    

0080ecb5 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ecb5:	55                   	push   %ebp
  80ecb6:	89 e5                	mov    %esp,%ebp
  80ecb8:	56                   	push   %esi
  80ecb9:	53                   	push   %ebx
  80ecba:	8b 45 08             	mov    0x8(%ebp),%eax
  80ecbd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ecc0:	89 c6                	mov    %eax,%esi
  80ecc2:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ecc5:	eb 1a                	jmp    80ece1 <memcmp+0x2c>
		if (*s1 != *s2)
  80ecc7:	0f b6 08             	movzbl (%eax),%ecx
  80ecca:	0f b6 1a             	movzbl (%edx),%ebx
  80eccd:	38 d9                	cmp    %bl,%cl
  80eccf:	74 0a                	je     80ecdb <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80ecd1:	0f b6 c1             	movzbl %cl,%eax
  80ecd4:	0f b6 db             	movzbl %bl,%ebx
  80ecd7:	29 d8                	sub    %ebx,%eax
  80ecd9:	eb 0f                	jmp    80ecea <memcmp+0x35>
		s1++, s2++;
  80ecdb:	83 c0 01             	add    $0x1,%eax
  80ecde:	83 c2 01             	add    $0x1,%edx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ece1:	39 f0                	cmp    %esi,%eax
  80ece3:	75 e2                	jne    80ecc7 <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80ece5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ecea:	5b                   	pop    %ebx
  80eceb:	5e                   	pop    %esi
  80ecec:	5d                   	pop    %ebp
  80eced:	c3                   	ret    

0080ecee <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80ecee:	55                   	push   %ebp
  80ecef:	89 e5                	mov    %esp,%ebp
  80ecf1:	53                   	push   %ebx
  80ecf2:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  80ecf5:	89 c1                	mov    %eax,%ecx
  80ecf7:	03 4d 10             	add    0x10(%ebp),%ecx
	for (; s < ends; s++)
		if (*(const unsigned char *) s == (unsigned char) c)
  80ecfa:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ecfe:	eb 0a                	jmp    80ed0a <memfind+0x1c>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ed00:	0f b6 10             	movzbl (%eax),%edx
  80ed03:	39 da                	cmp    %ebx,%edx
  80ed05:	74 07                	je     80ed0e <memfind+0x20>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ed07:	83 c0 01             	add    $0x1,%eax
  80ed0a:	39 c8                	cmp    %ecx,%eax
  80ed0c:	72 f2                	jb     80ed00 <memfind+0x12>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80ed0e:	5b                   	pop    %ebx
  80ed0f:	5d                   	pop    %ebp
  80ed10:	c3                   	ret    

0080ed11 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80ed11:	55                   	push   %ebp
  80ed12:	89 e5                	mov    %esp,%ebp
  80ed14:	57                   	push   %edi
  80ed15:	56                   	push   %esi
  80ed16:	53                   	push   %ebx
  80ed17:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ed1a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ed1d:	eb 03                	jmp    80ed22 <strtol+0x11>
		s++;
  80ed1f:	83 c1 01             	add    $0x1,%ecx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ed22:	0f b6 01             	movzbl (%ecx),%eax
  80ed25:	3c 20                	cmp    $0x20,%al
  80ed27:	74 f6                	je     80ed1f <strtol+0xe>
  80ed29:	3c 09                	cmp    $0x9,%al
  80ed2b:	74 f2                	je     80ed1f <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80ed2d:	3c 2b                	cmp    $0x2b,%al
  80ed2f:	75 0a                	jne    80ed3b <strtol+0x2a>
		s++;
  80ed31:	83 c1 01             	add    $0x1,%ecx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80ed34:	bf 00 00 00 00       	mov    $0x0,%edi
  80ed39:	eb 11                	jmp    80ed4c <strtol+0x3b>
  80ed3b:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80ed40:	3c 2d                	cmp    $0x2d,%al
  80ed42:	75 08                	jne    80ed4c <strtol+0x3b>
		s++, neg = 1;
  80ed44:	83 c1 01             	add    $0x1,%ecx
  80ed47:	bf 01 00 00 00       	mov    $0x1,%edi

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ed4c:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80ed52:	75 15                	jne    80ed69 <strtol+0x58>
  80ed54:	80 39 30             	cmpb   $0x30,(%ecx)
  80ed57:	75 10                	jne    80ed69 <strtol+0x58>
  80ed59:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80ed5d:	75 7c                	jne    80eddb <strtol+0xca>
		s += 2, base = 16;
  80ed5f:	83 c1 02             	add    $0x2,%ecx
  80ed62:	bb 10 00 00 00       	mov    $0x10,%ebx
  80ed67:	eb 16                	jmp    80ed7f <strtol+0x6e>
	else if (base == 0 && s[0] == '0')
  80ed69:	85 db                	test   %ebx,%ebx
  80ed6b:	75 12                	jne    80ed7f <strtol+0x6e>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80ed6d:	bb 0a 00 00 00       	mov    $0xa,%ebx
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ed72:	80 39 30             	cmpb   $0x30,(%ecx)
  80ed75:	75 08                	jne    80ed7f <strtol+0x6e>
		s++, base = 8;
  80ed77:	83 c1 01             	add    $0x1,%ecx
  80ed7a:	bb 08 00 00 00       	mov    $0x8,%ebx
	else if (base == 0)
		base = 10;
  80ed7f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed84:	89 5d 10             	mov    %ebx,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80ed87:	0f b6 11             	movzbl (%ecx),%edx
  80ed8a:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ed8d:	89 f3                	mov    %esi,%ebx
  80ed8f:	80 fb 09             	cmp    $0x9,%bl
  80ed92:	77 08                	ja     80ed9c <strtol+0x8b>
			dig = *s - '0';
  80ed94:	0f be d2             	movsbl %dl,%edx
  80ed97:	83 ea 30             	sub    $0x30,%edx
  80ed9a:	eb 22                	jmp    80edbe <strtol+0xad>
		else if (*s >= 'a' && *s <= 'z')
  80ed9c:	8d 72 9f             	lea    -0x61(%edx),%esi
  80ed9f:	89 f3                	mov    %esi,%ebx
  80eda1:	80 fb 19             	cmp    $0x19,%bl
  80eda4:	77 08                	ja     80edae <strtol+0x9d>
			dig = *s - 'a' + 10;
  80eda6:	0f be d2             	movsbl %dl,%edx
  80eda9:	83 ea 57             	sub    $0x57,%edx
  80edac:	eb 10                	jmp    80edbe <strtol+0xad>
		else if (*s >= 'A' && *s <= 'Z')
  80edae:	8d 72 bf             	lea    -0x41(%edx),%esi
  80edb1:	89 f3                	mov    %esi,%ebx
  80edb3:	80 fb 19             	cmp    $0x19,%bl
  80edb6:	77 16                	ja     80edce <strtol+0xbd>
			dig = *s - 'A' + 10;
  80edb8:	0f be d2             	movsbl %dl,%edx
  80edbb:	83 ea 37             	sub    $0x37,%edx
		else
			break;
		if (dig >= base)
  80edbe:	3b 55 10             	cmp    0x10(%ebp),%edx
  80edc1:	7d 0b                	jge    80edce <strtol+0xbd>
			break;
		s++, val = (val * base) + dig;
  80edc3:	83 c1 01             	add    $0x1,%ecx
  80edc6:	0f af 45 10          	imul   0x10(%ebp),%eax
  80edca:	01 d0                	add    %edx,%eax
		// we don't properly detect overflow!
	}
  80edcc:	eb b9                	jmp    80ed87 <strtol+0x76>

	if (endptr)
  80edce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80edd2:	74 0d                	je     80ede1 <strtol+0xd0>
		*endptr = (char *) s;
  80edd4:	8b 75 0c             	mov    0xc(%ebp),%esi
  80edd7:	89 0e                	mov    %ecx,(%esi)
  80edd9:	eb 06                	jmp    80ede1 <strtol+0xd0>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80eddb:	85 db                	test   %ebx,%ebx
  80eddd:	74 98                	je     80ed77 <strtol+0x66>
  80eddf:	eb 9e                	jmp    80ed7f <strtol+0x6e>
		// we don't properly detect overflow!
	}

	if (endptr)
		*endptr = (char *) s;
	return (neg ? -val : val);
  80ede1:	89 c2                	mov    %eax,%edx
  80ede3:	f7 da                	neg    %edx
  80ede5:	85 ff                	test   %edi,%edi
  80ede7:	0f 45 c2             	cmovne %edx,%eax
}
  80edea:	5b                   	pop    %ebx
  80edeb:	5e                   	pop    %esi
  80edec:	5f                   	pop    %edi
  80eded:	5d                   	pop    %ebp
  80edee:	c3                   	ret    

0080edef <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80edef:	55                   	push   %ebp
  80edf0:	89 e5                	mov    %esp,%ebp
  80edf2:	57                   	push   %edi
  80edf3:	56                   	push   %esi
  80edf4:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80edf5:	b8 00 00 00 00       	mov    $0x0,%eax
  80edfa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80edfd:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee00:	89 c3                	mov    %eax,%ebx
  80ee02:	89 c7                	mov    %eax,%edi
  80ee04:	89 c6                	mov    %eax,%esi
  80ee06:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80ee08:	5b                   	pop    %ebx
  80ee09:	5e                   	pop    %esi
  80ee0a:	5f                   	pop    %edi
  80ee0b:	5d                   	pop    %ebp
  80ee0c:	c3                   	ret    

0080ee0d <sys_cgetc>:

int
sys_cgetc(void)
{
  80ee0d:	55                   	push   %ebp
  80ee0e:	89 e5                	mov    %esp,%ebp
  80ee10:	57                   	push   %edi
  80ee11:	56                   	push   %esi
  80ee12:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee13:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee18:	b8 01 00 00 00       	mov    $0x1,%eax
  80ee1d:	89 d1                	mov    %edx,%ecx
  80ee1f:	89 d3                	mov    %edx,%ebx
  80ee21:	89 d7                	mov    %edx,%edi
  80ee23:	89 d6                	mov    %edx,%esi
  80ee25:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80ee27:	5b                   	pop    %ebx
  80ee28:	5e                   	pop    %esi
  80ee29:	5f                   	pop    %edi
  80ee2a:	5d                   	pop    %ebp
  80ee2b:	c3                   	ret    

0080ee2c <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80ee2c:	55                   	push   %ebp
  80ee2d:	89 e5                	mov    %esp,%ebp
  80ee2f:	57                   	push   %edi
  80ee30:	56                   	push   %esi
  80ee31:	53                   	push   %ebx
  80ee32:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee35:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee3a:	b8 03 00 00 00       	mov    $0x3,%eax
  80ee3f:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee42:	89 cb                	mov    %ecx,%ebx
  80ee44:	89 cf                	mov    %ecx,%edi
  80ee46:	89 ce                	mov    %ecx,%esi
  80ee48:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ee4a:	85 c0                	test   %eax,%eax
  80ee4c:	7e 17                	jle    80ee65 <sys_env_destroy+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee4e:	83 ec 0c             	sub    $0xc,%esp
  80ee51:	50                   	push   %eax
  80ee52:	6a 03                	push   $0x3
  80ee54:	68 bf 35 81 00       	push   $0x8135bf
  80ee59:	6a 23                	push   $0x23
  80ee5b:	68 dc 35 81 00       	push   $0x8135dc
  80ee60:	e8 e5 f5 ff ff       	call   80e44a <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80ee65:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee68:	5b                   	pop    %ebx
  80ee69:	5e                   	pop    %esi
  80ee6a:	5f                   	pop    %edi
  80ee6b:	5d                   	pop    %ebp
  80ee6c:	c3                   	ret    

0080ee6d <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80ee6d:	55                   	push   %ebp
  80ee6e:	89 e5                	mov    %esp,%ebp
  80ee70:	57                   	push   %edi
  80ee71:	56                   	push   %esi
  80ee72:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee73:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee78:	b8 02 00 00 00       	mov    $0x2,%eax
  80ee7d:	89 d1                	mov    %edx,%ecx
  80ee7f:	89 d3                	mov    %edx,%ebx
  80ee81:	89 d7                	mov    %edx,%edi
  80ee83:	89 d6                	mov    %edx,%esi
  80ee85:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80ee87:	5b                   	pop    %ebx
  80ee88:	5e                   	pop    %esi
  80ee89:	5f                   	pop    %edi
  80ee8a:	5d                   	pop    %ebp
  80ee8b:	c3                   	ret    

0080ee8c <sys_yield>:

void
sys_yield(void)
{
  80ee8c:	55                   	push   %ebp
  80ee8d:	89 e5                	mov    %esp,%ebp
  80ee8f:	57                   	push   %edi
  80ee90:	56                   	push   %esi
  80ee91:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee92:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee97:	b8 0b 00 00 00       	mov    $0xb,%eax
  80ee9c:	89 d1                	mov    %edx,%ecx
  80ee9e:	89 d3                	mov    %edx,%ebx
  80eea0:	89 d7                	mov    %edx,%edi
  80eea2:	89 d6                	mov    %edx,%esi
  80eea4:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80eea6:	5b                   	pop    %ebx
  80eea7:	5e                   	pop    %esi
  80eea8:	5f                   	pop    %edi
  80eea9:	5d                   	pop    %ebp
  80eeaa:	c3                   	ret    

0080eeab <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80eeab:	55                   	push   %ebp
  80eeac:	89 e5                	mov    %esp,%ebp
  80eeae:	57                   	push   %edi
  80eeaf:	56                   	push   %esi
  80eeb0:	53                   	push   %ebx
  80eeb1:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eeb4:	be 00 00 00 00       	mov    $0x0,%esi
  80eeb9:	b8 04 00 00 00       	mov    $0x4,%eax
  80eebe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eec1:	8b 55 08             	mov    0x8(%ebp),%edx
  80eec4:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80eec7:	89 f7                	mov    %esi,%edi
  80eec9:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80eecb:	85 c0                	test   %eax,%eax
  80eecd:	7e 17                	jle    80eee6 <sys_page_alloc+0x3b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eecf:	83 ec 0c             	sub    $0xc,%esp
  80eed2:	50                   	push   %eax
  80eed3:	6a 04                	push   $0x4
  80eed5:	68 bf 35 81 00       	push   $0x8135bf
  80eeda:	6a 23                	push   $0x23
  80eedc:	68 dc 35 81 00       	push   $0x8135dc
  80eee1:	e8 64 f5 ff ff       	call   80e44a <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80eee6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eee9:	5b                   	pop    %ebx
  80eeea:	5e                   	pop    %esi
  80eeeb:	5f                   	pop    %edi
  80eeec:	5d                   	pop    %ebp
  80eeed:	c3                   	ret    

0080eeee <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80eeee:	55                   	push   %ebp
  80eeef:	89 e5                	mov    %esp,%ebp
  80eef1:	57                   	push   %edi
  80eef2:	56                   	push   %esi
  80eef3:	53                   	push   %ebx
  80eef4:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eef7:	b8 05 00 00 00       	mov    $0x5,%eax
  80eefc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eeff:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef02:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ef05:	8b 7d 14             	mov    0x14(%ebp),%edi
  80ef08:	8b 75 18             	mov    0x18(%ebp),%esi
  80ef0b:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef0d:	85 c0                	test   %eax,%eax
  80ef0f:	7e 17                	jle    80ef28 <sys_page_map+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef11:	83 ec 0c             	sub    $0xc,%esp
  80ef14:	50                   	push   %eax
  80ef15:	6a 05                	push   $0x5
  80ef17:	68 bf 35 81 00       	push   $0x8135bf
  80ef1c:	6a 23                	push   $0x23
  80ef1e:	68 dc 35 81 00       	push   $0x8135dc
  80ef23:	e8 22 f5 ff ff       	call   80e44a <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80ef28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef2b:	5b                   	pop    %ebx
  80ef2c:	5e                   	pop    %esi
  80ef2d:	5f                   	pop    %edi
  80ef2e:	5d                   	pop    %ebp
  80ef2f:	c3                   	ret    

0080ef30 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80ef30:	55                   	push   %ebp
  80ef31:	89 e5                	mov    %esp,%ebp
  80ef33:	57                   	push   %edi
  80ef34:	56                   	push   %esi
  80ef35:	53                   	push   %ebx
  80ef36:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef39:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef3e:	b8 06 00 00 00       	mov    $0x6,%eax
  80ef43:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef46:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef49:	89 df                	mov    %ebx,%edi
  80ef4b:	89 de                	mov    %ebx,%esi
  80ef4d:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef4f:	85 c0                	test   %eax,%eax
  80ef51:	7e 17                	jle    80ef6a <sys_page_unmap+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef53:	83 ec 0c             	sub    $0xc,%esp
  80ef56:	50                   	push   %eax
  80ef57:	6a 06                	push   $0x6
  80ef59:	68 bf 35 81 00       	push   $0x8135bf
  80ef5e:	6a 23                	push   $0x23
  80ef60:	68 dc 35 81 00       	push   $0x8135dc
  80ef65:	e8 e0 f4 ff ff       	call   80e44a <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80ef6a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef6d:	5b                   	pop    %ebx
  80ef6e:	5e                   	pop    %esi
  80ef6f:	5f                   	pop    %edi
  80ef70:	5d                   	pop    %ebp
  80ef71:	c3                   	ret    

0080ef72 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80ef72:	55                   	push   %ebp
  80ef73:	89 e5                	mov    %esp,%ebp
  80ef75:	57                   	push   %edi
  80ef76:	56                   	push   %esi
  80ef77:	53                   	push   %ebx
  80ef78:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef7b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef80:	b8 08 00 00 00       	mov    $0x8,%eax
  80ef85:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef88:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef8b:	89 df                	mov    %ebx,%edi
  80ef8d:	89 de                	mov    %ebx,%esi
  80ef8f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef91:	85 c0                	test   %eax,%eax
  80ef93:	7e 17                	jle    80efac <sys_env_set_status+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef95:	83 ec 0c             	sub    $0xc,%esp
  80ef98:	50                   	push   %eax
  80ef99:	6a 08                	push   $0x8
  80ef9b:	68 bf 35 81 00       	push   $0x8135bf
  80efa0:	6a 23                	push   $0x23
  80efa2:	68 dc 35 81 00       	push   $0x8135dc
  80efa7:	e8 9e f4 ff ff       	call   80e44a <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80efac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efaf:	5b                   	pop    %ebx
  80efb0:	5e                   	pop    %esi
  80efb1:	5f                   	pop    %edi
  80efb2:	5d                   	pop    %ebp
  80efb3:	c3                   	ret    

0080efb4 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80efb4:	55                   	push   %ebp
  80efb5:	89 e5                	mov    %esp,%ebp
  80efb7:	57                   	push   %edi
  80efb8:	56                   	push   %esi
  80efb9:	53                   	push   %ebx
  80efba:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efbd:	bb 00 00 00 00       	mov    $0x0,%ebx
  80efc2:	b8 09 00 00 00       	mov    $0x9,%eax
  80efc7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efca:	8b 55 08             	mov    0x8(%ebp),%edx
  80efcd:	89 df                	mov    %ebx,%edi
  80efcf:	89 de                	mov    %ebx,%esi
  80efd1:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80efd3:	85 c0                	test   %eax,%eax
  80efd5:	7e 17                	jle    80efee <sys_env_set_trapframe+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80efd7:	83 ec 0c             	sub    $0xc,%esp
  80efda:	50                   	push   %eax
  80efdb:	6a 09                	push   $0x9
  80efdd:	68 bf 35 81 00       	push   $0x8135bf
  80efe2:	6a 23                	push   $0x23
  80efe4:	68 dc 35 81 00       	push   $0x8135dc
  80efe9:	e8 5c f4 ff ff       	call   80e44a <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80efee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eff1:	5b                   	pop    %ebx
  80eff2:	5e                   	pop    %esi
  80eff3:	5f                   	pop    %edi
  80eff4:	5d                   	pop    %ebp
  80eff5:	c3                   	ret    

0080eff6 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80eff6:	55                   	push   %ebp
  80eff7:	89 e5                	mov    %esp,%ebp
  80eff9:	57                   	push   %edi
  80effa:	56                   	push   %esi
  80effb:	53                   	push   %ebx
  80effc:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efff:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f004:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f009:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f00c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f00f:	89 df                	mov    %ebx,%edi
  80f011:	89 de                	mov    %ebx,%esi
  80f013:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f015:	85 c0                	test   %eax,%eax
  80f017:	7e 17                	jle    80f030 <sys_env_set_pgfault_upcall+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f019:	83 ec 0c             	sub    $0xc,%esp
  80f01c:	50                   	push   %eax
  80f01d:	6a 0a                	push   $0xa
  80f01f:	68 bf 35 81 00       	push   $0x8135bf
  80f024:	6a 23                	push   $0x23
  80f026:	68 dc 35 81 00       	push   $0x8135dc
  80f02b:	e8 1a f4 ff ff       	call   80e44a <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f030:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f033:	5b                   	pop    %ebx
  80f034:	5e                   	pop    %esi
  80f035:	5f                   	pop    %edi
  80f036:	5d                   	pop    %ebp
  80f037:	c3                   	ret    

0080f038 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f038:	55                   	push   %ebp
  80f039:	89 e5                	mov    %esp,%ebp
  80f03b:	57                   	push   %edi
  80f03c:	56                   	push   %esi
  80f03d:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f03e:	be 00 00 00 00       	mov    $0x0,%esi
  80f043:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f048:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f04b:	8b 55 08             	mov    0x8(%ebp),%edx
  80f04e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f051:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f054:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f056:	5b                   	pop    %ebx
  80f057:	5e                   	pop    %esi
  80f058:	5f                   	pop    %edi
  80f059:	5d                   	pop    %ebp
  80f05a:	c3                   	ret    

0080f05b <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f05b:	55                   	push   %ebp
  80f05c:	89 e5                	mov    %esp,%ebp
  80f05e:	57                   	push   %edi
  80f05f:	56                   	push   %esi
  80f060:	53                   	push   %ebx
  80f061:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f064:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f069:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f06e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f071:	89 cb                	mov    %ecx,%ebx
  80f073:	89 cf                	mov    %ecx,%edi
  80f075:	89 ce                	mov    %ecx,%esi
  80f077:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f079:	85 c0                	test   %eax,%eax
  80f07b:	7e 17                	jle    80f094 <sys_ipc_recv+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f07d:	83 ec 0c             	sub    $0xc,%esp
  80f080:	50                   	push   %eax
  80f081:	6a 0d                	push   $0xd
  80f083:	68 bf 35 81 00       	push   $0x8135bf
  80f088:	6a 23                	push   $0x23
  80f08a:	68 dc 35 81 00       	push   $0x8135dc
  80f08f:	e8 b6 f3 ff ff       	call   80e44a <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f094:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f097:	5b                   	pop    %ebx
  80f098:	5e                   	pop    %esi
  80f099:	5f                   	pop    %edi
  80f09a:	5d                   	pop    %ebp
  80f09b:	c3                   	ret    

0080f09c <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f09c:	55                   	push   %ebp
  80f09d:	89 e5                	mov    %esp,%ebp
  80f09f:	57                   	push   %edi
  80f0a0:	56                   	push   %esi
  80f0a1:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f0a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80f0a7:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f0ac:	89 d1                	mov    %edx,%ecx
  80f0ae:	89 d3                	mov    %edx,%ebx
  80f0b0:	89 d7                	mov    %edx,%edi
  80f0b2:	89 d6                	mov    %edx,%esi
  80f0b4:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f0b6:	5b                   	pop    %ebx
  80f0b7:	5e                   	pop    %esi
  80f0b8:	5f                   	pop    %edi
  80f0b9:	5d                   	pop    %ebp
  80f0ba:	c3                   	ret    

0080f0bb <sys_transmit_packet>:

int
sys_transmit_packet(void *buf, size_t size)
{
  80f0bb:	55                   	push   %ebp
  80f0bc:	89 e5                	mov    %esp,%ebp
  80f0be:	57                   	push   %edi
  80f0bf:	56                   	push   %esi
  80f0c0:	53                   	push   %ebx
  80f0c1:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f0c4:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f0c9:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f0ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0d1:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0d4:	89 df                	mov    %ebx,%edi
  80f0d6:	89 de                	mov    %ebx,%esi
  80f0d8:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f0da:	85 c0                	test   %eax,%eax
  80f0dc:	7e 17                	jle    80f0f5 <sys_transmit_packet+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f0de:	83 ec 0c             	sub    $0xc,%esp
  80f0e1:	50                   	push   %eax
  80f0e2:	6a 0f                	push   $0xf
  80f0e4:	68 bf 35 81 00       	push   $0x8135bf
  80f0e9:	6a 23                	push   $0x23
  80f0eb:	68 dc 35 81 00       	push   $0x8135dc
  80f0f0:	e8 55 f3 ff ff       	call   80e44a <_panic>
int
sys_transmit_packet(void *buf, size_t size)
{
	return syscall(SYS_transmit_packet, 1,
		(uint32_t) buf, (uint32_t) size, 0, 0, 0);
}
  80f0f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f0f8:	5b                   	pop    %ebx
  80f0f9:	5e                   	pop    %esi
  80f0fa:	5f                   	pop    %edi
  80f0fb:	5d                   	pop    %ebp
  80f0fc:	c3                   	ret    

0080f0fd <sys_receive_packet>:

int
sys_receive_packet(void *buf, size_t *size_store)
{
  80f0fd:	55                   	push   %ebp
  80f0fe:	89 e5                	mov    %esp,%ebp
  80f100:	57                   	push   %edi
  80f101:	56                   	push   %esi
  80f102:	53                   	push   %ebx
  80f103:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f106:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f10b:	b8 10 00 00 00       	mov    $0x10,%eax
  80f110:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f113:	8b 55 08             	mov    0x8(%ebp),%edx
  80f116:	89 df                	mov    %ebx,%edi
  80f118:	89 de                	mov    %ebx,%esi
  80f11a:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f11c:	85 c0                	test   %eax,%eax
  80f11e:	7e 17                	jle    80f137 <sys_receive_packet+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f120:	83 ec 0c             	sub    $0xc,%esp
  80f123:	50                   	push   %eax
  80f124:	6a 10                	push   $0x10
  80f126:	68 bf 35 81 00       	push   $0x8135bf
  80f12b:	6a 23                	push   $0x23
  80f12d:	68 dc 35 81 00       	push   $0x8135dc
  80f132:	e8 13 f3 ff ff       	call   80e44a <_panic>
int
sys_receive_packet(void *buf, size_t *size_store)
{
	return syscall(SYS_receive_packet, 1,
		(uint32_t) buf, (uint32_t) size_store, 0, 0, 0);
}
  80f137:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f13a:	5b                   	pop    %ebx
  80f13b:	5e                   	pop    %esi
  80f13c:	5f                   	pop    %edi
  80f13d:	5d                   	pop    %ebp
  80f13e:	c3                   	ret    

0080f13f <sys_get_mac_address>:

int
sys_get_mac_address(void *buf)
{
  80f13f:	55                   	push   %ebp
  80f140:	89 e5                	mov    %esp,%ebp
  80f142:	57                   	push   %edi
  80f143:	56                   	push   %esi
  80f144:	53                   	push   %ebx
  80f145:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f148:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f14d:	b8 11 00 00 00       	mov    $0x11,%eax
  80f152:	8b 55 08             	mov    0x8(%ebp),%edx
  80f155:	89 cb                	mov    %ecx,%ebx
  80f157:	89 cf                	mov    %ecx,%edi
  80f159:	89 ce                	mov    %ecx,%esi
  80f15b:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f15d:	85 c0                	test   %eax,%eax
  80f15f:	7e 17                	jle    80f178 <sys_get_mac_address+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f161:	83 ec 0c             	sub    $0xc,%esp
  80f164:	50                   	push   %eax
  80f165:	6a 11                	push   $0x11
  80f167:	68 bf 35 81 00       	push   $0x8135bf
  80f16c:	6a 23                	push   $0x23
  80f16e:	68 dc 35 81 00       	push   $0x8135dc
  80f173:	e8 d2 f2 ff ff       	call   80e44a <_panic>
int
sys_get_mac_address(void *buf)
{
	return syscall(SYS_get_mac_address, 1,
		(uint32_t) buf, 0, 0, 0, 0);
}
  80f178:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f17b:	5b                   	pop    %ebx
  80f17c:	5e                   	pop    %esi
  80f17d:	5f                   	pop    %edi
  80f17e:	5d                   	pop    %ebp
  80f17f:	c3                   	ret    

0080f180 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f180:	55                   	push   %ebp
  80f181:	89 e5                	mov    %esp,%ebp
  80f183:	53                   	push   %ebx
  80f184:	83 ec 04             	sub    $0x4,%esp
  80f187:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80f18a:	8b 18                	mov    (%eax),%ebx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	unsigned pn = ((uint32_t)addr)/PGSIZE;
  80f18c:	89 da                	mov    %ebx,%edx
  80f18e:	c1 ea 0c             	shr    $0xc,%edx
	pte_t pte = uvpt[pn];
  80f191:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(err & FEC_WR) || !(pte & PTE_COW)) {
  80f198:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f19c:	74 05                	je     80f1a3 <pgfault+0x23>
  80f19e:	f6 c6 08             	test   $0x8,%dh
  80f1a1:	75 14                	jne    80f1b7 <pgfault+0x37>
		panic("fork pgfault handler: does not handle this fault");
  80f1a3:	83 ec 04             	sub    $0x4,%esp
  80f1a6:	68 ec 35 81 00       	push   $0x8135ec
  80f1ab:	6a 1f                	push   $0x1f
  80f1ad:	68 1d 36 81 00       	push   $0x81361d
  80f1b2:	e8 93 f2 ff ff       	call   80e44a <_panic>
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
	// Allocate a new page, mapped at temp location
	if ((r = sys_page_alloc(0, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0)
  80f1b7:	83 ec 04             	sub    $0x4,%esp
  80f1ba:	6a 07                	push   $0x7
  80f1bc:	68 00 f0 7f 00       	push   $0x7ff000
  80f1c1:	6a 00                	push   $0x0
  80f1c3:	e8 e3 fc ff ff       	call   80eeab <sys_page_alloc>
  80f1c8:	83 c4 10             	add    $0x10,%esp
  80f1cb:	85 c0                	test   %eax,%eax
  80f1cd:	79 12                	jns    80f1e1 <pgfault+0x61>
		panic("sys_page_alloc: %e", r);
  80f1cf:	50                   	push   %eax
  80f1d0:	68 28 36 81 00       	push   $0x813628
  80f1d5:	6a 2b                	push   $0x2b
  80f1d7:	68 1d 36 81 00       	push   $0x81361d
  80f1dc:	e8 69 f2 ff ff       	call   80e44a <_panic>

	// Copy the data from the old page to this new page
	void *addr_pgstart = (void *) ROUNDDOWN(addr, PGSIZE);
  80f1e1:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	memmove(PFTEMP, addr_pgstart, PGSIZE);
  80f1e7:	83 ec 04             	sub    $0x4,%esp
  80f1ea:	68 00 10 00 00       	push   $0x1000
  80f1ef:	53                   	push   %ebx
  80f1f0:	68 00 f0 7f 00       	push   $0x7ff000
  80f1f5:	e8 40 fa ff ff       	call   80ec3a <memmove>

	// Move the new page to the old page's address
	if ((r = sys_page_map(0, PFTEMP, 0, addr_pgstart, PTE_P|PTE_U|PTE_W)) < 0)
  80f1fa:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f201:	53                   	push   %ebx
  80f202:	6a 00                	push   $0x0
  80f204:	68 00 f0 7f 00       	push   $0x7ff000
  80f209:	6a 00                	push   $0x0
  80f20b:	e8 de fc ff ff       	call   80eeee <sys_page_map>
  80f210:	83 c4 20             	add    $0x20,%esp
  80f213:	85 c0                	test   %eax,%eax
  80f215:	79 12                	jns    80f229 <pgfault+0xa9>
		panic("sys_page_map: %e", r);
  80f217:	50                   	push   %eax
  80f218:	68 3b 36 81 00       	push   $0x81363b
  80f21d:	6a 33                	push   $0x33
  80f21f:	68 1d 36 81 00       	push   $0x81361d
  80f224:	e8 21 f2 ff ff       	call   80e44a <_panic>

	// Unmap the temp location
	if ((r = sys_page_unmap(0, PFTEMP)) < 0)
  80f229:	83 ec 08             	sub    $0x8,%esp
  80f22c:	68 00 f0 7f 00       	push   $0x7ff000
  80f231:	6a 00                	push   $0x0
  80f233:	e8 f8 fc ff ff       	call   80ef30 <sys_page_unmap>
  80f238:	83 c4 10             	add    $0x10,%esp
  80f23b:	85 c0                	test   %eax,%eax
  80f23d:	79 12                	jns    80f251 <pgfault+0xd1>
		panic("sys_page_unmap: %e", r);
  80f23f:	50                   	push   %eax
  80f240:	68 4c 36 81 00       	push   $0x81364c
  80f245:	6a 37                	push   $0x37
  80f247:	68 1d 36 81 00       	push   $0x81361d
  80f24c:	e8 f9 f1 ff ff       	call   80e44a <_panic>
}
  80f251:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f254:	c9                   	leave  
  80f255:	c3                   	ret    

0080f256 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f256:	55                   	push   %ebp
  80f257:	89 e5                	mov    %esp,%ebp
  80f259:	57                   	push   %edi
  80f25a:	56                   	push   %esi
  80f25b:	53                   	push   %ebx
  80f25c:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	// Set up page fault handler
	set_pgfault_handler(&pgfault);
  80f25f:	68 80 f1 80 00       	push   $0x80f180
  80f264:	e8 ca 16 00 00       	call   810933 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  80f269:	b8 07 00 00 00       	mov    $0x7,%eax
  80f26e:	cd 30                	int    $0x30
  80f270:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80f273:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	// Create child
	envid_t envid = sys_exofork();
	if (envid < 0) {
  80f276:	83 c4 10             	add    $0x10,%esp
  80f279:	85 c0                	test   %eax,%eax
  80f27b:	79 15                	jns    80f292 <fork+0x3c>
		panic("sys_exofork: %e", envid);
  80f27d:	50                   	push   %eax
  80f27e:	68 5f 36 81 00       	push   $0x81365f
  80f283:	68 93 00 00 00       	push   $0x93
  80f288:	68 1d 36 81 00       	push   $0x81361d
  80f28d:	e8 b8 f1 ff ff       	call   80e44a <_panic>
		return envid;
	}

	// If we are the child, fix thisenv.
	if (envid == 0) {
  80f292:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80f296:	75 21                	jne    80f2b9 <fork+0x63>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f298:	e8 d0 fb ff ff       	call   80ee6d <sys_getenvid>
  80f29d:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f2a2:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f2a5:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f2aa:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f2af:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2b4:	e9 5a 01 00 00       	jmp    80f413 <fork+0x1bd>
	// We are the parent!
	// Set page fault handler on the child.
	// The parent needs to do it, else the child wouldn't be able to handle the
	// fault when trying to access it's stack (which happens as soon it starts)
	extern void _pgfault_upcall(void);
	sys_page_alloc(envid, (void *) (UXSTACKTOP-PGSIZE), PTE_P | PTE_U | PTE_W);
  80f2b9:	83 ec 04             	sub    $0x4,%esp
  80f2bc:	6a 07                	push   $0x7
  80f2be:	68 00 f0 bf ee       	push   $0xeebff000
  80f2c3:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80f2c6:	57                   	push   %edi
  80f2c7:	e8 df fb ff ff       	call   80eeab <sys_page_alloc>
	sys_env_set_pgfault_upcall(envid, (void *) _pgfault_upcall);
  80f2cc:	83 c4 08             	add    $0x8,%esp
  80f2cf:	68 78 09 81 00       	push   $0x810978
  80f2d4:	57                   	push   %edi
  80f2d5:	e8 1c fd ff ff       	call   80eff6 <sys_env_set_pgfault_upcall>
  80f2da:	83 c4 10             	add    $0x10,%esp

	// Copy our address space to child. Be careful not to copy the exception
	// stack too, so go until USTACKTOP instead of UTOP.
	unsigned pn;
	for (pn = UTEXT/PGSIZE; pn < USTACKTOP/PGSIZE; pn++) {
  80f2dd:	bb 00 08 00 00       	mov    $0x800,%ebx
static int
duppage(envid_t envid, unsigned pn)
{
	// Check if the page table that contains the PTE we want is allocated
	// using UVPD. If it is not, just don't map anything, and silently succeed.
	if (!(uvpd[pn/NPTENTRIES] & PTE_P))
  80f2e2:	89 d8                	mov    %ebx,%eax
  80f2e4:	c1 e8 0a             	shr    $0xa,%eax
  80f2e7:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f2ee:	a8 01                	test   $0x1,%al
  80f2f0:	0f 84 e2 00 00 00    	je     80f3d8 <fork+0x182>
		return 0;

	// Retrieve the PTE using UVPT
	pte_t pte = uvpt[pn];
  80f2f6:	8b 34 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%esi

	// If the page is present, duplicate according to it's permissions
	if (pte & PTE_P) {
  80f2fd:	f7 c6 01 00 00 00    	test   $0x1,%esi
  80f303:	0f 84 cf 00 00 00    	je     80f3d8 <fork+0x182>
		int r;
		uint32_t perm = pte & PTE_SYSCALL;
  80f309:	89 f0                	mov    %esi,%eax
  80f30b:	25 07 0e 00 00       	and    $0xe07,%eax
  80f310:	89 df                	mov    %ebx,%edi
  80f312:	c1 e7 0c             	shl    $0xc,%edi
		void *va = (void *) (pn * PGSIZE);

		// If PTE_SHARE is enabled, share it by just copying the
		// pte, which can be done by mapping on the same address
		// with the same permissions, even if it is writable
		if (pte & PTE_SHARE) {
  80f315:	f7 c6 00 04 00 00    	test   $0x400,%esi
  80f31b:	74 2d                	je     80f34a <fork+0xf4>
			// Map on the child
			if ((r = sys_page_map(0, va, envid, va, perm)) < 0) {
  80f31d:	83 ec 0c             	sub    $0xc,%esp
  80f320:	50                   	push   %eax
  80f321:	57                   	push   %edi
  80f322:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f325:	57                   	push   %edi
  80f326:	6a 00                	push   $0x0
  80f328:	e8 c1 fb ff ff       	call   80eeee <sys_page_map>
  80f32d:	83 c4 20             	add    $0x20,%esp
  80f330:	85 c0                	test   %eax,%eax
  80f332:	0f 89 a0 00 00 00    	jns    80f3d8 <fork+0x182>
				panic("sys_page_map: %e", r);
  80f338:	50                   	push   %eax
  80f339:	68 3b 36 81 00       	push   $0x81363b
  80f33e:	6a 5c                	push   $0x5c
  80f340:	68 1d 36 81 00       	push   $0x81361d
  80f345:	e8 00 f1 ff ff       	call   80e44a <_panic>
				return r;
			}
		// If writable or COW, make it COW on parent and child
		} else if (pte & (PTE_W | PTE_COW)) {
  80f34a:	f7 c6 02 08 00 00    	test   $0x802,%esi
  80f350:	74 5d                	je     80f3af <fork+0x159>
			perm &= ~PTE_W;  // Remove PTE_W, so it faults
  80f352:	81 e6 05 0e 00 00    	and    $0xe05,%esi
			perm |= PTE_COW; // Make it PTE_COW
			// Map on the child
			if ((r = sys_page_map(0, va, envid, va, perm)) < 0) {
  80f358:	81 ce 00 08 00 00    	or     $0x800,%esi
  80f35e:	83 ec 0c             	sub    $0xc,%esp
  80f361:	56                   	push   %esi
  80f362:	57                   	push   %edi
  80f363:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f366:	57                   	push   %edi
  80f367:	6a 00                	push   $0x0
  80f369:	e8 80 fb ff ff       	call   80eeee <sys_page_map>
  80f36e:	83 c4 20             	add    $0x20,%esp
  80f371:	85 c0                	test   %eax,%eax
  80f373:	79 12                	jns    80f387 <fork+0x131>
				panic("sys_page_map: %e", r);
  80f375:	50                   	push   %eax
  80f376:	68 3b 36 81 00       	push   $0x81363b
  80f37b:	6a 65                	push   $0x65
  80f37d:	68 1d 36 81 00       	push   $0x81361d
  80f382:	e8 c3 f0 ff ff       	call   80e44a <_panic>
				return r;
			}
			// Change the permission on parent, mapping on itself
			if ((r = sys_page_map(0, va, 0, va, perm)) < 0) {
  80f387:	83 ec 0c             	sub    $0xc,%esp
  80f38a:	56                   	push   %esi
  80f38b:	57                   	push   %edi
  80f38c:	6a 00                	push   $0x0
  80f38e:	57                   	push   %edi
  80f38f:	6a 00                	push   $0x0
  80f391:	e8 58 fb ff ff       	call   80eeee <sys_page_map>
  80f396:	83 c4 20             	add    $0x20,%esp
  80f399:	85 c0                	test   %eax,%eax
  80f39b:	79 3b                	jns    80f3d8 <fork+0x182>
				panic("sys_page_map: %e", r);
  80f39d:	50                   	push   %eax
  80f39e:	68 3b 36 81 00       	push   $0x81363b
  80f3a3:	6a 6a                	push   $0x6a
  80f3a5:	68 1d 36 81 00       	push   $0x81361d
  80f3aa:	e8 9b f0 ff ff       	call   80e44a <_panic>
				return r;
			}
		// If it is read-only, just share it.
		} else {
			// Map on the child
			if ((r = sys_page_map(0, va, envid, va, perm)) < 0) {
  80f3af:	83 ec 0c             	sub    $0xc,%esp
  80f3b2:	50                   	push   %eax
  80f3b3:	57                   	push   %edi
  80f3b4:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f3b7:	57                   	push   %edi
  80f3b8:	6a 00                	push   $0x0
  80f3ba:	e8 2f fb ff ff       	call   80eeee <sys_page_map>
  80f3bf:	83 c4 20             	add    $0x20,%esp
  80f3c2:	85 c0                	test   %eax,%eax
  80f3c4:	79 12                	jns    80f3d8 <fork+0x182>
				panic("sys_page_map: %e", r);
  80f3c6:	50                   	push   %eax
  80f3c7:	68 3b 36 81 00       	push   $0x81363b
  80f3cc:	6a 71                	push   $0x71
  80f3ce:	68 1d 36 81 00       	push   $0x81361d
  80f3d3:	e8 72 f0 ff ff       	call   80e44a <_panic>
	sys_env_set_pgfault_upcall(envid, (void *) _pgfault_upcall);

	// Copy our address space to child. Be careful not to copy the exception
	// stack too, so go until USTACKTOP instead of UTOP.
	unsigned pn;
	for (pn = UTEXT/PGSIZE; pn < USTACKTOP/PGSIZE; pn++) {
  80f3d8:	83 c3 01             	add    $0x1,%ebx
  80f3db:	81 fb fe eb 0e 00    	cmp    $0xeebfe,%ebx
  80f3e1:	0f 85 fb fe ff ff    	jne    80f2e2 <fork+0x8c>
		duppage(envid, pn);
	}

	// Make the child runnable
	int r;
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0) {
  80f3e7:	83 ec 08             	sub    $0x8,%esp
  80f3ea:	6a 02                	push   $0x2
  80f3ec:	ff 75 e0             	pushl  -0x20(%ebp)
  80f3ef:	e8 7e fb ff ff       	call   80ef72 <sys_env_set_status>
  80f3f4:	83 c4 10             	add    $0x10,%esp
  80f3f7:	85 c0                	test   %eax,%eax
  80f3f9:	79 15                	jns    80f410 <fork+0x1ba>
		panic("sys_env_set_status: %e", r);
  80f3fb:	50                   	push   %eax
  80f3fc:	68 6f 36 81 00       	push   $0x81366f
  80f401:	68 af 00 00 00       	push   $0xaf
  80f406:	68 1d 36 81 00       	push   $0x81361d
  80f40b:	e8 3a f0 ff ff       	call   80e44a <_panic>
		return r;
	}

	return envid;
  80f410:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80f413:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f416:	5b                   	pop    %ebx
  80f417:	5e                   	pop    %esi
  80f418:	5f                   	pop    %edi
  80f419:	5d                   	pop    %ebp
  80f41a:	c3                   	ret    

0080f41b <sfork>:

// Challenge!
int
sfork(void)
{
  80f41b:	55                   	push   %ebp
  80f41c:	89 e5                	mov    %esp,%ebp
  80f41e:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f421:	68 86 36 81 00       	push   $0x813686
  80f426:	68 ba 00 00 00       	push   $0xba
  80f42b:	68 1d 36 81 00       	push   $0x81361d
  80f430:	e8 15 f0 ff ff       	call   80e44a <_panic>

0080f435 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f435:	55                   	push   %ebp
  80f436:	89 e5                	mov    %esp,%ebp
  80f438:	56                   	push   %esi
  80f439:	53                   	push   %ebx
  80f43a:	8b 75 08             	mov    0x8(%ebp),%esi
  80f43d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f440:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int r;
	void *va;

	if (pg) {
  80f443:	85 c0                	test   %eax,%eax
		va = pg;
	} else {
		va = (void *) KERNBASE;
  80f445:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
  80f44a:	0f 44 c2             	cmove  %edx,%eax
	}

	r = sys_ipc_recv(va);
  80f44d:	83 ec 0c             	sub    $0xc,%esp
  80f450:	50                   	push   %eax
  80f451:	e8 05 fc ff ff       	call   80f05b <sys_ipc_recv>

	if (r < 0) {
  80f456:	83 c4 10             	add    $0x10,%esp
  80f459:	85 c0                	test   %eax,%eax
  80f45b:	79 16                	jns    80f473 <ipc_recv+0x3e>
		if (from_env_store)
  80f45d:	85 f6                	test   %esi,%esi
  80f45f:	74 06                	je     80f467 <ipc_recv+0x32>
			*from_env_store = 0;
  80f461:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

		if (perm_store)
  80f467:	85 db                	test   %ebx,%ebx
  80f469:	74 2c                	je     80f497 <ipc_recv+0x62>
			*perm_store = 0;
  80f46b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80f471:	eb 24                	jmp    80f497 <ipc_recv+0x62>

		return r;
	} else {
		if (from_env_store)
  80f473:	85 f6                	test   %esi,%esi
  80f475:	74 0a                	je     80f481 <ipc_recv+0x4c>
			*from_env_store = thisenv->env_ipc_from;
  80f477:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f47c:	8b 40 74             	mov    0x74(%eax),%eax
  80f47f:	89 06                	mov    %eax,(%esi)

		if (perm_store)
  80f481:	85 db                	test   %ebx,%ebx
  80f483:	74 0a                	je     80f48f <ipc_recv+0x5a>
			*perm_store = thisenv->env_ipc_perm;
  80f485:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f48a:	8b 40 78             	mov    0x78(%eax),%eax
  80f48d:	89 03                	mov    %eax,(%ebx)

		return thisenv->env_ipc_value;
  80f48f:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f494:	8b 40 70             	mov    0x70(%eax),%eax
	}
}
  80f497:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f49a:	5b                   	pop    %ebx
  80f49b:	5e                   	pop    %esi
  80f49c:	5d                   	pop    %ebp
  80f49d:	c3                   	ret    

0080f49e <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f49e:	55                   	push   %ebp
  80f49f:	89 e5                	mov    %esp,%ebp
  80f4a1:	57                   	push   %edi
  80f4a2:	56                   	push   %esi
  80f4a3:	53                   	push   %ebx
  80f4a4:	83 ec 0c             	sub    $0xc,%esp
  80f4a7:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f4aa:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f4ad:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	void *va;
	if (pg) {
  80f4b0:	85 db                	test   %ebx,%ebx
		va = pg;
	} else {
		va = (void *) KERNBASE;
  80f4b2:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
  80f4b7:	0f 44 d8             	cmove  %eax,%ebx
	}

	int r = -1;
	while (r < 0) {
		r = sys_ipc_try_send(to_env, val, va, perm);
  80f4ba:	ff 75 14             	pushl  0x14(%ebp)
  80f4bd:	53                   	push   %ebx
  80f4be:	56                   	push   %esi
  80f4bf:	57                   	push   %edi
  80f4c0:	e8 73 fb ff ff       	call   80f038 <sys_ipc_try_send>
		if (r == -E_IPC_NOT_RECV) {
  80f4c5:	83 c4 10             	add    $0x10,%esp
  80f4c8:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f4cb:	75 07                	jne    80f4d4 <ipc_send+0x36>
			sys_yield();
  80f4cd:	e8 ba f9 ff ff       	call   80ee8c <sys_yield>
  80f4d2:	eb e6                	jmp    80f4ba <ipc_send+0x1c>
		} else if (r < 0) {
  80f4d4:	85 c0                	test   %eax,%eax
  80f4d6:	79 12                	jns    80f4ea <ipc_send+0x4c>
			panic("ipc_send: %e", r);
  80f4d8:	50                   	push   %eax
  80f4d9:	68 9c 36 81 00       	push   $0x81369c
  80f4de:	6a 51                	push   $0x51
  80f4e0:	68 a9 36 81 00       	push   $0x8136a9
  80f4e5:	e8 60 ef ff ff       	call   80e44a <_panic>
		}
	}
}
  80f4ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4ed:	5b                   	pop    %ebx
  80f4ee:	5e                   	pop    %esi
  80f4ef:	5f                   	pop    %edi
  80f4f0:	5d                   	pop    %ebp
  80f4f1:	c3                   	ret    

0080f4f2 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f4f2:	55                   	push   %ebp
  80f4f3:	89 e5                	mov    %esp,%ebp
  80f4f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f4f8:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f4fd:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f500:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f506:	8b 52 50             	mov    0x50(%edx),%edx
  80f509:	39 ca                	cmp    %ecx,%edx
  80f50b:	75 0d                	jne    80f51a <ipc_find_env+0x28>
			return envs[i].env_id;
  80f50d:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f510:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f515:	8b 40 48             	mov    0x48(%eax),%eax
  80f518:	eb 0f                	jmp    80f529 <ipc_find_env+0x37>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  80f51a:	83 c0 01             	add    $0x1,%eax
  80f51d:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f522:	75 d9                	jne    80f4fd <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  80f524:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f529:	5d                   	pop    %ebp
  80f52a:	c3                   	ret    

0080f52b <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f52b:	55                   	push   %ebp
  80f52c:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f52e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f531:	05 00 00 00 30       	add    $0x30000000,%eax
  80f536:	c1 e8 0c             	shr    $0xc,%eax
}
  80f539:	5d                   	pop    %ebp
  80f53a:	c3                   	ret    

0080f53b <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f53b:	55                   	push   %ebp
  80f53c:	89 e5                	mov    %esp,%ebp
	return INDEX2DATA(fd2num(fd));
  80f53e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f541:	05 00 00 00 30       	add    $0x30000000,%eax
  80f546:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f54b:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f550:	5d                   	pop    %ebp
  80f551:	c3                   	ret    

0080f552 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f552:	55                   	push   %ebp
  80f553:	89 e5                	mov    %esp,%ebp
  80f555:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f558:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f55d:	89 c2                	mov    %eax,%edx
  80f55f:	c1 ea 16             	shr    $0x16,%edx
  80f562:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f569:	f6 c2 01             	test   $0x1,%dl
  80f56c:	74 11                	je     80f57f <fd_alloc+0x2d>
  80f56e:	89 c2                	mov    %eax,%edx
  80f570:	c1 ea 0c             	shr    $0xc,%edx
  80f573:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f57a:	f6 c2 01             	test   $0x1,%dl
  80f57d:	75 09                	jne    80f588 <fd_alloc+0x36>
			*fd_store = fd;
  80f57f:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f581:	b8 00 00 00 00       	mov    $0x0,%eax
  80f586:	eb 17                	jmp    80f59f <fd_alloc+0x4d>
  80f588:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  80f58d:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f592:	75 c9                	jne    80f55d <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f594:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  80f59a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  80f59f:	5d                   	pop    %ebp
  80f5a0:	c3                   	ret    

0080f5a1 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f5a1:	55                   	push   %ebp
  80f5a2:	89 e5                	mov    %esp,%ebp
  80f5a4:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f5a7:	83 f8 1f             	cmp    $0x1f,%eax
  80f5aa:	77 36                	ja     80f5e2 <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f5ac:	c1 e0 0c             	shl    $0xc,%eax
  80f5af:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f5b4:	89 c2                	mov    %eax,%edx
  80f5b6:	c1 ea 16             	shr    $0x16,%edx
  80f5b9:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f5c0:	f6 c2 01             	test   $0x1,%dl
  80f5c3:	74 24                	je     80f5e9 <fd_lookup+0x48>
  80f5c5:	89 c2                	mov    %eax,%edx
  80f5c7:	c1 ea 0c             	shr    $0xc,%edx
  80f5ca:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f5d1:	f6 c2 01             	test   $0x1,%dl
  80f5d4:	74 1a                	je     80f5f0 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f5d6:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f5d9:	89 02                	mov    %eax,(%edx)
	return 0;
  80f5db:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5e0:	eb 13                	jmp    80f5f5 <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f5e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f5e7:	eb 0c                	jmp    80f5f5 <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f5e9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f5ee:	eb 05                	jmp    80f5f5 <fd_lookup+0x54>
  80f5f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  80f5f5:	5d                   	pop    %ebp
  80f5f6:	c3                   	ret    

0080f5f7 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f5f7:	55                   	push   %ebp
  80f5f8:	89 e5                	mov    %esp,%ebp
  80f5fa:	83 ec 08             	sub    $0x8,%esp
  80f5fd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f600:	ba 30 37 81 00       	mov    $0x813730,%edx
	int i;
	for (i = 0; devtab[i]; i++)
  80f605:	eb 13                	jmp    80f61a <dev_lookup+0x23>
  80f607:	83 c2 04             	add    $0x4,%edx
		if (devtab[i]->dev_id == dev_id) {
  80f60a:	39 08                	cmp    %ecx,(%eax)
  80f60c:	75 0c                	jne    80f61a <dev_lookup+0x23>
			*dev = devtab[i];
  80f60e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f611:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f613:	b8 00 00 00 00       	mov    $0x0,%eax
  80f618:	eb 2e                	jmp    80f648 <dev_lookup+0x51>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  80f61a:	8b 02                	mov    (%edx),%eax
  80f61c:	85 c0                	test   %eax,%eax
  80f61e:	75 e7                	jne    80f607 <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f620:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f625:	8b 40 48             	mov    0x48(%eax),%eax
  80f628:	83 ec 04             	sub    $0x4,%esp
  80f62b:	51                   	push   %ecx
  80f62c:	50                   	push   %eax
  80f62d:	68 b4 36 81 00       	push   $0x8136b4
  80f632:	e8 ec ee ff ff       	call   80e523 <cprintf>
	*dev = 0;
  80f637:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f63a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f640:	83 c4 10             	add    $0x10,%esp
  80f643:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f648:	c9                   	leave  
  80f649:	c3                   	ret    

0080f64a <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80f64a:	55                   	push   %ebp
  80f64b:	89 e5                	mov    %esp,%ebp
  80f64d:	56                   	push   %esi
  80f64e:	53                   	push   %ebx
  80f64f:	83 ec 10             	sub    $0x10,%esp
  80f652:	8b 75 08             	mov    0x8(%ebp),%esi
  80f655:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f658:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f65b:	50                   	push   %eax
  80f65c:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f662:	c1 e8 0c             	shr    $0xc,%eax
  80f665:	50                   	push   %eax
  80f666:	e8 36 ff ff ff       	call   80f5a1 <fd_lookup>
  80f66b:	83 c4 08             	add    $0x8,%esp
  80f66e:	85 c0                	test   %eax,%eax
  80f670:	78 05                	js     80f677 <fd_close+0x2d>
	    || fd != fd2)
  80f672:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80f675:	74 0c                	je     80f683 <fd_close+0x39>
		return (must_exist ? r : 0);
  80f677:	84 db                	test   %bl,%bl
  80f679:	ba 00 00 00 00       	mov    $0x0,%edx
  80f67e:	0f 44 c2             	cmove  %edx,%eax
  80f681:	eb 41                	jmp    80f6c4 <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f683:	83 ec 08             	sub    $0x8,%esp
  80f686:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f689:	50                   	push   %eax
  80f68a:	ff 36                	pushl  (%esi)
  80f68c:	e8 66 ff ff ff       	call   80f5f7 <dev_lookup>
  80f691:	89 c3                	mov    %eax,%ebx
  80f693:	83 c4 10             	add    $0x10,%esp
  80f696:	85 c0                	test   %eax,%eax
  80f698:	78 1a                	js     80f6b4 <fd_close+0x6a>
		if (dev->dev_close)
  80f69a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f69d:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  80f6a0:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  80f6a5:	85 c0                	test   %eax,%eax
  80f6a7:	74 0b                	je     80f6b4 <fd_close+0x6a>
			r = (*dev->dev_close)(fd);
  80f6a9:	83 ec 0c             	sub    $0xc,%esp
  80f6ac:	56                   	push   %esi
  80f6ad:	ff d0                	call   *%eax
  80f6af:	89 c3                	mov    %eax,%ebx
  80f6b1:	83 c4 10             	add    $0x10,%esp
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80f6b4:	83 ec 08             	sub    $0x8,%esp
  80f6b7:	56                   	push   %esi
  80f6b8:	6a 00                	push   $0x0
  80f6ba:	e8 71 f8 ff ff       	call   80ef30 <sys_page_unmap>
	return r;
  80f6bf:	83 c4 10             	add    $0x10,%esp
  80f6c2:	89 d8                	mov    %ebx,%eax
}
  80f6c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f6c7:	5b                   	pop    %ebx
  80f6c8:	5e                   	pop    %esi
  80f6c9:	5d                   	pop    %ebp
  80f6ca:	c3                   	ret    

0080f6cb <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80f6cb:	55                   	push   %ebp
  80f6cc:	89 e5                	mov    %esp,%ebp
  80f6ce:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f6d1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f6d4:	50                   	push   %eax
  80f6d5:	ff 75 08             	pushl  0x8(%ebp)
  80f6d8:	e8 c4 fe ff ff       	call   80f5a1 <fd_lookup>
  80f6dd:	83 c4 08             	add    $0x8,%esp
  80f6e0:	85 c0                	test   %eax,%eax
  80f6e2:	78 10                	js     80f6f4 <close+0x29>
		return r;
	else
		return fd_close(fd, 1);
  80f6e4:	83 ec 08             	sub    $0x8,%esp
  80f6e7:	6a 01                	push   $0x1
  80f6e9:	ff 75 f4             	pushl  -0xc(%ebp)
  80f6ec:	e8 59 ff ff ff       	call   80f64a <fd_close>
  80f6f1:	83 c4 10             	add    $0x10,%esp
}
  80f6f4:	c9                   	leave  
  80f6f5:	c3                   	ret    

0080f6f6 <close_all>:

void
close_all(void)
{
  80f6f6:	55                   	push   %ebp
  80f6f7:	89 e5                	mov    %esp,%ebp
  80f6f9:	53                   	push   %ebx
  80f6fa:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f6fd:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f702:	83 ec 0c             	sub    $0xc,%esp
  80f705:	53                   	push   %ebx
  80f706:	e8 c0 ff ff ff       	call   80f6cb <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80f70b:	83 c3 01             	add    $0x1,%ebx
  80f70e:	83 c4 10             	add    $0x10,%esp
  80f711:	83 fb 20             	cmp    $0x20,%ebx
  80f714:	75 ec                	jne    80f702 <close_all+0xc>
		close(i);
}
  80f716:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f719:	c9                   	leave  
  80f71a:	c3                   	ret    

0080f71b <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f71b:	55                   	push   %ebp
  80f71c:	89 e5                	mov    %esp,%ebp
  80f71e:	57                   	push   %edi
  80f71f:	56                   	push   %esi
  80f720:	53                   	push   %ebx
  80f721:	83 ec 2c             	sub    $0x2c,%esp
  80f724:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f727:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f72a:	50                   	push   %eax
  80f72b:	ff 75 08             	pushl  0x8(%ebp)
  80f72e:	e8 6e fe ff ff       	call   80f5a1 <fd_lookup>
  80f733:	83 c4 08             	add    $0x8,%esp
  80f736:	85 c0                	test   %eax,%eax
  80f738:	0f 88 c1 00 00 00    	js     80f7ff <dup+0xe4>
		return r;
	close(newfdnum);
  80f73e:	83 ec 0c             	sub    $0xc,%esp
  80f741:	56                   	push   %esi
  80f742:	e8 84 ff ff ff       	call   80f6cb <close>

	newfd = INDEX2FD(newfdnum);
  80f747:	89 f3                	mov    %esi,%ebx
  80f749:	c1 e3 0c             	shl    $0xc,%ebx
  80f74c:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  80f752:	83 c4 04             	add    $0x4,%esp
  80f755:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f758:	e8 de fd ff ff       	call   80f53b <fd2data>
  80f75d:	89 c7                	mov    %eax,%edi
	nva = fd2data(newfd);
  80f75f:	89 1c 24             	mov    %ebx,(%esp)
  80f762:	e8 d4 fd ff ff       	call   80f53b <fd2data>
  80f767:	83 c4 10             	add    $0x10,%esp
  80f76a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f76d:	89 f8                	mov    %edi,%eax
  80f76f:	c1 e8 16             	shr    $0x16,%eax
  80f772:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f779:	a8 01                	test   $0x1,%al
  80f77b:	74 37                	je     80f7b4 <dup+0x99>
  80f77d:	89 f8                	mov    %edi,%eax
  80f77f:	c1 e8 0c             	shr    $0xc,%eax
  80f782:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f789:	f6 c2 01             	test   $0x1,%dl
  80f78c:	74 26                	je     80f7b4 <dup+0x99>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f78e:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f795:	83 ec 0c             	sub    $0xc,%esp
  80f798:	25 07 0e 00 00       	and    $0xe07,%eax
  80f79d:	50                   	push   %eax
  80f79e:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f7a1:	6a 00                	push   $0x0
  80f7a3:	57                   	push   %edi
  80f7a4:	6a 00                	push   $0x0
  80f7a6:	e8 43 f7 ff ff       	call   80eeee <sys_page_map>
  80f7ab:	89 c7                	mov    %eax,%edi
  80f7ad:	83 c4 20             	add    $0x20,%esp
  80f7b0:	85 c0                	test   %eax,%eax
  80f7b2:	78 2e                	js     80f7e2 <dup+0xc7>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f7b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f7b7:	89 d0                	mov    %edx,%eax
  80f7b9:	c1 e8 0c             	shr    $0xc,%eax
  80f7bc:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f7c3:	83 ec 0c             	sub    $0xc,%esp
  80f7c6:	25 07 0e 00 00       	and    $0xe07,%eax
  80f7cb:	50                   	push   %eax
  80f7cc:	53                   	push   %ebx
  80f7cd:	6a 00                	push   $0x0
  80f7cf:	52                   	push   %edx
  80f7d0:	6a 00                	push   $0x0
  80f7d2:	e8 17 f7 ff ff       	call   80eeee <sys_page_map>
  80f7d7:	89 c7                	mov    %eax,%edi
  80f7d9:	83 c4 20             	add    $0x20,%esp
		goto err;

	return newfdnum;
  80f7dc:	89 f0                	mov    %esi,%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f7de:	85 ff                	test   %edi,%edi
  80f7e0:	79 1d                	jns    80f7ff <dup+0xe4>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  80f7e2:	83 ec 08             	sub    $0x8,%esp
  80f7e5:	53                   	push   %ebx
  80f7e6:	6a 00                	push   $0x0
  80f7e8:	e8 43 f7 ff ff       	call   80ef30 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f7ed:	83 c4 08             	add    $0x8,%esp
  80f7f0:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f7f3:	6a 00                	push   $0x0
  80f7f5:	e8 36 f7 ff ff       	call   80ef30 <sys_page_unmap>
	return r;
  80f7fa:	83 c4 10             	add    $0x10,%esp
  80f7fd:	89 f8                	mov    %edi,%eax
}
  80f7ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f802:	5b                   	pop    %ebx
  80f803:	5e                   	pop    %esi
  80f804:	5f                   	pop    %edi
  80f805:	5d                   	pop    %ebp
  80f806:	c3                   	ret    

0080f807 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f807:	55                   	push   %ebp
  80f808:	89 e5                	mov    %esp,%ebp
  80f80a:	53                   	push   %ebx
  80f80b:	83 ec 14             	sub    $0x14,%esp
  80f80e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f811:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f814:	50                   	push   %eax
  80f815:	53                   	push   %ebx
  80f816:	e8 86 fd ff ff       	call   80f5a1 <fd_lookup>
  80f81b:	83 c4 08             	add    $0x8,%esp
  80f81e:	89 c2                	mov    %eax,%edx
  80f820:	85 c0                	test   %eax,%eax
  80f822:	78 6d                	js     80f891 <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f824:	83 ec 08             	sub    $0x8,%esp
  80f827:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f82a:	50                   	push   %eax
  80f82b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f82e:	ff 30                	pushl  (%eax)
  80f830:	e8 c2 fd ff ff       	call   80f5f7 <dev_lookup>
  80f835:	83 c4 10             	add    $0x10,%esp
  80f838:	85 c0                	test   %eax,%eax
  80f83a:	78 4c                	js     80f888 <read+0x81>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80f83c:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80f83f:	8b 42 08             	mov    0x8(%edx),%eax
  80f842:	83 e0 03             	and    $0x3,%eax
  80f845:	83 f8 01             	cmp    $0x1,%eax
  80f848:	75 21                	jne    80f86b <read+0x64>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80f84a:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f84f:	8b 40 48             	mov    0x48(%eax),%eax
  80f852:	83 ec 04             	sub    $0x4,%esp
  80f855:	53                   	push   %ebx
  80f856:	50                   	push   %eax
  80f857:	68 f5 36 81 00       	push   $0x8136f5
  80f85c:	e8 c2 ec ff ff       	call   80e523 <cprintf>
		return -E_INVAL;
  80f861:	83 c4 10             	add    $0x10,%esp
  80f864:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f869:	eb 26                	jmp    80f891 <read+0x8a>
	}
	if (!dev->dev_read)
  80f86b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f86e:	8b 40 08             	mov    0x8(%eax),%eax
  80f871:	85 c0                	test   %eax,%eax
  80f873:	74 17                	je     80f88c <read+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80f875:	83 ec 04             	sub    $0x4,%esp
  80f878:	ff 75 10             	pushl  0x10(%ebp)
  80f87b:	ff 75 0c             	pushl  0xc(%ebp)
  80f87e:	52                   	push   %edx
  80f87f:	ff d0                	call   *%eax
  80f881:	89 c2                	mov    %eax,%edx
  80f883:	83 c4 10             	add    $0x10,%esp
  80f886:	eb 09                	jmp    80f891 <read+0x8a>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f888:	89 c2                	mov    %eax,%edx
  80f88a:	eb 05                	jmp    80f891 <read+0x8a>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  80f88c:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_read)(fd, buf, n);
}
  80f891:	89 d0                	mov    %edx,%eax
  80f893:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f896:	c9                   	leave  
  80f897:	c3                   	ret    

0080f898 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80f898:	55                   	push   %ebp
  80f899:	89 e5                	mov    %esp,%ebp
  80f89b:	57                   	push   %edi
  80f89c:	56                   	push   %esi
  80f89d:	53                   	push   %ebx
  80f89e:	83 ec 0c             	sub    $0xc,%esp
  80f8a1:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f8a4:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f8a7:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f8ac:	eb 21                	jmp    80f8cf <readn+0x37>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f8ae:	83 ec 04             	sub    $0x4,%esp
  80f8b1:	89 f0                	mov    %esi,%eax
  80f8b3:	29 d8                	sub    %ebx,%eax
  80f8b5:	50                   	push   %eax
  80f8b6:	89 d8                	mov    %ebx,%eax
  80f8b8:	03 45 0c             	add    0xc(%ebp),%eax
  80f8bb:	50                   	push   %eax
  80f8bc:	57                   	push   %edi
  80f8bd:	e8 45 ff ff ff       	call   80f807 <read>
		if (m < 0)
  80f8c2:	83 c4 10             	add    $0x10,%esp
  80f8c5:	85 c0                	test   %eax,%eax
  80f8c7:	78 10                	js     80f8d9 <readn+0x41>
			return m;
		if (m == 0)
  80f8c9:	85 c0                	test   %eax,%eax
  80f8cb:	74 0a                	je     80f8d7 <readn+0x3f>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f8cd:	01 c3                	add    %eax,%ebx
  80f8cf:	39 f3                	cmp    %esi,%ebx
  80f8d1:	72 db                	jb     80f8ae <readn+0x16>
  80f8d3:	89 d8                	mov    %ebx,%eax
  80f8d5:	eb 02                	jmp    80f8d9 <readn+0x41>
  80f8d7:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  80f8d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f8dc:	5b                   	pop    %ebx
  80f8dd:	5e                   	pop    %esi
  80f8de:	5f                   	pop    %edi
  80f8df:	5d                   	pop    %ebp
  80f8e0:	c3                   	ret    

0080f8e1 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80f8e1:	55                   	push   %ebp
  80f8e2:	89 e5                	mov    %esp,%ebp
  80f8e4:	53                   	push   %ebx
  80f8e5:	83 ec 14             	sub    $0x14,%esp
  80f8e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f8eb:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f8ee:	50                   	push   %eax
  80f8ef:	53                   	push   %ebx
  80f8f0:	e8 ac fc ff ff       	call   80f5a1 <fd_lookup>
  80f8f5:	83 c4 08             	add    $0x8,%esp
  80f8f8:	89 c2                	mov    %eax,%edx
  80f8fa:	85 c0                	test   %eax,%eax
  80f8fc:	78 68                	js     80f966 <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f8fe:	83 ec 08             	sub    $0x8,%esp
  80f901:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f904:	50                   	push   %eax
  80f905:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f908:	ff 30                	pushl  (%eax)
  80f90a:	e8 e8 fc ff ff       	call   80f5f7 <dev_lookup>
  80f90f:	83 c4 10             	add    $0x10,%esp
  80f912:	85 c0                	test   %eax,%eax
  80f914:	78 47                	js     80f95d <write+0x7c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f916:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f919:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f91d:	75 21                	jne    80f940 <write+0x5f>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80f91f:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f924:	8b 40 48             	mov    0x48(%eax),%eax
  80f927:	83 ec 04             	sub    $0x4,%esp
  80f92a:	53                   	push   %ebx
  80f92b:	50                   	push   %eax
  80f92c:	68 11 37 81 00       	push   $0x813711
  80f931:	e8 ed eb ff ff       	call   80e523 <cprintf>
		return -E_INVAL;
  80f936:	83 c4 10             	add    $0x10,%esp
  80f939:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f93e:	eb 26                	jmp    80f966 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80f940:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f943:	8b 52 0c             	mov    0xc(%edx),%edx
  80f946:	85 d2                	test   %edx,%edx
  80f948:	74 17                	je     80f961 <write+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80f94a:	83 ec 04             	sub    $0x4,%esp
  80f94d:	ff 75 10             	pushl  0x10(%ebp)
  80f950:	ff 75 0c             	pushl  0xc(%ebp)
  80f953:	50                   	push   %eax
  80f954:	ff d2                	call   *%edx
  80f956:	89 c2                	mov    %eax,%edx
  80f958:	83 c4 10             	add    $0x10,%esp
  80f95b:	eb 09                	jmp    80f966 <write+0x85>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f95d:	89 c2                	mov    %eax,%edx
  80f95f:	eb 05                	jmp    80f966 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  80f961:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_write)(fd, buf, n);
}
  80f966:	89 d0                	mov    %edx,%eax
  80f968:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f96b:	c9                   	leave  
  80f96c:	c3                   	ret    

0080f96d <seek>:

int
seek(int fdnum, off_t offset)
{
  80f96d:	55                   	push   %ebp
  80f96e:	89 e5                	mov    %esp,%ebp
  80f970:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f973:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80f976:	50                   	push   %eax
  80f977:	ff 75 08             	pushl  0x8(%ebp)
  80f97a:	e8 22 fc ff ff       	call   80f5a1 <fd_lookup>
  80f97f:	83 c4 08             	add    $0x8,%esp
  80f982:	85 c0                	test   %eax,%eax
  80f984:	78 0e                	js     80f994 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80f986:	8b 45 fc             	mov    -0x4(%ebp),%eax
  80f989:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f98c:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80f98f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f994:	c9                   	leave  
  80f995:	c3                   	ret    

0080f996 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80f996:	55                   	push   %ebp
  80f997:	89 e5                	mov    %esp,%ebp
  80f999:	53                   	push   %ebx
  80f99a:	83 ec 14             	sub    $0x14,%esp
  80f99d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f9a0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f9a3:	50                   	push   %eax
  80f9a4:	53                   	push   %ebx
  80f9a5:	e8 f7 fb ff ff       	call   80f5a1 <fd_lookup>
  80f9aa:	83 c4 08             	add    $0x8,%esp
  80f9ad:	89 c2                	mov    %eax,%edx
  80f9af:	85 c0                	test   %eax,%eax
  80f9b1:	78 65                	js     80fa18 <ftruncate+0x82>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9b3:	83 ec 08             	sub    $0x8,%esp
  80f9b6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f9b9:	50                   	push   %eax
  80f9ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f9bd:	ff 30                	pushl  (%eax)
  80f9bf:	e8 33 fc ff ff       	call   80f5f7 <dev_lookup>
  80f9c4:	83 c4 10             	add    $0x10,%esp
  80f9c7:	85 c0                	test   %eax,%eax
  80f9c9:	78 44                	js     80fa0f <ftruncate+0x79>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f9cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f9ce:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f9d2:	75 21                	jne    80f9f5 <ftruncate+0x5f>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  80f9d4:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80f9d9:	8b 40 48             	mov    0x48(%eax),%eax
  80f9dc:	83 ec 04             	sub    $0x4,%esp
  80f9df:	53                   	push   %ebx
  80f9e0:	50                   	push   %eax
  80f9e1:	68 d4 36 81 00       	push   $0x8136d4
  80f9e6:	e8 38 eb ff ff       	call   80e523 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  80f9eb:	83 c4 10             	add    $0x10,%esp
  80f9ee:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f9f3:	eb 23                	jmp    80fa18 <ftruncate+0x82>
	}
	if (!dev->dev_trunc)
  80f9f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f9f8:	8b 52 18             	mov    0x18(%edx),%edx
  80f9fb:	85 d2                	test   %edx,%edx
  80f9fd:	74 14                	je     80fa13 <ftruncate+0x7d>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80f9ff:	83 ec 08             	sub    $0x8,%esp
  80fa02:	ff 75 0c             	pushl  0xc(%ebp)
  80fa05:	50                   	push   %eax
  80fa06:	ff d2                	call   *%edx
  80fa08:	89 c2                	mov    %eax,%edx
  80fa0a:	83 c4 10             	add    $0x10,%esp
  80fa0d:	eb 09                	jmp    80fa18 <ftruncate+0x82>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fa0f:	89 c2                	mov    %eax,%edx
  80fa11:	eb 05                	jmp    80fa18 <ftruncate+0x82>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  80fa13:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_trunc)(fd, newsize);
}
  80fa18:	89 d0                	mov    %edx,%eax
  80fa1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa1d:	c9                   	leave  
  80fa1e:	c3                   	ret    

0080fa1f <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80fa1f:	55                   	push   %ebp
  80fa20:	89 e5                	mov    %esp,%ebp
  80fa22:	53                   	push   %ebx
  80fa23:	83 ec 14             	sub    $0x14,%esp
  80fa26:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fa29:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fa2c:	50                   	push   %eax
  80fa2d:	ff 75 08             	pushl  0x8(%ebp)
  80fa30:	e8 6c fb ff ff       	call   80f5a1 <fd_lookup>
  80fa35:	83 c4 08             	add    $0x8,%esp
  80fa38:	89 c2                	mov    %eax,%edx
  80fa3a:	85 c0                	test   %eax,%eax
  80fa3c:	78 58                	js     80fa96 <fstat+0x77>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fa3e:	83 ec 08             	sub    $0x8,%esp
  80fa41:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fa44:	50                   	push   %eax
  80fa45:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fa48:	ff 30                	pushl  (%eax)
  80fa4a:	e8 a8 fb ff ff       	call   80f5f7 <dev_lookup>
  80fa4f:	83 c4 10             	add    $0x10,%esp
  80fa52:	85 c0                	test   %eax,%eax
  80fa54:	78 37                	js     80fa8d <fstat+0x6e>
		return r;
	if (!dev->dev_stat)
  80fa56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fa59:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80fa5d:	74 32                	je     80fa91 <fstat+0x72>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80fa5f:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80fa62:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80fa69:	00 00 00 
	stat->st_isdir = 0;
  80fa6c:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80fa73:	00 00 00 
	stat->st_dev = dev;
  80fa76:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fa7c:	83 ec 08             	sub    $0x8,%esp
  80fa7f:	53                   	push   %ebx
  80fa80:	ff 75 f0             	pushl  -0x10(%ebp)
  80fa83:	ff 50 14             	call   *0x14(%eax)
  80fa86:	89 c2                	mov    %eax,%edx
  80fa88:	83 c4 10             	add    $0x10,%esp
  80fa8b:	eb 09                	jmp    80fa96 <fstat+0x77>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fa8d:	89 c2                	mov    %eax,%edx
  80fa8f:	eb 05                	jmp    80fa96 <fstat+0x77>
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  80fa91:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  80fa96:	89 d0                	mov    %edx,%eax
  80fa98:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa9b:	c9                   	leave  
  80fa9c:	c3                   	ret    

0080fa9d <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80fa9d:	55                   	push   %ebp
  80fa9e:	89 e5                	mov    %esp,%ebp
  80faa0:	56                   	push   %esi
  80faa1:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80faa2:	83 ec 08             	sub    $0x8,%esp
  80faa5:	6a 00                	push   $0x0
  80faa7:	ff 75 08             	pushl  0x8(%ebp)
  80faaa:	e8 0c 02 00 00       	call   80fcbb <open>
  80faaf:	89 c3                	mov    %eax,%ebx
  80fab1:	83 c4 10             	add    $0x10,%esp
  80fab4:	85 c0                	test   %eax,%eax
  80fab6:	78 1b                	js     80fad3 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80fab8:	83 ec 08             	sub    $0x8,%esp
  80fabb:	ff 75 0c             	pushl  0xc(%ebp)
  80fabe:	50                   	push   %eax
  80fabf:	e8 5b ff ff ff       	call   80fa1f <fstat>
  80fac4:	89 c6                	mov    %eax,%esi
	close(fd);
  80fac6:	89 1c 24             	mov    %ebx,(%esp)
  80fac9:	e8 fd fb ff ff       	call   80f6cb <close>
	return r;
  80face:	83 c4 10             	add    $0x10,%esp
  80fad1:	89 f0                	mov    %esi,%eax
}
  80fad3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fad6:	5b                   	pop    %ebx
  80fad7:	5e                   	pop    %esi
  80fad8:	5d                   	pop    %ebp
  80fad9:	c3                   	ret    

0080fada <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80fada:	55                   	push   %ebp
  80fadb:	89 e5                	mov    %esp,%ebp
  80fadd:	56                   	push   %esi
  80fade:	53                   	push   %ebx
  80fadf:	89 c6                	mov    %eax,%esi
  80fae1:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80fae3:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80faea:	75 12                	jne    80fafe <fsipc+0x24>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80faec:	83 ec 0c             	sub    $0xc,%esp
  80faef:	6a 01                	push   $0x1
  80faf1:	e8 fc f9 ff ff       	call   80f4f2 <ipc_find_env>
  80faf6:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80fafb:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80fafe:	6a 07                	push   $0x7
  80fb00:	68 00 c0 b3 00       	push   $0xb3c000
  80fb05:	56                   	push   %esi
  80fb06:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80fb0c:	e8 8d f9 ff ff       	call   80f49e <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80fb11:	83 c4 0c             	add    $0xc,%esp
  80fb14:	6a 00                	push   $0x0
  80fb16:	53                   	push   %ebx
  80fb17:	6a 00                	push   $0x0
  80fb19:	e8 17 f9 ff ff       	call   80f435 <ipc_recv>
}
  80fb1e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fb21:	5b                   	pop    %ebx
  80fb22:	5e                   	pop    %esi
  80fb23:	5d                   	pop    %ebp
  80fb24:	c3                   	ret    

0080fb25 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80fb25:	55                   	push   %ebp
  80fb26:	89 e5                	mov    %esp,%ebp
  80fb28:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80fb2b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb2e:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb31:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80fb36:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb39:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fb3e:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb43:	b8 02 00 00 00       	mov    $0x2,%eax
  80fb48:	e8 8d ff ff ff       	call   80fada <fsipc>
}
  80fb4d:	c9                   	leave  
  80fb4e:	c3                   	ret    

0080fb4f <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80fb4f:	55                   	push   %ebp
  80fb50:	89 e5                	mov    %esp,%ebp
  80fb52:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80fb55:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb58:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb5b:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fb60:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb65:	b8 06 00 00 00       	mov    $0x6,%eax
  80fb6a:	e8 6b ff ff ff       	call   80fada <fsipc>
}
  80fb6f:	c9                   	leave  
  80fb70:	c3                   	ret    

0080fb71 <devfile_stat>:
	return r;
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  80fb71:	55                   	push   %ebp
  80fb72:	89 e5                	mov    %esp,%ebp
  80fb74:	53                   	push   %ebx
  80fb75:	83 ec 04             	sub    $0x4,%esp
  80fb78:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fb7b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb7e:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb81:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fb86:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb8b:	b8 05 00 00 00       	mov    $0x5,%eax
  80fb90:	e8 45 ff ff ff       	call   80fada <fsipc>
  80fb95:	85 c0                	test   %eax,%eax
  80fb97:	78 2c                	js     80fbc5 <devfile_stat+0x54>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fb99:	83 ec 08             	sub    $0x8,%esp
  80fb9c:	68 00 c0 b3 00       	push   $0xb3c000
  80fba1:	53                   	push   %ebx
  80fba2:	e8 01 ef ff ff       	call   80eaa8 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fba7:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fbac:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fbb2:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fbb7:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fbbd:	83 c4 10             	add    $0x10,%esp
  80fbc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fbc5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fbc8:	c9                   	leave  
  80fbc9:	c3                   	ret    

0080fbca <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80fbca:	55                   	push   %ebp
  80fbcb:	89 e5                	mov    %esp,%ebp
  80fbcd:	53                   	push   %ebx
  80fbce:	83 ec 08             	sub    $0x8,%esp
  80fbd1:	8b 45 10             	mov    0x10(%ebp),%eax
	// bytes than requested.
	// LAB 5: Your code here

	// Build up arguments of the write request
	// The file to write is stored in the request req_fileid
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fbd4:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbd7:	8b 52 0c             	mov    0xc(%edx),%edx
  80fbda:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
  80fbe0:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  80fbe5:	bb f8 0f 00 00       	mov    $0xff8,%ebx
  80fbea:	0f 46 d8             	cmovbe %eax,%ebx
	// The size is capped to the size of the request buffer
	size_t n_real = min_size(n, sizeof(fsipcbuf.write.req_buf));
	fsipcbuf.write.req_n = n_real;
  80fbed:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004
	// The data to write is stored in the request buffer
	memmove(fsipcbuf.write.req_buf, buf, n_real);
  80fbf3:	53                   	push   %ebx
  80fbf4:	ff 75 0c             	pushl  0xc(%ebp)
  80fbf7:	68 08 c0 b3 00       	push   $0xb3c008
  80fbfc:	e8 39 f0 ff ff       	call   80ec3a <memmove>

	// Send request via fsipc
	int r;
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0) // Error occurred
  80fc01:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc06:	b8 04 00 00 00       	mov    $0x4,%eax
  80fc0b:	e8 ca fe ff ff       	call   80fada <fsipc>
  80fc10:	83 c4 10             	add    $0x10,%esp
  80fc13:	85 c0                	test   %eax,%eax
  80fc15:	78 1d                	js     80fc34 <devfile_write+0x6a>
		return r;
	assert(r <= n_real); // Number of bytes written should be <= n_real
  80fc17:	39 d8                	cmp    %ebx,%eax
  80fc19:	76 19                	jbe    80fc34 <devfile_write+0x6a>
  80fc1b:	68 44 37 81 00       	push   $0x813744
  80fc20:	68 87 24 81 00       	push   $0x812487
  80fc25:	68 a5 00 00 00       	push   $0xa5
  80fc2a:	68 50 37 81 00       	push   $0x813750
  80fc2f:	e8 16 e8 ff ff       	call   80e44a <_panic>
	return r;
}
  80fc34:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fc37:	c9                   	leave  
  80fc38:	c3                   	ret    

0080fc39 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80fc39:	55                   	push   %ebp
  80fc3a:	89 e5                	mov    %esp,%ebp
  80fc3c:	56                   	push   %esi
  80fc3d:	53                   	push   %ebx
  80fc3e:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80fc41:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc44:	8b 40 0c             	mov    0xc(%eax),%eax
  80fc47:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80fc4c:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80fc52:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc57:	b8 03 00 00 00       	mov    $0x3,%eax
  80fc5c:	e8 79 fe ff ff       	call   80fada <fsipc>
  80fc61:	89 c3                	mov    %eax,%ebx
  80fc63:	85 c0                	test   %eax,%eax
  80fc65:	78 4b                	js     80fcb2 <devfile_read+0x79>
		return r;
	assert(r <= n);
  80fc67:	39 c6                	cmp    %eax,%esi
  80fc69:	73 16                	jae    80fc81 <devfile_read+0x48>
  80fc6b:	68 5b 37 81 00       	push   $0x81375b
  80fc70:	68 87 24 81 00       	push   $0x812487
  80fc75:	6a 7c                	push   $0x7c
  80fc77:	68 50 37 81 00       	push   $0x813750
  80fc7c:	e8 c9 e7 ff ff       	call   80e44a <_panic>
	assert(r <= PGSIZE);
  80fc81:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fc86:	7e 16                	jle    80fc9e <devfile_read+0x65>
  80fc88:	68 62 37 81 00       	push   $0x813762
  80fc8d:	68 87 24 81 00       	push   $0x812487
  80fc92:	6a 7d                	push   $0x7d
  80fc94:	68 50 37 81 00       	push   $0x813750
  80fc99:	e8 ac e7 ff ff       	call   80e44a <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fc9e:	83 ec 04             	sub    $0x4,%esp
  80fca1:	50                   	push   %eax
  80fca2:	68 00 c0 b3 00       	push   $0xb3c000
  80fca7:	ff 75 0c             	pushl  0xc(%ebp)
  80fcaa:	e8 8b ef ff ff       	call   80ec3a <memmove>
	return r;
  80fcaf:	83 c4 10             	add    $0x10,%esp
}
  80fcb2:	89 d8                	mov    %ebx,%eax
  80fcb4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fcb7:	5b                   	pop    %ebx
  80fcb8:	5e                   	pop    %esi
  80fcb9:	5d                   	pop    %ebp
  80fcba:	c3                   	ret    

0080fcbb <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  80fcbb:	55                   	push   %ebp
  80fcbc:	89 e5                	mov    %esp,%ebp
  80fcbe:	53                   	push   %ebx
  80fcbf:	83 ec 20             	sub    $0x20,%esp
  80fcc2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  80fcc5:	53                   	push   %ebx
  80fcc6:	e8 a4 ed ff ff       	call   80ea6f <strlen>
  80fccb:	83 c4 10             	add    $0x10,%esp
  80fcce:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fcd3:	7f 67                	jg     80fd3c <open+0x81>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fcd5:	83 ec 0c             	sub    $0xc,%esp
  80fcd8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fcdb:	50                   	push   %eax
  80fcdc:	e8 71 f8 ff ff       	call   80f552 <fd_alloc>
  80fce1:	83 c4 10             	add    $0x10,%esp
		return r;
  80fce4:	89 c2                	mov    %eax,%edx
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fce6:	85 c0                	test   %eax,%eax
  80fce8:	78 57                	js     80fd41 <open+0x86>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  80fcea:	83 ec 08             	sub    $0x8,%esp
  80fced:	53                   	push   %ebx
  80fcee:	68 00 c0 b3 00       	push   $0xb3c000
  80fcf3:	e8 b0 ed ff ff       	call   80eaa8 <strcpy>
	fsipcbuf.open.req_omode = mode;
  80fcf8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fcfb:	a3 00 c4 b3 00       	mov    %eax,0xb3c400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fd00:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fd03:	b8 01 00 00 00       	mov    $0x1,%eax
  80fd08:	e8 cd fd ff ff       	call   80fada <fsipc>
  80fd0d:	89 c3                	mov    %eax,%ebx
  80fd0f:	83 c4 10             	add    $0x10,%esp
  80fd12:	85 c0                	test   %eax,%eax
  80fd14:	79 14                	jns    80fd2a <open+0x6f>
		fd_close(fd, 0);
  80fd16:	83 ec 08             	sub    $0x8,%esp
  80fd19:	6a 00                	push   $0x0
  80fd1b:	ff 75 f4             	pushl  -0xc(%ebp)
  80fd1e:	e8 27 f9 ff ff       	call   80f64a <fd_close>
		return r;
  80fd23:	83 c4 10             	add    $0x10,%esp
  80fd26:	89 da                	mov    %ebx,%edx
  80fd28:	eb 17                	jmp    80fd41 <open+0x86>
	}

	return fd2num(fd);
  80fd2a:	83 ec 0c             	sub    $0xc,%esp
  80fd2d:	ff 75 f4             	pushl  -0xc(%ebp)
  80fd30:	e8 f6 f7 ff ff       	call   80f52b <fd2num>
  80fd35:	89 c2                	mov    %eax,%edx
  80fd37:	83 c4 10             	add    $0x10,%esp
  80fd3a:	eb 05                	jmp    80fd41 <open+0x86>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  80fd3c:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  80fd41:	89 d0                	mov    %edx,%eax
  80fd43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd46:	c9                   	leave  
  80fd47:	c3                   	ret    

0080fd48 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80fd48:	55                   	push   %ebp
  80fd49:	89 e5                	mov    %esp,%ebp
  80fd4b:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80fd4e:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd53:	b8 08 00 00 00       	mov    $0x8,%eax
  80fd58:	e8 7d fd ff ff       	call   80fada <fsipc>
}
  80fd5d:	c9                   	leave  
  80fd5e:	c3                   	ret    

0080fd5f <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80fd5f:	55                   	push   %ebp
  80fd60:	89 e5                	mov    %esp,%ebp
  80fd62:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  80fd65:	68 6e 37 81 00       	push   $0x81376e
  80fd6a:	ff 75 0c             	pushl  0xc(%ebp)
  80fd6d:	e8 36 ed ff ff       	call   80eaa8 <strcpy>
	return 0;
}
  80fd72:	b8 00 00 00 00       	mov    $0x0,%eax
  80fd77:	c9                   	leave  
  80fd78:	c3                   	ret    

0080fd79 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  80fd79:	55                   	push   %ebp
  80fd7a:	89 e5                	mov    %esp,%ebp
  80fd7c:	53                   	push   %ebx
  80fd7d:	83 ec 10             	sub    $0x10,%esp
  80fd80:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  80fd83:	53                   	push   %ebx
  80fd84:	e8 20 0c 00 00       	call   8109a9 <pageref>
  80fd89:	83 c4 10             	add    $0x10,%esp
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  80fd8c:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  80fd91:	83 f8 01             	cmp    $0x1,%eax
  80fd94:	75 10                	jne    80fda6 <devsock_close+0x2d>
		return nsipc_close(fd->fd_sock.sockid);
  80fd96:	83 ec 0c             	sub    $0xc,%esp
  80fd99:	ff 73 0c             	pushl  0xc(%ebx)
  80fd9c:	e8 c0 02 00 00       	call   810061 <nsipc_close>
  80fda1:	89 c2                	mov    %eax,%edx
  80fda3:	83 c4 10             	add    $0x10,%esp
	else
		return 0;
}
  80fda6:	89 d0                	mov    %edx,%eax
  80fda8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fdab:	c9                   	leave  
  80fdac:	c3                   	ret    

0080fdad <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80fdad:	55                   	push   %ebp
  80fdae:	89 e5                	mov    %esp,%ebp
  80fdb0:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80fdb3:	6a 00                	push   $0x0
  80fdb5:	ff 75 10             	pushl  0x10(%ebp)
  80fdb8:	ff 75 0c             	pushl  0xc(%ebp)
  80fdbb:	8b 45 08             	mov    0x8(%ebp),%eax
  80fdbe:	ff 70 0c             	pushl  0xc(%eax)
  80fdc1:	e8 78 03 00 00       	call   81013e <nsipc_send>
}
  80fdc6:	c9                   	leave  
  80fdc7:	c3                   	ret    

0080fdc8 <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80fdc8:	55                   	push   %ebp
  80fdc9:	89 e5                	mov    %esp,%ebp
  80fdcb:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80fdce:	6a 00                	push   $0x0
  80fdd0:	ff 75 10             	pushl  0x10(%ebp)
  80fdd3:	ff 75 0c             	pushl  0xc(%ebp)
  80fdd6:	8b 45 08             	mov    0x8(%ebp),%eax
  80fdd9:	ff 70 0c             	pushl  0xc(%eax)
  80fddc:	e8 f1 02 00 00       	call   8100d2 <nsipc_recv>
}
  80fde1:	c9                   	leave  
  80fde2:	c3                   	ret    

0080fde3 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80fde3:	55                   	push   %ebp
  80fde4:	89 e5                	mov    %esp,%ebp
  80fde6:	83 ec 20             	sub    $0x20,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80fde9:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80fdec:	52                   	push   %edx
  80fded:	50                   	push   %eax
  80fdee:	e8 ae f7 ff ff       	call   80f5a1 <fd_lookup>
  80fdf3:	83 c4 10             	add    $0x10,%esp
  80fdf6:	85 c0                	test   %eax,%eax
  80fdf8:	78 17                	js     80fe11 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80fdfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fdfd:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  80fe03:	39 08                	cmp    %ecx,(%eax)
  80fe05:	75 05                	jne    80fe0c <fd2sockid+0x29>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80fe07:	8b 40 0c             	mov    0xc(%eax),%eax
  80fe0a:	eb 05                	jmp    80fe11 <fd2sockid+0x2e>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  80fe0c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  80fe11:	c9                   	leave  
  80fe12:	c3                   	ret    

0080fe13 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  80fe13:	55                   	push   %ebp
  80fe14:	89 e5                	mov    %esp,%ebp
  80fe16:	56                   	push   %esi
  80fe17:	53                   	push   %ebx
  80fe18:	83 ec 1c             	sub    $0x1c,%esp
  80fe1b:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80fe1d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe20:	50                   	push   %eax
  80fe21:	e8 2c f7 ff ff       	call   80f552 <fd_alloc>
  80fe26:	89 c3                	mov    %eax,%ebx
  80fe28:	83 c4 10             	add    $0x10,%esp
  80fe2b:	85 c0                	test   %eax,%eax
  80fe2d:	78 1b                	js     80fe4a <alloc_sockfd+0x37>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80fe2f:	83 ec 04             	sub    $0x4,%esp
  80fe32:	68 07 04 00 00       	push   $0x407
  80fe37:	ff 75 f4             	pushl  -0xc(%ebp)
  80fe3a:	6a 00                	push   $0x0
  80fe3c:	e8 6a f0 ff ff       	call   80eeab <sys_page_alloc>
  80fe41:	89 c3                	mov    %eax,%ebx
  80fe43:	83 c4 10             	add    $0x10,%esp
  80fe46:	85 c0                	test   %eax,%eax
  80fe48:	79 10                	jns    80fe5a <alloc_sockfd+0x47>
		nsipc_close(sockid);
  80fe4a:	83 ec 0c             	sub    $0xc,%esp
  80fe4d:	56                   	push   %esi
  80fe4e:	e8 0e 02 00 00       	call   810061 <nsipc_close>
		return r;
  80fe53:	83 c4 10             	add    $0x10,%esp
  80fe56:	89 d8                	mov    %ebx,%eax
  80fe58:	eb 24                	jmp    80fe7e <alloc_sockfd+0x6b>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80fe5a:	8b 15 08 43 81 00    	mov    0x814308,%edx
  80fe60:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe63:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80fe65:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe68:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  80fe6f:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80fe72:	83 ec 0c             	sub    $0xc,%esp
  80fe75:	50                   	push   %eax
  80fe76:	e8 b0 f6 ff ff       	call   80f52b <fd2num>
  80fe7b:	83 c4 10             	add    $0x10,%esp
}
  80fe7e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fe81:	5b                   	pop    %ebx
  80fe82:	5e                   	pop    %esi
  80fe83:	5d                   	pop    %ebp
  80fe84:	c3                   	ret    

0080fe85 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fe85:	55                   	push   %ebp
  80fe86:	89 e5                	mov    %esp,%ebp
  80fe88:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe8b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe8e:	e8 50 ff ff ff       	call   80fde3 <fd2sockid>
		return r;
  80fe93:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe95:	85 c0                	test   %eax,%eax
  80fe97:	78 1f                	js     80feb8 <accept+0x33>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fe99:	83 ec 04             	sub    $0x4,%esp
  80fe9c:	ff 75 10             	pushl  0x10(%ebp)
  80fe9f:	ff 75 0c             	pushl  0xc(%ebp)
  80fea2:	50                   	push   %eax
  80fea3:	e8 12 01 00 00       	call   80ffba <nsipc_accept>
  80fea8:	83 c4 10             	add    $0x10,%esp
		return r;
  80feab:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fead:	85 c0                	test   %eax,%eax
  80feaf:	78 07                	js     80feb8 <accept+0x33>
		return r;
	return alloc_sockfd(r);
  80feb1:	e8 5d ff ff ff       	call   80fe13 <alloc_sockfd>
  80feb6:	89 c1                	mov    %eax,%ecx
}
  80feb8:	89 c8                	mov    %ecx,%eax
  80feba:	c9                   	leave  
  80febb:	c3                   	ret    

0080febc <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80febc:	55                   	push   %ebp
  80febd:	89 e5                	mov    %esp,%ebp
  80febf:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fec2:	8b 45 08             	mov    0x8(%ebp),%eax
  80fec5:	e8 19 ff ff ff       	call   80fde3 <fd2sockid>
  80feca:	85 c0                	test   %eax,%eax
  80fecc:	78 12                	js     80fee0 <bind+0x24>
		return r;
	return nsipc_bind(r, name, namelen);
  80fece:	83 ec 04             	sub    $0x4,%esp
  80fed1:	ff 75 10             	pushl  0x10(%ebp)
  80fed4:	ff 75 0c             	pushl  0xc(%ebp)
  80fed7:	50                   	push   %eax
  80fed8:	e8 2d 01 00 00       	call   81000a <nsipc_bind>
  80fedd:	83 c4 10             	add    $0x10,%esp
}
  80fee0:	c9                   	leave  
  80fee1:	c3                   	ret    

0080fee2 <shutdown>:

int
shutdown(int s, int how)
{
  80fee2:	55                   	push   %ebp
  80fee3:	89 e5                	mov    %esp,%ebp
  80fee5:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fee8:	8b 45 08             	mov    0x8(%ebp),%eax
  80feeb:	e8 f3 fe ff ff       	call   80fde3 <fd2sockid>
  80fef0:	85 c0                	test   %eax,%eax
  80fef2:	78 0f                	js     80ff03 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  80fef4:	83 ec 08             	sub    $0x8,%esp
  80fef7:	ff 75 0c             	pushl  0xc(%ebp)
  80fefa:	50                   	push   %eax
  80fefb:	e8 3f 01 00 00       	call   81003f <nsipc_shutdown>
  80ff00:	83 c4 10             	add    $0x10,%esp
}
  80ff03:	c9                   	leave  
  80ff04:	c3                   	ret    

0080ff05 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80ff05:	55                   	push   %ebp
  80ff06:	89 e5                	mov    %esp,%ebp
  80ff08:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80ff0b:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff0e:	e8 d0 fe ff ff       	call   80fde3 <fd2sockid>
  80ff13:	85 c0                	test   %eax,%eax
  80ff15:	78 12                	js     80ff29 <connect+0x24>
		return r;
	return nsipc_connect(r, name, namelen);
  80ff17:	83 ec 04             	sub    $0x4,%esp
  80ff1a:	ff 75 10             	pushl  0x10(%ebp)
  80ff1d:	ff 75 0c             	pushl  0xc(%ebp)
  80ff20:	50                   	push   %eax
  80ff21:	e8 55 01 00 00       	call   81007b <nsipc_connect>
  80ff26:	83 c4 10             	add    $0x10,%esp
}
  80ff29:	c9                   	leave  
  80ff2a:	c3                   	ret    

0080ff2b <listen>:

int
listen(int s, int backlog)
{
  80ff2b:	55                   	push   %ebp
  80ff2c:	89 e5                	mov    %esp,%ebp
  80ff2e:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80ff31:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff34:	e8 aa fe ff ff       	call   80fde3 <fd2sockid>
  80ff39:	85 c0                	test   %eax,%eax
  80ff3b:	78 0f                	js     80ff4c <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  80ff3d:	83 ec 08             	sub    $0x8,%esp
  80ff40:	ff 75 0c             	pushl  0xc(%ebp)
  80ff43:	50                   	push   %eax
  80ff44:	e8 67 01 00 00       	call   8100b0 <nsipc_listen>
  80ff49:	83 c4 10             	add    $0x10,%esp
}
  80ff4c:	c9                   	leave  
  80ff4d:	c3                   	ret    

0080ff4e <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  80ff4e:	55                   	push   %ebp
  80ff4f:	89 e5                	mov    %esp,%ebp
  80ff51:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80ff54:	ff 75 10             	pushl  0x10(%ebp)
  80ff57:	ff 75 0c             	pushl  0xc(%ebp)
  80ff5a:	ff 75 08             	pushl  0x8(%ebp)
  80ff5d:	e8 3a 02 00 00       	call   81019c <nsipc_socket>
  80ff62:	83 c4 10             	add    $0x10,%esp
  80ff65:	85 c0                	test   %eax,%eax
  80ff67:	78 05                	js     80ff6e <socket+0x20>
		return r;
	return alloc_sockfd(r);
  80ff69:	e8 a5 fe ff ff       	call   80fe13 <alloc_sockfd>
}
  80ff6e:	c9                   	leave  
  80ff6f:	c3                   	ret    

0080ff70 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80ff70:	55                   	push   %ebp
  80ff71:	89 e5                	mov    %esp,%ebp
  80ff73:	53                   	push   %ebx
  80ff74:	83 ec 04             	sub    $0x4,%esp
  80ff77:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  80ff79:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  80ff80:	75 12                	jne    80ff94 <nsipc+0x24>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80ff82:	83 ec 0c             	sub    $0xc,%esp
  80ff85:	6a 02                	push   $0x2
  80ff87:	e8 66 f5 ff ff       	call   80f4f2 <ipc_find_env>
  80ff8c:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  80ff91:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80ff94:	6a 07                	push   $0x7
  80ff96:	68 00 d0 b3 00       	push   $0xb3d000
  80ff9b:	53                   	push   %ebx
  80ff9c:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  80ffa2:	e8 f7 f4 ff ff       	call   80f49e <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  80ffa7:	83 c4 0c             	add    $0xc,%esp
  80ffaa:	6a 00                	push   $0x0
  80ffac:	6a 00                	push   $0x0
  80ffae:	6a 00                	push   $0x0
  80ffb0:	e8 80 f4 ff ff       	call   80f435 <ipc_recv>
}
  80ffb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ffb8:	c9                   	leave  
  80ffb9:	c3                   	ret    

0080ffba <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80ffba:	55                   	push   %ebp
  80ffbb:	89 e5                	mov    %esp,%ebp
  80ffbd:	56                   	push   %esi
  80ffbe:	53                   	push   %ebx
  80ffbf:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  80ffc2:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffc5:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  80ffca:	8b 06                	mov    (%esi),%eax
  80ffcc:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80ffd1:	b8 01 00 00 00       	mov    $0x1,%eax
  80ffd6:	e8 95 ff ff ff       	call   80ff70 <nsipc>
  80ffdb:	89 c3                	mov    %eax,%ebx
  80ffdd:	85 c0                	test   %eax,%eax
  80ffdf:	78 20                	js     810001 <nsipc_accept+0x47>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80ffe1:	83 ec 04             	sub    $0x4,%esp
  80ffe4:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  80ffea:	68 00 d0 b3 00       	push   $0xb3d000
  80ffef:	ff 75 0c             	pushl  0xc(%ebp)
  80fff2:	e8 43 ec ff ff       	call   80ec3a <memmove>
		*addrlen = ret->ret_addrlen;
  80fff7:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  80fffc:	89 06                	mov    %eax,(%esi)
  80fffe:	83 c4 10             	add    $0x10,%esp
	}
	return r;
}
  810001:	89 d8                	mov    %ebx,%eax
  810003:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810006:	5b                   	pop    %ebx
  810007:	5e                   	pop    %esi
  810008:	5d                   	pop    %ebp
  810009:	c3                   	ret    

0081000a <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  81000a:	55                   	push   %ebp
  81000b:	89 e5                	mov    %esp,%ebp
  81000d:	53                   	push   %ebx
  81000e:	83 ec 08             	sub    $0x8,%esp
  810011:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810014:	8b 45 08             	mov    0x8(%ebp),%eax
  810017:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  81001c:	53                   	push   %ebx
  81001d:	ff 75 0c             	pushl  0xc(%ebp)
  810020:	68 04 d0 b3 00       	push   $0xb3d004
  810025:	e8 10 ec ff ff       	call   80ec3a <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  81002a:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  810030:	b8 02 00 00 00       	mov    $0x2,%eax
  810035:	e8 36 ff ff ff       	call   80ff70 <nsipc>
}
  81003a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81003d:	c9                   	leave  
  81003e:	c3                   	ret    

0081003f <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  81003f:	55                   	push   %ebp
  810040:	89 e5                	mov    %esp,%ebp
  810042:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810045:	8b 45 08             	mov    0x8(%ebp),%eax
  810048:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  81004d:	8b 45 0c             	mov    0xc(%ebp),%eax
  810050:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  810055:	b8 03 00 00 00       	mov    $0x3,%eax
  81005a:	e8 11 ff ff ff       	call   80ff70 <nsipc>
}
  81005f:	c9                   	leave  
  810060:	c3                   	ret    

00810061 <nsipc_close>:

int
nsipc_close(int s)
{
  810061:	55                   	push   %ebp
  810062:	89 e5                	mov    %esp,%ebp
  810064:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810067:	8b 45 08             	mov    0x8(%ebp),%eax
  81006a:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  81006f:	b8 04 00 00 00       	mov    $0x4,%eax
  810074:	e8 f7 fe ff ff       	call   80ff70 <nsipc>
}
  810079:	c9                   	leave  
  81007a:	c3                   	ret    

0081007b <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  81007b:	55                   	push   %ebp
  81007c:	89 e5                	mov    %esp,%ebp
  81007e:	53                   	push   %ebx
  81007f:	83 ec 08             	sub    $0x8,%esp
  810082:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810085:	8b 45 08             	mov    0x8(%ebp),%eax
  810088:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  81008d:	53                   	push   %ebx
  81008e:	ff 75 0c             	pushl  0xc(%ebp)
  810091:	68 04 d0 b3 00       	push   $0xb3d004
  810096:	e8 9f eb ff ff       	call   80ec3a <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  81009b:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  8100a1:	b8 05 00 00 00       	mov    $0x5,%eax
  8100a6:	e8 c5 fe ff ff       	call   80ff70 <nsipc>
}
  8100ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8100ae:	c9                   	leave  
  8100af:	c3                   	ret    

008100b0 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  8100b0:	55                   	push   %ebp
  8100b1:	89 e5                	mov    %esp,%ebp
  8100b3:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8100b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8100b9:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  8100be:	8b 45 0c             	mov    0xc(%ebp),%eax
  8100c1:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  8100c6:	b8 06 00 00 00       	mov    $0x6,%eax
  8100cb:	e8 a0 fe ff ff       	call   80ff70 <nsipc>
}
  8100d0:	c9                   	leave  
  8100d1:	c3                   	ret    

008100d2 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8100d2:	55                   	push   %ebp
  8100d3:	89 e5                	mov    %esp,%ebp
  8100d5:	56                   	push   %esi
  8100d6:	53                   	push   %ebx
  8100d7:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8100da:	8b 45 08             	mov    0x8(%ebp),%eax
  8100dd:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  8100e2:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  8100e8:	8b 45 14             	mov    0x14(%ebp),%eax
  8100eb:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8100f0:	b8 07 00 00 00       	mov    $0x7,%eax
  8100f5:	e8 76 fe ff ff       	call   80ff70 <nsipc>
  8100fa:	89 c3                	mov    %eax,%ebx
  8100fc:	85 c0                	test   %eax,%eax
  8100fe:	78 35                	js     810135 <nsipc_recv+0x63>
		assert(r < 1600 && r <= len);
  810100:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  810105:	7f 04                	jg     81010b <nsipc_recv+0x39>
  810107:	39 c6                	cmp    %eax,%esi
  810109:	7d 16                	jge    810121 <nsipc_recv+0x4f>
  81010b:	68 7a 37 81 00       	push   $0x81377a
  810110:	68 87 24 81 00       	push   $0x812487
  810115:	6a 62                	push   $0x62
  810117:	68 8f 37 81 00       	push   $0x81378f
  81011c:	e8 29 e3 ff ff       	call   80e44a <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810121:	83 ec 04             	sub    $0x4,%esp
  810124:	50                   	push   %eax
  810125:	68 00 d0 b3 00       	push   $0xb3d000
  81012a:	ff 75 0c             	pushl  0xc(%ebp)
  81012d:	e8 08 eb ff ff       	call   80ec3a <memmove>
  810132:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  810135:	89 d8                	mov    %ebx,%eax
  810137:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81013a:	5b                   	pop    %ebx
  81013b:	5e                   	pop    %esi
  81013c:	5d                   	pop    %ebp
  81013d:	c3                   	ret    

0081013e <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  81013e:	55                   	push   %ebp
  81013f:	89 e5                	mov    %esp,%ebp
  810141:	53                   	push   %ebx
  810142:	83 ec 04             	sub    $0x4,%esp
  810145:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  810148:	8b 45 08             	mov    0x8(%ebp),%eax
  81014b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  810150:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  810156:	7e 16                	jle    81016e <nsipc_send+0x30>
  810158:	68 9b 37 81 00       	push   $0x81379b
  81015d:	68 87 24 81 00       	push   $0x812487
  810162:	6a 6d                	push   $0x6d
  810164:	68 8f 37 81 00       	push   $0x81378f
  810169:	e8 dc e2 ff ff       	call   80e44a <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  81016e:	83 ec 04             	sub    $0x4,%esp
  810171:	53                   	push   %ebx
  810172:	ff 75 0c             	pushl  0xc(%ebp)
  810175:	68 0c d0 b3 00       	push   $0xb3d00c
  81017a:	e8 bb ea ff ff       	call   80ec3a <memmove>
	nsipcbuf.send.req_size = size;
  81017f:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  810185:	8b 45 14             	mov    0x14(%ebp),%eax
  810188:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  81018d:	b8 08 00 00 00       	mov    $0x8,%eax
  810192:	e8 d9 fd ff ff       	call   80ff70 <nsipc>
}
  810197:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81019a:	c9                   	leave  
  81019b:	c3                   	ret    

0081019c <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  81019c:	55                   	push   %ebp
  81019d:	89 e5                	mov    %esp,%ebp
  81019f:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8101a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8101a5:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  8101aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8101ad:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  8101b2:	8b 45 10             	mov    0x10(%ebp),%eax
  8101b5:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  8101ba:	b8 09 00 00 00       	mov    $0x9,%eax
  8101bf:	e8 ac fd ff ff       	call   80ff70 <nsipc>
}
  8101c4:	c9                   	leave  
  8101c5:	c3                   	ret    

008101c6 <free>:
	return v;
}

void
free(void *v)
{
  8101c6:	55                   	push   %ebp
  8101c7:	89 e5                	mov    %esp,%ebp
  8101c9:	53                   	push   %ebx
  8101ca:	83 ec 04             	sub    $0x4,%esp
  8101cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8101d0:	85 db                	test   %ebx,%ebx
  8101d2:	0f 84 97 00 00 00    	je     81026f <free+0xa9>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8101d8:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8101de:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8101e3:	76 16                	jbe    8101fb <free+0x35>
  8101e5:	68 a8 37 81 00       	push   $0x8137a8
  8101ea:	68 87 24 81 00       	push   $0x812487
  8101ef:	6a 7a                	push   $0x7a
  8101f1:	68 d8 37 81 00       	push   $0x8137d8
  8101f6:	e8 4f e2 ff ff       	call   80e44a <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  8101fb:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810201:	eb 3a                	jmp    81023d <free+0x77>
		sys_page_unmap(0, c);
  810203:	83 ec 08             	sub    $0x8,%esp
  810206:	53                   	push   %ebx
  810207:	6a 00                	push   $0x0
  810209:	e8 22 ed ff ff       	call   80ef30 <sys_page_unmap>
		c += PGSIZE;
  81020e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810214:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  81021a:	83 c4 10             	add    $0x10,%esp
  81021d:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810222:	76 19                	jbe    81023d <free+0x77>
  810224:	68 e5 37 81 00       	push   $0x8137e5
  810229:	68 87 24 81 00       	push   $0x812487
  81022e:	68 81 00 00 00       	push   $0x81
  810233:	68 d8 37 81 00       	push   $0x8137d8
  810238:	e8 0d e2 ff ff       	call   80e44a <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  81023d:	89 d8                	mov    %ebx,%eax
  81023f:	c1 e8 0c             	shr    $0xc,%eax
  810242:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810249:	f6 c4 02             	test   $0x2,%ah
  81024c:	75 b5                	jne    810203 <free+0x3d>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  81024e:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810254:	83 e8 01             	sub    $0x1,%eax
  810257:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  81025d:	85 c0                	test   %eax,%eax
  81025f:	75 0e                	jne    81026f <free+0xa9>
		sys_page_unmap(0, c);
  810261:	83 ec 08             	sub    $0x8,%esp
  810264:	53                   	push   %ebx
  810265:	6a 00                	push   $0x0
  810267:	e8 c4 ec ff ff       	call   80ef30 <sys_page_unmap>
  81026c:	83 c4 10             	add    $0x10,%esp
}
  81026f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810272:	c9                   	leave  
  810273:	c3                   	ret    

00810274 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  810274:	55                   	push   %ebp
  810275:	89 e5                	mov    %esp,%ebp
  810277:	57                   	push   %edi
  810278:	56                   	push   %esi
  810279:	53                   	push   %ebx
  81027a:	83 ec 1c             	sub    $0x1c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  81027d:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810282:	85 c0                	test   %eax,%eax
  810284:	75 22                	jne    8102a8 <malloc+0x34>
		mptr = mbegin;
  810286:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  81028d:	00 00 08 

	n = ROUNDUP(n, 4);
  810290:	8b 45 08             	mov    0x8(%ebp),%eax
  810293:	83 c0 03             	add    $0x3,%eax
  810296:	83 e0 fc             	and    $0xfffffffc,%eax
  810299:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if (n >= MAXMALLOC)
  81029c:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8102a1:	76 74                	jbe    810317 <malloc+0xa3>
  8102a3:	e9 7a 01 00 00       	jmp    810422 <malloc+0x1ae>
	void *v;

	if (mptr == 0)
		mptr = mbegin;

	n = ROUNDUP(n, 4);
  8102a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8102ab:	8d 53 03             	lea    0x3(%ebx),%edx
  8102ae:	83 e2 fc             	and    $0xfffffffc,%edx
  8102b1:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (n >= MAXMALLOC)
  8102b4:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8102ba:	0f 87 69 01 00 00    	ja     810429 <malloc+0x1b5>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  8102c0:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8102c5:	74 50                	je     810317 <malloc+0xa3>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8102c7:	89 c1                	mov    %eax,%ecx
  8102c9:	c1 e9 0c             	shr    $0xc,%ecx
  8102cc:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  8102d0:	c1 ea 0c             	shr    $0xc,%edx
  8102d3:	39 d1                	cmp    %edx,%ecx
  8102d5:	75 20                	jne    8102f7 <malloc+0x83>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8102d7:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  8102dd:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  8102e3:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  8102e7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8102ea:	01 c2                	add    %eax,%edx
  8102ec:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  8102f2:	e9 55 01 00 00       	jmp    81044c <malloc+0x1d8>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  8102f7:	83 ec 0c             	sub    $0xc,%esp
  8102fa:	50                   	push   %eax
  8102fb:	e8 c6 fe ff ff       	call   8101c6 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810300:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810305:	05 00 10 00 00       	add    $0x1000,%eax
  81030a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  81030f:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  810314:	83 c4 10             	add    $0x10,%esp
  810317:	8b 35 d4 b1 b3 00    	mov    0xb3b1d4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  81031d:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810324:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  810328:	8b 45 dc             	mov    -0x24(%ebp),%eax
  81032b:	8d 78 04             	lea    0x4(%eax),%edi
  81032e:	89 75 e0             	mov    %esi,-0x20(%ebp)
  810331:	89 fb                	mov    %edi,%ebx
  810333:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810336:	89 f0                	mov    %esi,%eax
  810338:	eb 36                	jmp    810370 <malloc+0xfc>
		if (va >= (uintptr_t) mend
  81033a:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  81033f:	0f 87 eb 00 00 00    	ja     810430 <malloc+0x1bc>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810345:	89 c2                	mov    %eax,%edx
  810347:	c1 ea 16             	shr    $0x16,%edx
  81034a:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810351:	f6 c2 01             	test   $0x1,%dl
  810354:	74 15                	je     81036b <malloc+0xf7>
  810356:	89 c2                	mov    %eax,%edx
  810358:	c1 ea 0c             	shr    $0xc,%edx
  81035b:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810362:	f6 c2 01             	test   $0x1,%dl
  810365:	0f 85 c5 00 00 00    	jne    810430 <malloc+0x1bc>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81036b:	05 00 10 00 00       	add    $0x1000,%eax
  810370:	39 c8                	cmp    %ecx,%eax
  810372:	72 c6                	jb     81033a <malloc+0xc6>
  810374:	eb 79                	jmp    8103ef <malloc+0x17b>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  810376:	be 00 00 00 08       	mov    $0x8000000,%esi
  81037b:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
			if (++nwrap == 2)
  81037f:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  810383:	75 a9                	jne    81032e <malloc+0xba>
  810385:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  81038c:	00 00 08 
				return 0;	/* out of address space */
  81038f:	b8 00 00 00 00       	mov    $0x0,%eax
  810394:	e9 b3 00 00 00       	jmp    81044c <malloc+0x1d8>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810399:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  81039f:	39 df                	cmp    %ebx,%edi
  8103a1:	19 c0                	sbb    %eax,%eax
  8103a3:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8103a8:	83 ec 04             	sub    $0x4,%esp
  8103ab:	83 c8 07             	or     $0x7,%eax
  8103ae:	50                   	push   %eax
  8103af:	03 15 d4 b1 b3 00    	add    0xb3b1d4,%edx
  8103b5:	52                   	push   %edx
  8103b6:	6a 00                	push   $0x0
  8103b8:	e8 ee ea ff ff       	call   80eeab <sys_page_alloc>
  8103bd:	83 c4 10             	add    $0x10,%esp
  8103c0:	85 c0                	test   %eax,%eax
  8103c2:	78 20                	js     8103e4 <malloc+0x170>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8103c4:	89 fe                	mov    %edi,%esi
  8103c6:	eb 3a                	jmp    810402 <malloc+0x18e>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  8103c8:	83 ec 08             	sub    $0x8,%esp
  8103cb:	89 f0                	mov    %esi,%eax
  8103cd:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  8103d3:	50                   	push   %eax
  8103d4:	6a 00                	push   $0x0
  8103d6:	e8 55 eb ff ff       	call   80ef30 <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8103db:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  8103e1:	83 c4 10             	add    $0x10,%esp
  8103e4:	85 f6                	test   %esi,%esi
  8103e6:	79 e0                	jns    8103c8 <malloc+0x154>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  8103e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8103ed:	eb 5d                	jmp    81044c <malloc+0x1d8>
  8103ef:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8103f3:	74 08                	je     8103fd <malloc+0x189>
  8103f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8103f8:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8103fd:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  810402:	89 f2                	mov    %esi,%edx
  810404:	39 f3                	cmp    %esi,%ebx
  810406:	77 91                	ja     810399 <malloc+0x125>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  810408:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  81040d:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  810414:	00 
	v = mptr;
	mptr += n;
  810415:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810418:	01 c2                	add    %eax,%edx
  81041a:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
	return v;
  810420:	eb 2a                	jmp    81044c <malloc+0x1d8>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  810422:	b8 00 00 00 00       	mov    $0x0,%eax
  810427:	eb 23                	jmp    81044c <malloc+0x1d8>
  810429:	b8 00 00 00 00       	mov    $0x0,%eax
  81042e:	eb 1c                	jmp    81044c <malloc+0x1d8>
  810430:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  810436:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  81043a:	89 c6                	mov    %eax,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  81043c:	3d 00 00 00 10       	cmp    $0x10000000,%eax
  810441:	0f 85 e7 fe ff ff    	jne    81032e <malloc+0xba>
  810447:	e9 2a ff ff ff       	jmp    810376 <malloc+0x102>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  81044c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81044f:	5b                   	pop    %ebx
  810450:	5e                   	pop    %esi
  810451:	5f                   	pop    %edi
  810452:	5d                   	pop    %ebp
  810453:	c3                   	ret    

00810454 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810454:	55                   	push   %ebp
  810455:	89 e5                	mov    %esp,%ebp
  810457:	56                   	push   %esi
  810458:	53                   	push   %ebx
  810459:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  81045c:	83 ec 0c             	sub    $0xc,%esp
  81045f:	ff 75 08             	pushl  0x8(%ebp)
  810462:	e8 d4 f0 ff ff       	call   80f53b <fd2data>
  810467:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810469:	83 c4 08             	add    $0x8,%esp
  81046c:	68 fd 37 81 00       	push   $0x8137fd
  810471:	53                   	push   %ebx
  810472:	e8 31 e6 ff ff       	call   80eaa8 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810477:	8b 46 04             	mov    0x4(%esi),%eax
  81047a:	2b 06                	sub    (%esi),%eax
  81047c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810482:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810489:	00 00 00 
	stat->st_dev = &devpipe;
  81048c:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  810493:	43 81 00 
	return 0;
}
  810496:	b8 00 00 00 00       	mov    $0x0,%eax
  81049b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81049e:	5b                   	pop    %ebx
  81049f:	5e                   	pop    %esi
  8104a0:	5d                   	pop    %ebp
  8104a1:	c3                   	ret    

008104a2 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  8104a2:	55                   	push   %ebp
  8104a3:	89 e5                	mov    %esp,%ebp
  8104a5:	53                   	push   %ebx
  8104a6:	83 ec 0c             	sub    $0xc,%esp
  8104a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  8104ac:	53                   	push   %ebx
  8104ad:	6a 00                	push   $0x0
  8104af:	e8 7c ea ff ff       	call   80ef30 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  8104b4:	89 1c 24             	mov    %ebx,(%esp)
  8104b7:	e8 7f f0 ff ff       	call   80f53b <fd2data>
  8104bc:	83 c4 08             	add    $0x8,%esp
  8104bf:	50                   	push   %eax
  8104c0:	6a 00                	push   $0x0
  8104c2:	e8 69 ea ff ff       	call   80ef30 <sys_page_unmap>
}
  8104c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8104ca:	c9                   	leave  
  8104cb:	c3                   	ret    

008104cc <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  8104cc:	55                   	push   %ebp
  8104cd:	89 e5                	mov    %esp,%ebp
  8104cf:	57                   	push   %edi
  8104d0:	56                   	push   %esi
  8104d1:	53                   	push   %ebx
  8104d2:	83 ec 1c             	sub    $0x1c,%esp
  8104d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8104d8:	89 d7                	mov    %edx,%edi
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  8104da:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  8104df:	8b 70 58             	mov    0x58(%eax),%esi
		ret = pageref(fd) == pageref(p);
  8104e2:	83 ec 0c             	sub    $0xc,%esp
  8104e5:	ff 75 e0             	pushl  -0x20(%ebp)
  8104e8:	e8 bc 04 00 00       	call   8109a9 <pageref>
  8104ed:	89 c3                	mov    %eax,%ebx
  8104ef:	89 3c 24             	mov    %edi,(%esp)
  8104f2:	e8 b2 04 00 00       	call   8109a9 <pageref>
  8104f7:	83 c4 10             	add    $0x10,%esp
  8104fa:	39 c3                	cmp    %eax,%ebx
  8104fc:	0f 94 c1             	sete   %cl
  8104ff:	0f b6 c9             	movzbl %cl,%ecx
  810502:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		nn = thisenv->env_runs;
  810505:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  81050b:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  81050e:	39 ce                	cmp    %ecx,%esi
  810510:	74 1b                	je     81052d <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  810512:	39 c3                	cmp    %eax,%ebx
  810514:	75 c4                	jne    8104da <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810516:	8b 42 58             	mov    0x58(%edx),%eax
  810519:	ff 75 e4             	pushl  -0x1c(%ebp)
  81051c:	50                   	push   %eax
  81051d:	56                   	push   %esi
  81051e:	68 04 38 81 00       	push   $0x813804
  810523:	e8 fb df ff ff       	call   80e523 <cprintf>
  810528:	83 c4 10             	add    $0x10,%esp
  81052b:	eb ad                	jmp    8104da <_pipeisclosed+0xe>
	}
}
  81052d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810530:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810533:	5b                   	pop    %ebx
  810534:	5e                   	pop    %esi
  810535:	5f                   	pop    %edi
  810536:	5d                   	pop    %ebp
  810537:	c3                   	ret    

00810538 <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  810538:	55                   	push   %ebp
  810539:	89 e5                	mov    %esp,%ebp
  81053b:	57                   	push   %edi
  81053c:	56                   	push   %esi
  81053d:	53                   	push   %ebx
  81053e:	83 ec 28             	sub    $0x28,%esp
  810541:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  810544:	56                   	push   %esi
  810545:	e8 f1 ef ff ff       	call   80f53b <fd2data>
  81054a:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81054c:	83 c4 10             	add    $0x10,%esp
  81054f:	bf 00 00 00 00       	mov    $0x0,%edi
  810554:	eb 4b                	jmp    8105a1 <devpipe_write+0x69>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  810556:	89 da                	mov    %ebx,%edx
  810558:	89 f0                	mov    %esi,%eax
  81055a:	e8 6d ff ff ff       	call   8104cc <_pipeisclosed>
  81055f:	85 c0                	test   %eax,%eax
  810561:	75 48                	jne    8105ab <devpipe_write+0x73>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  810563:	e8 24 e9 ff ff       	call   80ee8c <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810568:	8b 43 04             	mov    0x4(%ebx),%eax
  81056b:	8b 0b                	mov    (%ebx),%ecx
  81056d:	8d 51 20             	lea    0x20(%ecx),%edx
  810570:	39 d0                	cmp    %edx,%eax
  810572:	73 e2                	jae    810556 <devpipe_write+0x1e>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810574:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810577:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  81057b:	88 4d e7             	mov    %cl,-0x19(%ebp)
  81057e:	89 c2                	mov    %eax,%edx
  810580:	c1 fa 1f             	sar    $0x1f,%edx
  810583:	89 d1                	mov    %edx,%ecx
  810585:	c1 e9 1b             	shr    $0x1b,%ecx
  810588:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  81058b:	83 e2 1f             	and    $0x1f,%edx
  81058e:	29 ca                	sub    %ecx,%edx
  810590:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810594:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810598:	83 c0 01             	add    $0x1,%eax
  81059b:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81059e:	83 c7 01             	add    $0x1,%edi
  8105a1:	3b 7d 10             	cmp    0x10(%ebp),%edi
  8105a4:	75 c2                	jne    810568 <devpipe_write+0x30>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8105a6:	8b 45 10             	mov    0x10(%ebp),%eax
  8105a9:	eb 05                	jmp    8105b0 <devpipe_write+0x78>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  8105ab:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  8105b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8105b3:	5b                   	pop    %ebx
  8105b4:	5e                   	pop    %esi
  8105b5:	5f                   	pop    %edi
  8105b6:	5d                   	pop    %ebp
  8105b7:	c3                   	ret    

008105b8 <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  8105b8:	55                   	push   %ebp
  8105b9:	89 e5                	mov    %esp,%ebp
  8105bb:	57                   	push   %edi
  8105bc:	56                   	push   %esi
  8105bd:	53                   	push   %ebx
  8105be:	83 ec 18             	sub    $0x18,%esp
  8105c1:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  8105c4:	57                   	push   %edi
  8105c5:	e8 71 ef ff ff       	call   80f53b <fd2data>
  8105ca:	89 c6                	mov    %eax,%esi
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8105cc:	83 c4 10             	add    $0x10,%esp
  8105cf:	bb 00 00 00 00       	mov    $0x0,%ebx
  8105d4:	eb 3d                	jmp    810613 <devpipe_read+0x5b>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  8105d6:	85 db                	test   %ebx,%ebx
  8105d8:	74 04                	je     8105de <devpipe_read+0x26>
				return i;
  8105da:	89 d8                	mov    %ebx,%eax
  8105dc:	eb 44                	jmp    810622 <devpipe_read+0x6a>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  8105de:	89 f2                	mov    %esi,%edx
  8105e0:	89 f8                	mov    %edi,%eax
  8105e2:	e8 e5 fe ff ff       	call   8104cc <_pipeisclosed>
  8105e7:	85 c0                	test   %eax,%eax
  8105e9:	75 32                	jne    81061d <devpipe_read+0x65>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  8105eb:	e8 9c e8 ff ff       	call   80ee8c <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  8105f0:	8b 06                	mov    (%esi),%eax
  8105f2:	3b 46 04             	cmp    0x4(%esi),%eax
  8105f5:	74 df                	je     8105d6 <devpipe_read+0x1e>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8105f7:	99                   	cltd   
  8105f8:	c1 ea 1b             	shr    $0x1b,%edx
  8105fb:	01 d0                	add    %edx,%eax
  8105fd:	83 e0 1f             	and    $0x1f,%eax
  810600:	29 d0                	sub    %edx,%eax
  810602:	0f b6 44 06 08       	movzbl 0x8(%esi,%eax,1),%eax
  810607:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81060a:	88 04 19             	mov    %al,(%ecx,%ebx,1)
		p->p_rpos++;
  81060d:	83 06 01             	addl   $0x1,(%esi)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810610:	83 c3 01             	add    $0x1,%ebx
  810613:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  810616:	75 d8                	jne    8105f0 <devpipe_read+0x38>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  810618:	8b 45 10             	mov    0x10(%ebp),%eax
  81061b:	eb 05                	jmp    810622 <devpipe_read+0x6a>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81061d:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  810622:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810625:	5b                   	pop    %ebx
  810626:	5e                   	pop    %esi
  810627:	5f                   	pop    %edi
  810628:	5d                   	pop    %ebp
  810629:	c3                   	ret    

0081062a <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  81062a:	55                   	push   %ebp
  81062b:	89 e5                	mov    %esp,%ebp
  81062d:	56                   	push   %esi
  81062e:	53                   	push   %ebx
  81062f:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  810632:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810635:	50                   	push   %eax
  810636:	e8 17 ef ff ff       	call   80f552 <fd_alloc>
  81063b:	83 c4 10             	add    $0x10,%esp
  81063e:	89 c2                	mov    %eax,%edx
  810640:	85 c0                	test   %eax,%eax
  810642:	0f 88 2c 01 00 00    	js     810774 <pipe+0x14a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810648:	83 ec 04             	sub    $0x4,%esp
  81064b:	68 07 04 00 00       	push   $0x407
  810650:	ff 75 f4             	pushl  -0xc(%ebp)
  810653:	6a 00                	push   $0x0
  810655:	e8 51 e8 ff ff       	call   80eeab <sys_page_alloc>
  81065a:	83 c4 10             	add    $0x10,%esp
  81065d:	89 c2                	mov    %eax,%edx
  81065f:	85 c0                	test   %eax,%eax
  810661:	0f 88 0d 01 00 00    	js     810774 <pipe+0x14a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  810667:	83 ec 0c             	sub    $0xc,%esp
  81066a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  81066d:	50                   	push   %eax
  81066e:	e8 df ee ff ff       	call   80f552 <fd_alloc>
  810673:	89 c3                	mov    %eax,%ebx
  810675:	83 c4 10             	add    $0x10,%esp
  810678:	85 c0                	test   %eax,%eax
  81067a:	0f 88 e2 00 00 00    	js     810762 <pipe+0x138>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810680:	83 ec 04             	sub    $0x4,%esp
  810683:	68 07 04 00 00       	push   $0x407
  810688:	ff 75 f0             	pushl  -0x10(%ebp)
  81068b:	6a 00                	push   $0x0
  81068d:	e8 19 e8 ff ff       	call   80eeab <sys_page_alloc>
  810692:	89 c3                	mov    %eax,%ebx
  810694:	83 c4 10             	add    $0x10,%esp
  810697:	85 c0                	test   %eax,%eax
  810699:	0f 88 c3 00 00 00    	js     810762 <pipe+0x138>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  81069f:	83 ec 0c             	sub    $0xc,%esp
  8106a2:	ff 75 f4             	pushl  -0xc(%ebp)
  8106a5:	e8 91 ee ff ff       	call   80f53b <fd2data>
  8106aa:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8106ac:	83 c4 0c             	add    $0xc,%esp
  8106af:	68 07 04 00 00       	push   $0x407
  8106b4:	50                   	push   %eax
  8106b5:	6a 00                	push   $0x0
  8106b7:	e8 ef e7 ff ff       	call   80eeab <sys_page_alloc>
  8106bc:	89 c3                	mov    %eax,%ebx
  8106be:	83 c4 10             	add    $0x10,%esp
  8106c1:	85 c0                	test   %eax,%eax
  8106c3:	0f 88 89 00 00 00    	js     810752 <pipe+0x128>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8106c9:	83 ec 0c             	sub    $0xc,%esp
  8106cc:	ff 75 f0             	pushl  -0x10(%ebp)
  8106cf:	e8 67 ee ff ff       	call   80f53b <fd2data>
  8106d4:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  8106db:	50                   	push   %eax
  8106dc:	6a 00                	push   $0x0
  8106de:	56                   	push   %esi
  8106df:	6a 00                	push   $0x0
  8106e1:	e8 08 e8 ff ff       	call   80eeee <sys_page_map>
  8106e6:	89 c3                	mov    %eax,%ebx
  8106e8:	83 c4 20             	add    $0x20,%esp
  8106eb:	85 c0                	test   %eax,%eax
  8106ed:	78 55                	js     810744 <pipe+0x11a>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  8106ef:	8b 15 24 43 81 00    	mov    0x814324,%edx
  8106f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8106f8:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  8106fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8106fd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  810704:	8b 15 24 43 81 00    	mov    0x814324,%edx
  81070a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81070d:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  81070f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810712:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  810719:	83 ec 0c             	sub    $0xc,%esp
  81071c:	ff 75 f4             	pushl  -0xc(%ebp)
  81071f:	e8 07 ee ff ff       	call   80f52b <fd2num>
  810724:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810727:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810729:	83 c4 04             	add    $0x4,%esp
  81072c:	ff 75 f0             	pushl  -0x10(%ebp)
  81072f:	e8 f7 ed ff ff       	call   80f52b <fd2num>
  810734:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810737:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  81073a:	83 c4 10             	add    $0x10,%esp
  81073d:	ba 00 00 00 00       	mov    $0x0,%edx
  810742:	eb 30                	jmp    810774 <pipe+0x14a>

    err3:
	sys_page_unmap(0, va);
  810744:	83 ec 08             	sub    $0x8,%esp
  810747:	56                   	push   %esi
  810748:	6a 00                	push   $0x0
  81074a:	e8 e1 e7 ff ff       	call   80ef30 <sys_page_unmap>
  81074f:	83 c4 10             	add    $0x10,%esp
    err2:
	sys_page_unmap(0, fd1);
  810752:	83 ec 08             	sub    $0x8,%esp
  810755:	ff 75 f0             	pushl  -0x10(%ebp)
  810758:	6a 00                	push   $0x0
  81075a:	e8 d1 e7 ff ff       	call   80ef30 <sys_page_unmap>
  81075f:	83 c4 10             	add    $0x10,%esp
    err1:
	sys_page_unmap(0, fd0);
  810762:	83 ec 08             	sub    $0x8,%esp
  810765:	ff 75 f4             	pushl  -0xc(%ebp)
  810768:	6a 00                	push   $0x0
  81076a:	e8 c1 e7 ff ff       	call   80ef30 <sys_page_unmap>
  81076f:	83 c4 10             	add    $0x10,%esp
  810772:	89 da                	mov    %ebx,%edx
    err:
	return r;
}
  810774:	89 d0                	mov    %edx,%eax
  810776:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810779:	5b                   	pop    %ebx
  81077a:	5e                   	pop    %esi
  81077b:	5d                   	pop    %ebp
  81077c:	c3                   	ret    

0081077d <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  81077d:	55                   	push   %ebp
  81077e:	89 e5                	mov    %esp,%ebp
  810780:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810783:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810786:	50                   	push   %eax
  810787:	ff 75 08             	pushl  0x8(%ebp)
  81078a:	e8 12 ee ff ff       	call   80f5a1 <fd_lookup>
  81078f:	83 c4 10             	add    $0x10,%esp
  810792:	85 c0                	test   %eax,%eax
  810794:	78 18                	js     8107ae <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  810796:	83 ec 0c             	sub    $0xc,%esp
  810799:	ff 75 f4             	pushl  -0xc(%ebp)
  81079c:	e8 9a ed ff ff       	call   80f53b <fd2data>
	return _pipeisclosed(fd, p);
  8107a1:	89 c2                	mov    %eax,%edx
  8107a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8107a6:	e8 21 fd ff ff       	call   8104cc <_pipeisclosed>
  8107ab:	83 c4 10             	add    $0x10,%esp
}
  8107ae:	c9                   	leave  
  8107af:	c3                   	ret    

008107b0 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  8107b0:	55                   	push   %ebp
  8107b1:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  8107b3:	b8 00 00 00 00       	mov    $0x0,%eax
  8107b8:	5d                   	pop    %ebp
  8107b9:	c3                   	ret    

008107ba <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  8107ba:	55                   	push   %ebp
  8107bb:	89 e5                	mov    %esp,%ebp
  8107bd:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  8107c0:	68 1c 38 81 00       	push   $0x81381c
  8107c5:	ff 75 0c             	pushl  0xc(%ebp)
  8107c8:	e8 db e2 ff ff       	call   80eaa8 <strcpy>
	return 0;
}
  8107cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8107d2:	c9                   	leave  
  8107d3:	c3                   	ret    

008107d4 <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8107d4:	55                   	push   %ebp
  8107d5:	89 e5                	mov    %esp,%ebp
  8107d7:	57                   	push   %edi
  8107d8:	56                   	push   %esi
  8107d9:	53                   	push   %ebx
  8107da:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8107e0:	be 00 00 00 00       	mov    $0x0,%esi
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8107e5:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8107eb:	eb 2d                	jmp    81081a <devcons_write+0x46>
		m = n - tot;
  8107ed:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8107f0:	29 f3                	sub    %esi,%ebx
		if (m > sizeof(buf) - 1)
  8107f2:	83 fb 7f             	cmp    $0x7f,%ebx
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  8107f5:	ba 7f 00 00 00       	mov    $0x7f,%edx
  8107fa:	0f 47 da             	cmova  %edx,%ebx
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8107fd:	83 ec 04             	sub    $0x4,%esp
  810800:	53                   	push   %ebx
  810801:	03 45 0c             	add    0xc(%ebp),%eax
  810804:	50                   	push   %eax
  810805:	57                   	push   %edi
  810806:	e8 2f e4 ff ff       	call   80ec3a <memmove>
		sys_cputs(buf, m);
  81080b:	83 c4 08             	add    $0x8,%esp
  81080e:	53                   	push   %ebx
  81080f:	57                   	push   %edi
  810810:	e8 da e5 ff ff       	call   80edef <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810815:	01 de                	add    %ebx,%esi
  810817:	83 c4 10             	add    $0x10,%esp
  81081a:	89 f0                	mov    %esi,%eax
  81081c:	3b 75 10             	cmp    0x10(%ebp),%esi
  81081f:	72 cc                	jb     8107ed <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  810821:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810824:	5b                   	pop    %ebx
  810825:	5e                   	pop    %esi
  810826:	5f                   	pop    %edi
  810827:	5d                   	pop    %ebp
  810828:	c3                   	ret    

00810829 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  810829:	55                   	push   %ebp
  81082a:	89 e5                	mov    %esp,%ebp
  81082c:	83 ec 08             	sub    $0x8,%esp
  81082f:	b8 00 00 00 00       	mov    $0x0,%eax
	int c;

	if (n == 0)
  810834:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810838:	74 2a                	je     810864 <devcons_read+0x3b>
  81083a:	eb 05                	jmp    810841 <devcons_read+0x18>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  81083c:	e8 4b e6 ff ff       	call   80ee8c <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  810841:	e8 c7 e5 ff ff       	call   80ee0d <sys_cgetc>
  810846:	85 c0                	test   %eax,%eax
  810848:	74 f2                	je     81083c <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  81084a:	85 c0                	test   %eax,%eax
  81084c:	78 16                	js     810864 <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  81084e:	83 f8 04             	cmp    $0x4,%eax
  810851:	74 0c                	je     81085f <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  810853:	8b 55 0c             	mov    0xc(%ebp),%edx
  810856:	88 02                	mov    %al,(%edx)
	return 1;
  810858:	b8 01 00 00 00       	mov    $0x1,%eax
  81085d:	eb 05                	jmp    810864 <devcons_read+0x3b>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  81085f:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  810864:	c9                   	leave  
  810865:	c3                   	ret    

00810866 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  810866:	55                   	push   %ebp
  810867:	89 e5                	mov    %esp,%ebp
  810869:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  81086c:	8b 45 08             	mov    0x8(%ebp),%eax
  81086f:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  810872:	6a 01                	push   $0x1
  810874:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810877:	50                   	push   %eax
  810878:	e8 72 e5 ff ff       	call   80edef <sys_cputs>
}
  81087d:	83 c4 10             	add    $0x10,%esp
  810880:	c9                   	leave  
  810881:	c3                   	ret    

00810882 <getchar>:

int
getchar(void)
{
  810882:	55                   	push   %ebp
  810883:	89 e5                	mov    %esp,%ebp
  810885:	83 ec 1c             	sub    $0x1c,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  810888:	6a 01                	push   $0x1
  81088a:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81088d:	50                   	push   %eax
  81088e:	6a 00                	push   $0x0
  810890:	e8 72 ef ff ff       	call   80f807 <read>
	if (r < 0)
  810895:	83 c4 10             	add    $0x10,%esp
  810898:	85 c0                	test   %eax,%eax
  81089a:	78 0f                	js     8108ab <getchar+0x29>
		return r;
	if (r < 1)
  81089c:	85 c0                	test   %eax,%eax
  81089e:	7e 06                	jle    8108a6 <getchar+0x24>
		return -E_EOF;
	return c;
  8108a0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  8108a4:	eb 05                	jmp    8108ab <getchar+0x29>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  8108a6:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  8108ab:	c9                   	leave  
  8108ac:	c3                   	ret    

008108ad <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8108ad:	55                   	push   %ebp
  8108ae:	89 e5                	mov    %esp,%ebp
  8108b0:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8108b3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8108b6:	50                   	push   %eax
  8108b7:	ff 75 08             	pushl  0x8(%ebp)
  8108ba:	e8 e2 ec ff ff       	call   80f5a1 <fd_lookup>
  8108bf:	83 c4 10             	add    $0x10,%esp
  8108c2:	85 c0                	test   %eax,%eax
  8108c4:	78 11                	js     8108d7 <iscons+0x2a>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  8108c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8108c9:	8b 15 40 43 81 00    	mov    0x814340,%edx
  8108cf:	39 10                	cmp    %edx,(%eax)
  8108d1:	0f 94 c0             	sete   %al
  8108d4:	0f b6 c0             	movzbl %al,%eax
}
  8108d7:	c9                   	leave  
  8108d8:	c3                   	ret    

008108d9 <opencons>:

int
opencons(void)
{
  8108d9:	55                   	push   %ebp
  8108da:	89 e5                	mov    %esp,%ebp
  8108dc:	83 ec 24             	sub    $0x24,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  8108df:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8108e2:	50                   	push   %eax
  8108e3:	e8 6a ec ff ff       	call   80f552 <fd_alloc>
  8108e8:	83 c4 10             	add    $0x10,%esp
		return r;
  8108eb:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  8108ed:	85 c0                	test   %eax,%eax
  8108ef:	78 3e                	js     81092f <opencons+0x56>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8108f1:	83 ec 04             	sub    $0x4,%esp
  8108f4:	68 07 04 00 00       	push   $0x407
  8108f9:	ff 75 f4             	pushl  -0xc(%ebp)
  8108fc:	6a 00                	push   $0x0
  8108fe:	e8 a8 e5 ff ff       	call   80eeab <sys_page_alloc>
  810903:	83 c4 10             	add    $0x10,%esp
		return r;
  810906:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810908:	85 c0                	test   %eax,%eax
  81090a:	78 23                	js     81092f <opencons+0x56>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  81090c:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810912:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810915:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810917:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81091a:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810921:	83 ec 0c             	sub    $0xc,%esp
  810924:	50                   	push   %eax
  810925:	e8 01 ec ff ff       	call   80f52b <fd2num>
  81092a:	89 c2                	mov    %eax,%edx
  81092c:	83 c4 10             	add    $0x10,%esp
}
  81092f:	89 d0                	mov    %edx,%eax
  810931:	c9                   	leave  
  810932:	c3                   	ret    

00810933 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810933:	55                   	push   %ebp
  810934:	89 e5                	mov    %esp,%ebp
  810936:	53                   	push   %ebx
  810937:	83 ec 04             	sub    $0x4,%esp
	int r;

	if (_pgfault_handler == 0) {
  81093a:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810941:	75 28                	jne    81096b <set_pgfault_handler+0x38>
		// First time through!
		// LAB 4: Your code here.
		envid_t envid = sys_getenvid();
  810943:	e8 25 e5 ff ff       	call   80ee6d <sys_getenvid>
  810948:	89 c3                	mov    %eax,%ebx
		sys_page_alloc(envid, (void *) (UXSTACKTOP - PGSIZE), PTE_U | PTE_W);
  81094a:	83 ec 04             	sub    $0x4,%esp
  81094d:	6a 06                	push   $0x6
  81094f:	68 00 f0 bf ee       	push   $0xeebff000
  810954:	50                   	push   %eax
  810955:	e8 51 e5 ff ff       	call   80eeab <sys_page_alloc>
		sys_env_set_pgfault_upcall(envid, (void *) _pgfault_upcall);
  81095a:	83 c4 08             	add    $0x8,%esp
  81095d:	68 78 09 81 00       	push   $0x810978
  810962:	53                   	push   %ebx
  810963:	e8 8e e6 ff ff       	call   80eff6 <sys_env_set_pgfault_upcall>
  810968:	83 c4 10             	add    $0x10,%esp
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  81096b:	8b 45 08             	mov    0x8(%ebp),%eax
  81096e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  810973:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810976:	c9                   	leave  
  810977:	c3                   	ret    

00810978 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810978:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810979:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  81097e:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810980:	83 c4 04             	add    $0x4,%esp
	//
	// LAB 4: Your code here.

	# My method is different. Copy the values to the other stack
	# in a convinient way, and then pop everything.
	movl %esp, %ebp		# ebp refers to the exception stack
  810983:	89 e5                	mov    %esp,%ebp
	movl 48(%ebp), %esp 	# go to other stack
  810985:	8b 65 30             	mov    0x30(%ebp),%esp

	pushl 40(%ebp)		# eip - ORDER SWITCHED WITH EFLAGS
  810988:	ff 75 28             	pushl  0x28(%ebp)
	pushl 44(%ebp)      	# eflags
  81098b:	ff 75 2c             	pushl  0x2c(%ebp)
	pushl 36(%ebp)		# all the 8 remaining regs
  81098e:	ff 75 24             	pushl  0x24(%ebp)
	pushl 32(%ebp)
  810991:	ff 75 20             	pushl  0x20(%ebp)
	pushl 28(%ebp)
  810994:	ff 75 1c             	pushl  0x1c(%ebp)
	pushl 24(%ebp)
  810997:	ff 75 18             	pushl  0x18(%ebp)
	pushl 20(%ebp)
  81099a:	ff 75 14             	pushl  0x14(%ebp)
	pushl 16(%ebp)
  81099d:	ff 75 10             	pushl  0x10(%ebp)
	pushl 12(%ebp)
  8109a0:	ff 75 0c             	pushl  0xc(%ebp)
	pushl 8(%ebp)
  8109a3:	ff 75 08             	pushl  0x8(%ebp)

	popal			# now just pop everything!
  8109a6:	61                   	popa   
	popfl
  8109a7:	9d                   	popf   
	ret
  8109a8:	c3                   	ret    

008109a9 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  8109a9:	55                   	push   %ebp
  8109aa:	89 e5                	mov    %esp,%ebp
  8109ac:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  8109af:	89 d0                	mov    %edx,%eax
  8109b1:	c1 e8 16             	shr    $0x16,%eax
  8109b4:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  8109bb:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  8109c0:	f6 c1 01             	test   $0x1,%cl
  8109c3:	74 1d                	je     8109e2 <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  8109c5:	c1 ea 0c             	shr    $0xc,%edx
  8109c8:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  8109cf:	f6 c2 01             	test   $0x1,%dl
  8109d2:	74 0e                	je     8109e2 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  8109d4:	c1 ea 0c             	shr    $0xc,%edx
  8109d7:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  8109de:	ef 
  8109df:	0f b7 c0             	movzwl %ax,%eax
}
  8109e2:	5d                   	pop    %ebp
  8109e3:	c3                   	ret    
  8109e4:	66 90                	xchg   %ax,%ax
  8109e6:	66 90                	xchg   %ax,%ax
  8109e8:	66 90                	xchg   %ax,%ax
  8109ea:	66 90                	xchg   %ax,%ax
  8109ec:	66 90                	xchg   %ax,%ax
  8109ee:	66 90                	xchg   %ax,%ax

008109f0 <__udivdi3>:
  8109f0:	55                   	push   %ebp
  8109f1:	57                   	push   %edi
  8109f2:	56                   	push   %esi
  8109f3:	53                   	push   %ebx
  8109f4:	83 ec 1c             	sub    $0x1c,%esp
  8109f7:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  8109fb:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  8109ff:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  810a03:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810a07:	85 f6                	test   %esi,%esi
  810a09:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810a0d:	89 ca                	mov    %ecx,%edx
  810a0f:	89 f8                	mov    %edi,%eax
  810a11:	75 3d                	jne    810a50 <__udivdi3+0x60>
  810a13:	39 cf                	cmp    %ecx,%edi
  810a15:	0f 87 c5 00 00 00    	ja     810ae0 <__udivdi3+0xf0>
  810a1b:	85 ff                	test   %edi,%edi
  810a1d:	89 fd                	mov    %edi,%ebp
  810a1f:	75 0b                	jne    810a2c <__udivdi3+0x3c>
  810a21:	b8 01 00 00 00       	mov    $0x1,%eax
  810a26:	31 d2                	xor    %edx,%edx
  810a28:	f7 f7                	div    %edi
  810a2a:	89 c5                	mov    %eax,%ebp
  810a2c:	89 c8                	mov    %ecx,%eax
  810a2e:	31 d2                	xor    %edx,%edx
  810a30:	f7 f5                	div    %ebp
  810a32:	89 c1                	mov    %eax,%ecx
  810a34:	89 d8                	mov    %ebx,%eax
  810a36:	89 cf                	mov    %ecx,%edi
  810a38:	f7 f5                	div    %ebp
  810a3a:	89 c3                	mov    %eax,%ebx
  810a3c:	89 d8                	mov    %ebx,%eax
  810a3e:	89 fa                	mov    %edi,%edx
  810a40:	83 c4 1c             	add    $0x1c,%esp
  810a43:	5b                   	pop    %ebx
  810a44:	5e                   	pop    %esi
  810a45:	5f                   	pop    %edi
  810a46:	5d                   	pop    %ebp
  810a47:	c3                   	ret    
  810a48:	90                   	nop
  810a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810a50:	39 ce                	cmp    %ecx,%esi
  810a52:	77 74                	ja     810ac8 <__udivdi3+0xd8>
  810a54:	0f bd fe             	bsr    %esi,%edi
  810a57:	83 f7 1f             	xor    $0x1f,%edi
  810a5a:	0f 84 98 00 00 00    	je     810af8 <__udivdi3+0x108>
  810a60:	bb 20 00 00 00       	mov    $0x20,%ebx
  810a65:	89 f9                	mov    %edi,%ecx
  810a67:	89 c5                	mov    %eax,%ebp
  810a69:	29 fb                	sub    %edi,%ebx
  810a6b:	d3 e6                	shl    %cl,%esi
  810a6d:	89 d9                	mov    %ebx,%ecx
  810a6f:	d3 ed                	shr    %cl,%ebp
  810a71:	89 f9                	mov    %edi,%ecx
  810a73:	d3 e0                	shl    %cl,%eax
  810a75:	09 ee                	or     %ebp,%esi
  810a77:	89 d9                	mov    %ebx,%ecx
  810a79:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810a7d:	89 d5                	mov    %edx,%ebp
  810a7f:	8b 44 24 08          	mov    0x8(%esp),%eax
  810a83:	d3 ed                	shr    %cl,%ebp
  810a85:	89 f9                	mov    %edi,%ecx
  810a87:	d3 e2                	shl    %cl,%edx
  810a89:	89 d9                	mov    %ebx,%ecx
  810a8b:	d3 e8                	shr    %cl,%eax
  810a8d:	09 c2                	or     %eax,%edx
  810a8f:	89 d0                	mov    %edx,%eax
  810a91:	89 ea                	mov    %ebp,%edx
  810a93:	f7 f6                	div    %esi
  810a95:	89 d5                	mov    %edx,%ebp
  810a97:	89 c3                	mov    %eax,%ebx
  810a99:	f7 64 24 0c          	mull   0xc(%esp)
  810a9d:	39 d5                	cmp    %edx,%ebp
  810a9f:	72 10                	jb     810ab1 <__udivdi3+0xc1>
  810aa1:	8b 74 24 08          	mov    0x8(%esp),%esi
  810aa5:	89 f9                	mov    %edi,%ecx
  810aa7:	d3 e6                	shl    %cl,%esi
  810aa9:	39 c6                	cmp    %eax,%esi
  810aab:	73 07                	jae    810ab4 <__udivdi3+0xc4>
  810aad:	39 d5                	cmp    %edx,%ebp
  810aaf:	75 03                	jne    810ab4 <__udivdi3+0xc4>
  810ab1:	83 eb 01             	sub    $0x1,%ebx
  810ab4:	31 ff                	xor    %edi,%edi
  810ab6:	89 d8                	mov    %ebx,%eax
  810ab8:	89 fa                	mov    %edi,%edx
  810aba:	83 c4 1c             	add    $0x1c,%esp
  810abd:	5b                   	pop    %ebx
  810abe:	5e                   	pop    %esi
  810abf:	5f                   	pop    %edi
  810ac0:	5d                   	pop    %ebp
  810ac1:	c3                   	ret    
  810ac2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810ac8:	31 ff                	xor    %edi,%edi
  810aca:	31 db                	xor    %ebx,%ebx
  810acc:	89 d8                	mov    %ebx,%eax
  810ace:	89 fa                	mov    %edi,%edx
  810ad0:	83 c4 1c             	add    $0x1c,%esp
  810ad3:	5b                   	pop    %ebx
  810ad4:	5e                   	pop    %esi
  810ad5:	5f                   	pop    %edi
  810ad6:	5d                   	pop    %ebp
  810ad7:	c3                   	ret    
  810ad8:	90                   	nop
  810ad9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810ae0:	89 d8                	mov    %ebx,%eax
  810ae2:	f7 f7                	div    %edi
  810ae4:	31 ff                	xor    %edi,%edi
  810ae6:	89 c3                	mov    %eax,%ebx
  810ae8:	89 d8                	mov    %ebx,%eax
  810aea:	89 fa                	mov    %edi,%edx
  810aec:	83 c4 1c             	add    $0x1c,%esp
  810aef:	5b                   	pop    %ebx
  810af0:	5e                   	pop    %esi
  810af1:	5f                   	pop    %edi
  810af2:	5d                   	pop    %ebp
  810af3:	c3                   	ret    
  810af4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810af8:	39 ce                	cmp    %ecx,%esi
  810afa:	72 0c                	jb     810b08 <__udivdi3+0x118>
  810afc:	31 db                	xor    %ebx,%ebx
  810afe:	3b 44 24 08          	cmp    0x8(%esp),%eax
  810b02:	0f 87 34 ff ff ff    	ja     810a3c <__udivdi3+0x4c>
  810b08:	bb 01 00 00 00       	mov    $0x1,%ebx
  810b0d:	e9 2a ff ff ff       	jmp    810a3c <__udivdi3+0x4c>
  810b12:	66 90                	xchg   %ax,%ax
  810b14:	66 90                	xchg   %ax,%ax
  810b16:	66 90                	xchg   %ax,%ax
  810b18:	66 90                	xchg   %ax,%ax
  810b1a:	66 90                	xchg   %ax,%ax
  810b1c:	66 90                	xchg   %ax,%ax
  810b1e:	66 90                	xchg   %ax,%ax

00810b20 <__umoddi3>:
  810b20:	55                   	push   %ebp
  810b21:	57                   	push   %edi
  810b22:	56                   	push   %esi
  810b23:	53                   	push   %ebx
  810b24:	83 ec 1c             	sub    $0x1c,%esp
  810b27:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810b2b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  810b2f:	8b 74 24 34          	mov    0x34(%esp),%esi
  810b33:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810b37:	85 d2                	test   %edx,%edx
  810b39:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  810b3d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810b41:	89 f3                	mov    %esi,%ebx
  810b43:	89 3c 24             	mov    %edi,(%esp)
  810b46:	89 74 24 04          	mov    %esi,0x4(%esp)
  810b4a:	75 1c                	jne    810b68 <__umoddi3+0x48>
  810b4c:	39 f7                	cmp    %esi,%edi
  810b4e:	76 50                	jbe    810ba0 <__umoddi3+0x80>
  810b50:	89 c8                	mov    %ecx,%eax
  810b52:	89 f2                	mov    %esi,%edx
  810b54:	f7 f7                	div    %edi
  810b56:	89 d0                	mov    %edx,%eax
  810b58:	31 d2                	xor    %edx,%edx
  810b5a:	83 c4 1c             	add    $0x1c,%esp
  810b5d:	5b                   	pop    %ebx
  810b5e:	5e                   	pop    %esi
  810b5f:	5f                   	pop    %edi
  810b60:	5d                   	pop    %ebp
  810b61:	c3                   	ret    
  810b62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810b68:	39 f2                	cmp    %esi,%edx
  810b6a:	89 d0                	mov    %edx,%eax
  810b6c:	77 52                	ja     810bc0 <__umoddi3+0xa0>
  810b6e:	0f bd ea             	bsr    %edx,%ebp
  810b71:	83 f5 1f             	xor    $0x1f,%ebp
  810b74:	75 5a                	jne    810bd0 <__umoddi3+0xb0>
  810b76:	3b 54 24 04          	cmp    0x4(%esp),%edx
  810b7a:	0f 82 e0 00 00 00    	jb     810c60 <__umoddi3+0x140>
  810b80:	39 0c 24             	cmp    %ecx,(%esp)
  810b83:	0f 86 d7 00 00 00    	jbe    810c60 <__umoddi3+0x140>
  810b89:	8b 44 24 08          	mov    0x8(%esp),%eax
  810b8d:	8b 54 24 04          	mov    0x4(%esp),%edx
  810b91:	83 c4 1c             	add    $0x1c,%esp
  810b94:	5b                   	pop    %ebx
  810b95:	5e                   	pop    %esi
  810b96:	5f                   	pop    %edi
  810b97:	5d                   	pop    %ebp
  810b98:	c3                   	ret    
  810b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810ba0:	85 ff                	test   %edi,%edi
  810ba2:	89 fd                	mov    %edi,%ebp
  810ba4:	75 0b                	jne    810bb1 <__umoddi3+0x91>
  810ba6:	b8 01 00 00 00       	mov    $0x1,%eax
  810bab:	31 d2                	xor    %edx,%edx
  810bad:	f7 f7                	div    %edi
  810baf:	89 c5                	mov    %eax,%ebp
  810bb1:	89 f0                	mov    %esi,%eax
  810bb3:	31 d2                	xor    %edx,%edx
  810bb5:	f7 f5                	div    %ebp
  810bb7:	89 c8                	mov    %ecx,%eax
  810bb9:	f7 f5                	div    %ebp
  810bbb:	89 d0                	mov    %edx,%eax
  810bbd:	eb 99                	jmp    810b58 <__umoddi3+0x38>
  810bbf:	90                   	nop
  810bc0:	89 c8                	mov    %ecx,%eax
  810bc2:	89 f2                	mov    %esi,%edx
  810bc4:	83 c4 1c             	add    $0x1c,%esp
  810bc7:	5b                   	pop    %ebx
  810bc8:	5e                   	pop    %esi
  810bc9:	5f                   	pop    %edi
  810bca:	5d                   	pop    %ebp
  810bcb:	c3                   	ret    
  810bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810bd0:	8b 34 24             	mov    (%esp),%esi
  810bd3:	bf 20 00 00 00       	mov    $0x20,%edi
  810bd8:	89 e9                	mov    %ebp,%ecx
  810bda:	29 ef                	sub    %ebp,%edi
  810bdc:	d3 e0                	shl    %cl,%eax
  810bde:	89 f9                	mov    %edi,%ecx
  810be0:	89 f2                	mov    %esi,%edx
  810be2:	d3 ea                	shr    %cl,%edx
  810be4:	89 e9                	mov    %ebp,%ecx
  810be6:	09 c2                	or     %eax,%edx
  810be8:	89 d8                	mov    %ebx,%eax
  810bea:	89 14 24             	mov    %edx,(%esp)
  810bed:	89 f2                	mov    %esi,%edx
  810bef:	d3 e2                	shl    %cl,%edx
  810bf1:	89 f9                	mov    %edi,%ecx
  810bf3:	89 54 24 04          	mov    %edx,0x4(%esp)
  810bf7:	8b 54 24 0c          	mov    0xc(%esp),%edx
  810bfb:	d3 e8                	shr    %cl,%eax
  810bfd:	89 e9                	mov    %ebp,%ecx
  810bff:	89 c6                	mov    %eax,%esi
  810c01:	d3 e3                	shl    %cl,%ebx
  810c03:	89 f9                	mov    %edi,%ecx
  810c05:	89 d0                	mov    %edx,%eax
  810c07:	d3 e8                	shr    %cl,%eax
  810c09:	89 e9                	mov    %ebp,%ecx
  810c0b:	09 d8                	or     %ebx,%eax
  810c0d:	89 d3                	mov    %edx,%ebx
  810c0f:	89 f2                	mov    %esi,%edx
  810c11:	f7 34 24             	divl   (%esp)
  810c14:	89 d6                	mov    %edx,%esi
  810c16:	d3 e3                	shl    %cl,%ebx
  810c18:	f7 64 24 04          	mull   0x4(%esp)
  810c1c:	39 d6                	cmp    %edx,%esi
  810c1e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810c22:	89 d1                	mov    %edx,%ecx
  810c24:	89 c3                	mov    %eax,%ebx
  810c26:	72 08                	jb     810c30 <__umoddi3+0x110>
  810c28:	75 11                	jne    810c3b <__umoddi3+0x11b>
  810c2a:	39 44 24 08          	cmp    %eax,0x8(%esp)
  810c2e:	73 0b                	jae    810c3b <__umoddi3+0x11b>
  810c30:	2b 44 24 04          	sub    0x4(%esp),%eax
  810c34:	1b 14 24             	sbb    (%esp),%edx
  810c37:	89 d1                	mov    %edx,%ecx
  810c39:	89 c3                	mov    %eax,%ebx
  810c3b:	8b 54 24 08          	mov    0x8(%esp),%edx
  810c3f:	29 da                	sub    %ebx,%edx
  810c41:	19 ce                	sbb    %ecx,%esi
  810c43:	89 f9                	mov    %edi,%ecx
  810c45:	89 f0                	mov    %esi,%eax
  810c47:	d3 e0                	shl    %cl,%eax
  810c49:	89 e9                	mov    %ebp,%ecx
  810c4b:	d3 ea                	shr    %cl,%edx
  810c4d:	89 e9                	mov    %ebp,%ecx
  810c4f:	d3 ee                	shr    %cl,%esi
  810c51:	09 d0                	or     %edx,%eax
  810c53:	89 f2                	mov    %esi,%edx
  810c55:	83 c4 1c             	add    $0x1c,%esp
  810c58:	5b                   	pop    %ebx
  810c59:	5e                   	pop    %esi
  810c5a:	5f                   	pop    %edi
  810c5b:	5d                   	pop    %ebp
  810c5c:	c3                   	ret    
  810c5d:	8d 76 00             	lea    0x0(%esi),%esi
  810c60:	29 f9                	sub    %edi,%ecx
  810c62:	19 d6                	sbb    %edx,%esi
  810c64:	89 74 24 04          	mov    %esi,0x4(%esp)
  810c68:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810c6c:	e9 18 ff ff ff       	jmp    810b89 <__umoddi3+0x69>
