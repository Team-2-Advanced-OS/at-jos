First function
-----------------------------------------------------------------------------------------------------------------------

boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}
	
	if (n==0) //--------------------------------------------------------------------------------------> Change 1 start
	{
	return nextfree;
cprintf("n==0 loop\n");
	}
	if(n>0)
	{
	 char* next = nextfree;
cprintf("nextfree(old)--> %08x\n",nextfree);
cprintf("n-->%08x\n",n);
	//nextfree = nextfree+n;
	nextfree = ROUNDUP((char *) (nextfree+n), PGSIZE);
	cprintf("n>0 loop\n");
	cprintf("nextfree-->%08x",nextfree);
	return next;
	} //------------------------------------------------------------------------------------------------> Change 1 end


	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.

	return NULL;

}

allcation of the physical page array.
------------------------------------------------------------------------------------------------------------------------------
pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);
memset(pages, 0, sizeof(struct PageInfo) * npages);



Function 2
-------------------------------------------------------------------------------------------------------------------------------

void
page_init(void)
{

	 size_t i;
    for (i = 1; i < npages_basemem; i++) {
//cprintf("i is %d",i);
//cprintf("npages_basemem is %d",npages_basemem);

       pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
    int med = (int)ROUNDUP(((char*)pages) + (sizeof(struct PageInfo) * npages) - 0xf0000000, PGSIZE)/PGSIZE;
    cprintf("%d\n", ((char*)pages) + (sizeof(struct PageInfo) * npages));
    cprintf("med=%d\n", med);
    for (i = med; i < npages; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }


cprintf("reached point 3\n");
}

Function 3
----------------------------------------------------------------------------------------------------------------------------------

struct PageInfo *
page_alloc(int alloc_flags)
{

if (page_free_list) {
        struct PageInfo *returned_page = page_free_list;
        page_free_list = page_free_list->pp_link;
        if (alloc_flags & ALLOC_ZERO) 
            memset(page2kva(returned_page), 0, PGSIZE);
	returned_page->pp_link = NULL;
        return returned_page;
    }
    return NULL;




	// Fill this function in
	//return 0;
}


Function 4
--------------------------------------------------------------------------------------------------------------------------------------
void
page_free(struct PageInfo *pp)
{

if(pp->pp_ref != 0 || pp->pp_link != NULL ){
panic("page_free:Page might be in use\n");
//page_decref(pp);


}

pp->pp_link = page_free_list;
    page_free_list = pp;


	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
//cprintf("reached end of page_free\n");
}












































